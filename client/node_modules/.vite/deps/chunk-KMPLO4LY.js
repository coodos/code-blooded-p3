import {
  __commonJS,
  __require
} from "./chunk-BHN6OJC3.js";

// ../node_modules/ajv-dist/dist/ajv7.min.js
var require_ajv7_min = __commonJS({
  "../node_modules/ajv-dist/dist/ajv7.min.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).ajv7 = e();
      }
    }(function() {
      return function e(t, r, o) {
        function s(n2, i) {
          if (!r[n2]) {
            if (!t[n2]) {
              var c = "function" == typeof __require && __require;
              if (!i && c)
                return c(n2, true);
              if (a)
                return a(n2, true);
              var l = new Error("Cannot find module '" + n2 + "'");
              throw l.code = "MODULE_NOT_FOUND", l;
            }
            var d = r[n2] = { exports: {} };
            t[n2][0].call(d.exports, function(e2) {
              return s(t[n2][1][e2] || e2);
            }, d, d.exports, e, t, r, o);
          }
          return r[n2].exports;
        }
        for (var a = "function" == typeof __require && __require, n = 0; n < o.length; n++)
          s(o[n]);
        return s;
      }({ 1: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.regexpCode = r.getEsmExportName = r.getProperty = r.safeStringify = r.stringify = r.strConcat = r.addCodeArg = r.str = r._ = r.nil = r._Code = r.Name = r.IDENTIFIER = r._CodeOrName = void 0;
        class o {
        }
        r._CodeOrName = o, r.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class s extends o {
          constructor(e2) {
            if (super(), !r.IDENTIFIER.test(e2))
              throw new Error("CodeGen: name must be a valid identifier");
            this.str = e2;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            return false;
          }
          get names() {
            return { [this.str]: 1 };
          }
        }
        r.Name = s;
        class a extends o {
          constructor(e2) {
            super(), this._items = "string" == typeof e2 ? [e2] : e2;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            if (this._items.length > 1)
              return false;
            const e2 = this._items[0];
            return "" === e2 || '""' === e2;
          }
          get str() {
            var e2;
            return null !== (e2 = this._str) && void 0 !== e2 ? e2 : this._str = this._items.reduce((e3, t2) => `${e3}${t2}`, "");
          }
          get names() {
            var e2;
            return null !== (e2 = this._names) && void 0 !== e2 ? e2 : this._names = this._items.reduce((e3, t2) => (t2 instanceof s && (e3[t2.str] = (e3[t2.str] || 0) + 1), e3), {});
          }
        }
        function n(e2, ...t2) {
          const r2 = [e2[0]];
          let o2 = 0;
          for (; o2 < t2.length; )
            l(r2, t2[o2]), r2.push(e2[++o2]);
          return new a(r2);
        }
        r._Code = a, r.nil = new a(""), r._ = n;
        const i = new a("+");
        function c(e2, ...t2) {
          const r2 = [u(e2[0])];
          let o2 = 0;
          for (; o2 < t2.length; )
            r2.push(i), l(r2, t2[o2]), r2.push(i, u(e2[++o2]));
          return function(e3) {
            let t3 = 1;
            for (; t3 < e3.length - 1; ) {
              if (e3[t3] === i) {
                const r3 = d(e3[t3 - 1], e3[t3 + 1]);
                if (void 0 !== r3) {
                  e3.splice(t3 - 1, 3, r3);
                  continue;
                }
                e3[t3++] = "+";
              }
              t3++;
            }
          }(r2), new a(r2);
        }
        function l(e2, t2) {
          var r2;
          t2 instanceof a ? e2.push(...t2._items) : e2.push(t2 instanceof s ? t2 : "number" == typeof (r2 = t2) || "boolean" == typeof r2 || null === r2 ? r2 : u(Array.isArray(r2) ? r2.join(",") : r2));
        }
        function d(e2, t2) {
          if ('""' === t2)
            return e2;
          if ('""' === e2)
            return t2;
          if ("string" == typeof e2) {
            if (t2 instanceof s || '"' !== e2[e2.length - 1])
              return;
            return "string" != typeof t2 ? `${e2.slice(0, -1)}${t2}"` : '"' === t2[0] ? e2.slice(0, -1) + t2.slice(1) : void 0;
          }
          return "string" != typeof t2 || '"' !== t2[0] || e2 instanceof s ? void 0 : `"${e2}${t2.slice(1)}`;
        }
        function u(e2) {
          return JSON.stringify(e2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        r.str = c, r.addCodeArg = l, r.strConcat = function(e2, t2) {
          return t2.emptyStr() ? e2 : e2.emptyStr() ? t2 : c`${e2}${t2}`;
        }, r.stringify = function(e2) {
          return new a(u(e2));
        }, r.safeStringify = u, r.getProperty = function(e2) {
          return "string" == typeof e2 && r.IDENTIFIER.test(e2) ? new a(`.${e2}`) : n`[${e2}]`;
        }, r.getEsmExportName = function(e2) {
          if ("string" == typeof e2 && r.IDENTIFIER.test(e2))
            return new a(`${e2}`);
          throw new Error(`CodeGen: invalid export name: ${e2}, use explicit $id name mapping`);
        }, r.regexpCode = function(e2) {
          return new a(e2.toString());
        };
      }, {}], 2: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.or = r.and = r.not = r.CodeGen = r.operators = r.varKinds = r.ValueScopeName = r.ValueScope = r.Scope = r.Name = r.regexpCode = r.stringify = r.getProperty = r.nil = r.strConcat = r.str = r._ = void 0;
        const o = e("./code"), s = e("./scope");
        var a = e("./code");
        Object.defineProperty(r, "_", { enumerable: true, get() {
          return a._;
        } }), Object.defineProperty(r, "str", { enumerable: true, get() {
          return a.str;
        } }), Object.defineProperty(r, "strConcat", { enumerable: true, get() {
          return a.strConcat;
        } }), Object.defineProperty(r, "nil", { enumerable: true, get() {
          return a.nil;
        } }), Object.defineProperty(r, "getProperty", { enumerable: true, get() {
          return a.getProperty;
        } }), Object.defineProperty(r, "stringify", { enumerable: true, get() {
          return a.stringify;
        } }), Object.defineProperty(r, "regexpCode", { enumerable: true, get() {
          return a.regexpCode;
        } }), Object.defineProperty(r, "Name", { enumerable: true, get() {
          return a.Name;
        } });
        var n = e("./scope");
        Object.defineProperty(r, "Scope", { enumerable: true, get() {
          return n.Scope;
        } }), Object.defineProperty(r, "ValueScope", { enumerable: true, get() {
          return n.ValueScope;
        } }), Object.defineProperty(r, "ValueScopeName", { enumerable: true, get() {
          return n.ValueScopeName;
        } }), Object.defineProperty(r, "varKinds", { enumerable: true, get() {
          return n.varKinds;
        } }), r.operators = { GT: new o._Code(">"), GTE: new o._Code(">="), LT: new o._Code("<"), LTE: new o._Code("<="), EQ: new o._Code("==="), NEQ: new o._Code("!=="), NOT: new o._Code("!"), OR: new o._Code("||"), AND: new o._Code("&&"), ADD: new o._Code("+") };
        class i {
          optimizeNodes() {
            return this;
          }
          optimizeNames(e2, t2) {
            return this;
          }
        }
        class c extends i {
          constructor(e2, t2, r2) {
            super(), this.varKind = e2, this.name = t2, this.rhs = r2;
          }
          render({ es5: e2, _n: t2 }) {
            return `${e2 ? s.varKinds.var : this.varKind} ${this.name}${void 0 === this.rhs ? "" : ` = ${this.rhs}`};` + t2;
          }
          optimizeNames(e2, t2) {
            if (e2[this.name.str])
              return this.rhs && (this.rhs = x(this.rhs, e2, t2)), this;
          }
          get names() {
            return this.rhs instanceof o._CodeOrName ? this.rhs.names : {};
          }
        }
        class l extends i {
          constructor(e2, t2, r2) {
            super(), this.lhs = e2, this.rhs = t2, this.sideEffects = r2;
          }
          render({ _n: e2 }) {
            return `${this.lhs} = ${this.rhs};` + e2;
          }
          optimizeNames(e2, t2) {
            if (!(this.lhs instanceof o.Name) || e2[this.lhs.str] || this.sideEffects)
              return this.rhs = x(this.rhs, e2, t2), this;
          }
          get names() {
            return O(this.lhs instanceof o.Name ? {} : { ...this.lhs.names }, this.rhs);
          }
        }
        class d extends l {
          constructor(e2, t2, r2, o2) {
            super(e2, r2, o2), this.op = t2;
          }
          render({ _n: e2 }) {
            return `${this.lhs} ${this.op}= ${this.rhs};` + e2;
          }
        }
        class u extends i {
          constructor(e2) {
            super(), this.label = e2, this.names = {};
          }
          render({ _n: e2 }) {
            return `${this.label}:` + e2;
          }
        }
        class f extends i {
          constructor(e2) {
            super(), this.label = e2, this.names = {};
          }
          render({ _n: e2 }) {
            return `break${this.label ? ` ${this.label}` : ""};` + e2;
          }
        }
        class p extends i {
          constructor(e2) {
            super(), this.error = e2;
          }
          render({ _n: e2 }) {
            return `throw ${this.error};` + e2;
          }
          get names() {
            return this.error.names;
          }
        }
        class m extends i {
          constructor(e2) {
            super(), this.code = e2;
          }
          render({ _n: e2 }) {
            return `${this.code};` + e2;
          }
          optimizeNodes() {
            return `${this.code}` ? this : void 0;
          }
          optimizeNames(e2, t2) {
            return this.code = x(this.code, e2, t2), this;
          }
          get names() {
            return this.code instanceof o._CodeOrName ? this.code.names : {};
          }
        }
        class h extends i {
          constructor(e2 = []) {
            super(), this.nodes = e2;
          }
          render(e2) {
            return this.nodes.reduce((t2, r2) => t2 + r2.render(e2), "");
          }
          optimizeNodes() {
            const { nodes: e2 } = this;
            let t2 = e2.length;
            for (; t2--; ) {
              const r2 = e2[t2].optimizeNodes();
              Array.isArray(r2) ? e2.splice(t2, 1, ...r2) : r2 ? e2[t2] = r2 : e2.splice(t2, 1);
            }
            return e2.length > 0 ? this : void 0;
          }
          optimizeNames(e2, t2) {
            const { nodes: r2 } = this;
            let o2 = r2.length;
            for (; o2--; ) {
              const s2 = r2[o2];
              s2.optimizeNames(e2, t2) || (T(e2, s2.names), r2.splice(o2, 1));
            }
            return r2.length > 0 ? this : void 0;
          }
          get names() {
            return this.nodes.reduce((e2, t2) => C(e2, t2.names), {});
          }
        }
        class y extends h {
          render(e2) {
            return "{" + e2._n + super.render(e2) + "}" + e2._n;
          }
        }
        class v extends h {
        }
        class g extends y {
        }
        g.kind = "else";
        class $ extends y {
          constructor(e2, t2) {
            super(t2), this.condition = e2;
          }
          render(e2) {
            let t2 = `if(${this.condition})` + super.render(e2);
            return this.else && (t2 += "else " + this.else.render(e2)), t2;
          }
          optimizeNodes() {
            super.optimizeNodes();
            const e2 = this.condition;
            if (true === e2)
              return this.nodes;
            let t2 = this.else;
            if (t2) {
              const e3 = t2.optimizeNodes();
              t2 = this.else = Array.isArray(e3) ? new g(e3) : e3;
            }
            return t2 ? false === e2 ? t2 instanceof $ ? t2 : t2.nodes : this.nodes.length ? this : new $(I(e2), t2 instanceof $ ? [t2] : t2.nodes) : false !== e2 && this.nodes.length ? this : void 0;
          }
          optimizeNames(e2, t2) {
            var r2;
            if (this.else = null === (r2 = this.else) || void 0 === r2 ? void 0 : r2.optimizeNames(e2, t2), super.optimizeNames(e2, t2) || this.else)
              return this.condition = x(this.condition, e2, t2), this;
          }
          get names() {
            const e2 = super.names;
            return O(e2, this.condition), this.else && C(e2, this.else.names), e2;
          }
        }
        $.kind = "if";
        class _ extends y {
        }
        _.kind = "for";
        class w extends _ {
          constructor(e2) {
            super(), this.iteration = e2;
          }
          render(e2) {
            return `for(${this.iteration})` + super.render(e2);
          }
          optimizeNames(e2, t2) {
            if (super.optimizeNames(e2, t2))
              return this.iteration = x(this.iteration, e2, t2), this;
          }
          get names() {
            return C(super.names, this.iteration.names);
          }
        }
        class b extends _ {
          constructor(e2, t2, r2, o2) {
            super(), this.varKind = e2, this.name = t2, this.from = r2, this.to = o2;
          }
          render(e2) {
            const t2 = e2.es5 ? s.varKinds.var : this.varKind, { name: r2, from: o2, to: a2 } = this;
            return `for(${t2} ${r2}=${o2}; ${r2}<${a2}; ${r2}++)` + super.render(e2);
          }
          get names() {
            const e2 = O(super.names, this.from);
            return O(e2, this.to);
          }
        }
        class E extends _ {
          constructor(e2, t2, r2, o2) {
            super(), this.loop = e2, this.varKind = t2, this.name = r2, this.iterable = o2;
          }
          render(e2) {
            return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(e2);
          }
          optimizeNames(e2, t2) {
            if (super.optimizeNames(e2, t2))
              return this.iterable = x(this.iterable, e2, t2), this;
          }
          get names() {
            return C(super.names, this.iterable.names);
          }
        }
        class P extends y {
          constructor(e2, t2, r2) {
            super(), this.name = e2, this.args = t2, this.async = r2;
          }
          render(e2) {
            return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(e2);
          }
        }
        P.kind = "func";
        class S extends h {
          render(e2) {
            return "return " + super.render(e2);
          }
        }
        S.kind = "return";
        class N extends y {
          render(e2) {
            let t2 = "try" + super.render(e2);
            return this.catch && (t2 += this.catch.render(e2)), this.finally && (t2 += this.finally.render(e2)), t2;
          }
          optimizeNodes() {
            var e2, t2;
            return super.optimizeNodes(), null === (e2 = this.catch) || void 0 === e2 || e2.optimizeNodes(), null === (t2 = this.finally) || void 0 === t2 || t2.optimizeNodes(), this;
          }
          optimizeNames(e2, t2) {
            var r2, o2;
            return super.optimizeNames(e2, t2), null === (r2 = this.catch) || void 0 === r2 || r2.optimizeNames(e2, t2), null === (o2 = this.finally) || void 0 === o2 || o2.optimizeNames(e2, t2), this;
          }
          get names() {
            const e2 = super.names;
            return this.catch && C(e2, this.catch.names), this.finally && C(e2, this.finally.names), e2;
          }
        }
        class k extends y {
          constructor(e2) {
            super(), this.error = e2;
          }
          render(e2) {
            return `catch(${this.error})` + super.render(e2);
          }
        }
        k.kind = "catch";
        class j extends y {
          render(e2) {
            return "finally" + super.render(e2);
          }
        }
        j.kind = "finally";
        function C(e2, t2) {
          for (const r2 in t2)
            e2[r2] = (e2[r2] || 0) + (t2[r2] || 0);
          return e2;
        }
        function O(e2, t2) {
          return t2 instanceof o._CodeOrName ? C(e2, t2.names) : e2;
        }
        function x(e2, t2, r2) {
          return e2 instanceof o.Name ? a2(e2) : (s2 = e2) instanceof o._Code && s2._items.some((e3) => e3 instanceof o.Name && 1 === t2[e3.str] && void 0 !== r2[e3.str]) ? new o._Code(e2._items.reduce((e3, t3) => (t3 instanceof o.Name && (t3 = a2(t3)), t3 instanceof o._Code ? e3.push(...t3._items) : e3.push(t3), e3), [])) : e2;
          var s2;
          function a2(e3) {
            const o2 = r2[e3.str];
            return void 0 === o2 || 1 !== t2[e3.str] ? e3 : (delete t2[e3.str], o2);
          }
        }
        function T(e2, t2) {
          for (const r2 in t2)
            e2[r2] = (e2[r2] || 0) - (t2[r2] || 0);
        }
        function I(e2) {
          return "boolean" == typeof e2 || "number" == typeof e2 || null === e2 ? !e2 : o._`!${M(e2)}`;
        }
        r.CodeGen = class {
          constructor(e2, t2 = {}) {
            this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...t2, _n: t2.lines ? "\n" : "" }, this._extScope = e2, this._scope = new s.Scope({ parent: e2 }), this._nodes = [new v()];
          }
          toString() {
            return this._root.render(this.opts);
          }
          name(e2) {
            return this._scope.name(e2);
          }
          scopeName(e2) {
            return this._extScope.name(e2);
          }
          scopeValue(e2, t2) {
            const r2 = this._extScope.value(e2, t2);
            return (this._values[r2.prefix] || (this._values[r2.prefix] = /* @__PURE__ */ new Set())).add(r2), r2;
          }
          getScopeValue(e2, t2) {
            return this._extScope.getValue(e2, t2);
          }
          scopeRefs(e2) {
            return this._extScope.scopeRefs(e2, this._values);
          }
          scopeCode() {
            return this._extScope.scopeCode(this._values);
          }
          _def(e2, t2, r2, o2) {
            const s2 = this._scope.toName(t2);
            return void 0 !== r2 && o2 && (this._constants[s2.str] = r2), this._leafNode(new c(e2, s2, r2)), s2;
          }
          const(e2, t2, r2) {
            return this._def(s.varKinds.const, e2, t2, r2);
          }
          let(e2, t2, r2) {
            return this._def(s.varKinds.let, e2, t2, r2);
          }
          var(e2, t2, r2) {
            return this._def(s.varKinds.var, e2, t2, r2);
          }
          assign(e2, t2, r2) {
            return this._leafNode(new l(e2, t2, r2));
          }
          add(e2, t2) {
            return this._leafNode(new d(e2, r.operators.ADD, t2));
          }
          code(e2) {
            return "function" == typeof e2 ? e2() : e2 !== o.nil && this._leafNode(new m(e2)), this;
          }
          object(...e2) {
            const t2 = ["{"];
            for (const [r2, s2] of e2)
              t2.length > 1 && t2.push(","), t2.push(r2), (r2 !== s2 || this.opts.es5) && (t2.push(":"), (0, o.addCodeArg)(t2, s2));
            return t2.push("}"), new o._Code(t2);
          }
          if(e2, t2, r2) {
            if (this._blockNode(new $(e2)), t2 && r2)
              this.code(t2).else().code(r2).endIf();
            else if (t2)
              this.code(t2).endIf();
            else if (r2)
              throw new Error('CodeGen: "else" body without "then" body');
            return this;
          }
          elseIf(e2) {
            return this._elseNode(new $(e2));
          }
          else() {
            return this._elseNode(new g());
          }
          endIf() {
            return this._endBlockNode($, g);
          }
          _for(e2, t2) {
            return this._blockNode(e2), t2 && this.code(t2).endFor(), this;
          }
          for(e2, t2) {
            return this._for(new w(e2), t2);
          }
          forRange(e2, t2, r2, o2, a2 = this.opts.es5 ? s.varKinds.var : s.varKinds.let) {
            const n2 = this._scope.toName(e2);
            return this._for(new b(a2, n2, t2, r2), () => o2(n2));
          }
          forOf(e2, t2, r2, a2 = s.varKinds.const) {
            const n2 = this._scope.toName(e2);
            if (this.opts.es5) {
              const e3 = t2 instanceof o.Name ? t2 : this.var("_arr", t2);
              return this.forRange("_i", 0, o._`${e3}.length`, (t3) => {
                this.var(n2, o._`${e3}[${t3}]`), r2(n2);
              });
            }
            return this._for(new E("of", a2, n2, t2), () => r2(n2));
          }
          forIn(e2, t2, r2, a2 = this.opts.es5 ? s.varKinds.var : s.varKinds.const) {
            if (this.opts.ownProperties)
              return this.forOf(e2, o._`Object.keys(${t2})`, r2);
            const n2 = this._scope.toName(e2);
            return this._for(new E("in", a2, n2, t2), () => r2(n2));
          }
          endFor() {
            return this._endBlockNode(_);
          }
          label(e2) {
            return this._leafNode(new u(e2));
          }
          break(e2) {
            return this._leafNode(new f(e2));
          }
          return(e2) {
            const t2 = new S();
            if (this._blockNode(t2), this.code(e2), 1 !== t2.nodes.length)
              throw new Error('CodeGen: "return" should have one node');
            return this._endBlockNode(S);
          }
          try(e2, t2, r2) {
            if (!t2 && !r2)
              throw new Error('CodeGen: "try" without "catch" and "finally"');
            const o2 = new N();
            if (this._blockNode(o2), this.code(e2), t2) {
              const e3 = this.name("e");
              this._currNode = o2.catch = new k(e3), t2(e3);
            }
            return r2 && (this._currNode = o2.finally = new j(), this.code(r2)), this._endBlockNode(k, j);
          }
          throw(e2) {
            return this._leafNode(new p(e2));
          }
          block(e2, t2) {
            return this._blockStarts.push(this._nodes.length), e2 && this.code(e2).endBlock(t2), this;
          }
          endBlock(e2) {
            const t2 = this._blockStarts.pop();
            if (void 0 === t2)
              throw new Error("CodeGen: not in self-balancing block");
            const r2 = this._nodes.length - t2;
            if (r2 < 0 || void 0 !== e2 && r2 !== e2)
              throw new Error(`CodeGen: wrong number of nodes: ${r2} vs ${e2} expected`);
            return this._nodes.length = t2, this;
          }
          func(e2, t2 = o.nil, r2, s2) {
            return this._blockNode(new P(e2, t2, r2)), s2 && this.code(s2).endFunc(), this;
          }
          endFunc() {
            return this._endBlockNode(P);
          }
          optimize(e2 = 1) {
            for (; e2-- > 0; )
              this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
          }
          _leafNode(e2) {
            return this._currNode.nodes.push(e2), this;
          }
          _blockNode(e2) {
            this._currNode.nodes.push(e2), this._nodes.push(e2);
          }
          _endBlockNode(e2, t2) {
            const r2 = this._currNode;
            if (r2 instanceof e2 || t2 && r2 instanceof t2)
              return this._nodes.pop(), this;
            throw new Error(`CodeGen: not in block "${t2 ? `${e2.kind}/${t2.kind}` : e2.kind}"`);
          }
          _elseNode(e2) {
            const t2 = this._currNode;
            if (!(t2 instanceof $))
              throw new Error('CodeGen: "else" without "if"');
            return this._currNode = t2.else = e2, this;
          }
          get _root() {
            return this._nodes[0];
          }
          get _currNode() {
            const e2 = this._nodes;
            return e2[e2.length - 1];
          }
          set _currNode(e2) {
            const t2 = this._nodes;
            t2[t2.length - 1] = e2;
          }
        }, r.not = I;
        const R = A(r.operators.AND);
        r.and = function(...e2) {
          return e2.reduce(R);
        };
        const D = A(r.operators.OR);
        function A(e2) {
          return (t2, r2) => t2 === o.nil ? r2 : r2 === o.nil ? t2 : o._`${M(t2)} ${e2} ${M(r2)}`;
        }
        function M(e2) {
          return e2 instanceof o.Name ? e2 : o._`(${e2})`;
        }
        r.or = function(...e2) {
          return e2.reduce(D);
        };
      }, { "./code": 1, "./scope": 3 }], 3: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.ValueScope = r.ValueScopeName = r.Scope = r.varKinds = r.UsedValueState = void 0;
        const o = e("./code");
        class s extends Error {
          constructor(e2) {
            super(`CodeGen: "code" for ${e2} not defined`), this.value = e2.value;
          }
        }
        var a;
        !function(e2) {
          e2[e2.Started = 0] = "Started", e2[e2.Completed = 1] = "Completed";
        }(a = r.UsedValueState || (r.UsedValueState = {})), r.varKinds = { const: new o.Name("const"), let: new o.Name("let"), var: new o.Name("var") };
        class n {
          constructor({ prefixes: e2, parent: t2 } = {}) {
            this._names = {}, this._prefixes = e2, this._parent = t2;
          }
          toName(e2) {
            return e2 instanceof o.Name ? e2 : this.name(e2);
          }
          name(e2) {
            return new o.Name(this._newName(e2));
          }
          _newName(e2) {
            return `${e2}${(this._names[e2] || this._nameGroup(e2)).index++}`;
          }
          _nameGroup(e2) {
            var t2, r2;
            if ((null === (r2 = null === (t2 = this._parent) || void 0 === t2 ? void 0 : t2._prefixes) || void 0 === r2 ? void 0 : r2.has(e2)) || this._prefixes && !this._prefixes.has(e2))
              throw new Error(`CodeGen: prefix "${e2}" is not allowed in this scope`);
            return this._names[e2] = { prefix: e2, index: 0 };
          }
        }
        r.Scope = n;
        class i extends o.Name {
          constructor(e2, t2) {
            super(t2), this.prefix = e2;
          }
          setValue(e2, { property: t2, itemIndex: r2 }) {
            this.value = e2, this.scopePath = o._`.${new o.Name(t2)}[${r2}]`;
          }
        }
        r.ValueScopeName = i;
        const c = o._`\n`;
        r.ValueScope = class extends n {
          constructor(e2) {
            super(e2), this._values = {}, this._scope = e2.scope, this.opts = { ...e2, _n: e2.lines ? c : o.nil };
          }
          get() {
            return this._scope;
          }
          name(e2) {
            return new i(e2, this._newName(e2));
          }
          value(e2, t2) {
            var r2;
            if (void 0 === t2.ref)
              throw new Error("CodeGen: ref must be passed in value");
            const o2 = this.toName(e2), { prefix: s2 } = o2, a2 = null !== (r2 = t2.key) && void 0 !== r2 ? r2 : t2.ref;
            let n2 = this._values[s2];
            if (n2) {
              const e3 = n2.get(a2);
              if (e3)
                return e3;
            } else
              n2 = this._values[s2] = /* @__PURE__ */ new Map();
            n2.set(a2, o2);
            const i2 = this._scope[s2] || (this._scope[s2] = []), c2 = i2.length;
            return i2[c2] = t2.ref, o2.setValue(t2, { property: s2, itemIndex: c2 }), o2;
          }
          getValue(e2, t2) {
            const r2 = this._values[e2];
            if (r2)
              return r2.get(t2);
          }
          scopeRefs(e2, t2 = this._values) {
            return this._reduceValues(t2, (t3) => {
              if (void 0 === t3.scopePath)
                throw new Error(`CodeGen: name "${t3}" has no value`);
              return o._`${e2}${t3.scopePath}`;
            });
          }
          scopeCode(e2 = this._values, t2, r2) {
            return this._reduceValues(e2, (e3) => {
              if (void 0 === e3.value)
                throw new Error(`CodeGen: name "${e3}" has no value`);
              return e3.value.code;
            }, t2, r2);
          }
          _reduceValues(e2, t2, n2 = {}, i2) {
            let c2 = o.nil;
            for (const l in e2) {
              const d = e2[l];
              if (!d)
                continue;
              const u = n2[l] = n2[l] || /* @__PURE__ */ new Map();
              d.forEach((e3) => {
                if (u.has(e3))
                  return;
                u.set(e3, a.Started);
                let n3 = t2(e3);
                if (n3) {
                  c2 = o._`${c2}${this.opts.es5 ? r.varKinds.var : r.varKinds.const} ${e3} = ${n3};${this.opts._n}`;
                } else {
                  if (!(n3 = null == i2 ? void 0 : i2(e3)))
                    throw new s(e3);
                  c2 = o._`${c2}${n3}${this.opts._n}`;
                }
                u.set(e3, a.Completed);
              });
            }
            return c2;
          }
        };
      }, { "./code": 1 }], 4: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.extendErrors = r.resetErrorsCount = r.reportExtraError = r.reportError = r.keyword$DataError = r.keywordError = void 0;
        const o = e("./codegen"), s = e("./util"), a = e("./names");
        function n(e2, t2) {
          const r2 = e2.const("err", t2);
          e2.if(o._`${a.default.vErrors} === null`, () => e2.assign(a.default.vErrors, o._`[${r2}]`), o._`${a.default.vErrors}.push(${r2})`), e2.code(o._`${a.default.errors}++`);
        }
        function i(e2, t2) {
          const { gen: r2, validateName: s2, schemaEnv: a2 } = e2;
          a2.$async ? r2.throw(o._`new ${e2.ValidationError}(${t2})`) : (r2.assign(o._`${s2}.errors`, t2), r2.return(false));
        }
        r.keywordError = { message({ keyword: e2 }) {
          return o.str`must pass "${e2}" keyword validation`;
        } }, r.keyword$DataError = { message({ keyword: e2, schemaType: t2 }) {
          return t2 ? o.str`"${e2}" keyword must be ${t2} ($data)` : o.str`"${e2}" keyword is invalid ($data)`;
        } }, r.reportError = function(e2, t2 = r.keywordError, s2, a2) {
          const { it: c2 } = e2, { gen: d2, compositeRule: u2, allErrors: f } = c2, p = l(e2, t2, s2);
          (null != a2 ? a2 : u2 || f) ? n(d2, p) : i(c2, o._`[${p}]`);
        }, r.reportExtraError = function(e2, t2 = r.keywordError, o2) {
          const { it: s2 } = e2, { gen: c2, compositeRule: d2, allErrors: u2 } = s2;
          n(c2, l(e2, t2, o2)), d2 || u2 || i(s2, a.default.vErrors);
        }, r.resetErrorsCount = function(e2, t2) {
          e2.assign(a.default.errors, t2), e2.if(o._`${a.default.vErrors} !== null`, () => e2.if(t2, () => e2.assign(o._`${a.default.vErrors}.length`, t2), () => e2.assign(a.default.vErrors, null)));
        }, r.extendErrors = function({ gen: e2, keyword: t2, schemaValue: r2, data: s2, errsCount: n2, it: i2 }) {
          if (void 0 === n2)
            throw new Error("ajv implementation error");
          const c2 = e2.name("err");
          e2.forRange("i", n2, a.default.errors, (n3) => {
            e2.const(c2, o._`${a.default.vErrors}[${n3}]`), e2.if(o._`${c2}.instancePath === undefined`, () => e2.assign(o._`${c2}.instancePath`, (0, o.strConcat)(a.default.instancePath, i2.errorPath))), e2.assign(o._`${c2}.schemaPath`, o.str`${i2.errSchemaPath}/${t2}`), i2.opts.verbose && (e2.assign(o._`${c2}.schema`, r2), e2.assign(o._`${c2}.data`, s2));
          });
        };
        const c = { keyword: new o.Name("keyword"), schemaPath: new o.Name("schemaPath"), params: new o.Name("params"), propertyName: new o.Name("propertyName"), message: new o.Name("message"), schema: new o.Name("schema"), parentSchema: new o.Name("parentSchema") };
        function l(e2, t2, r2) {
          const { createErrors: s2 } = e2.it;
          return false === s2 ? o._`{}` : function(e3, t3, r3 = {}) {
            const { gen: s3, it: n2 } = e3, i2 = [d(n2, r3), u(e3, r3)];
            return function(e4, { params: t4, message: r4 }, s4) {
              const { keyword: n3, data: i3, schemaValue: l2, it: d2 } = e4, { opts: u2, propertyName: f, topSchemaRef: p, schemaPath: m } = d2;
              s4.push([c.keyword, n3], [c.params, "function" == typeof t4 ? t4(e4) : t4 || o._`{}`]), u2.messages && s4.push([c.message, "function" == typeof r4 ? r4(e4) : r4]);
              u2.verbose && s4.push([c.schema, l2], [c.parentSchema, o._`${p}${m}`], [a.default.data, i3]);
              f && s4.push([c.propertyName, f]);
            }(e3, t3, i2), s3.object(...i2);
          }(e2, t2, r2);
        }
        function d({ errorPath: e2 }, { instancePath: t2 }) {
          const r2 = t2 ? o.str`${e2}${(0, s.getErrorPath)(t2, s.Type.Str)}` : e2;
          return [a.default.instancePath, (0, o.strConcat)(a.default.instancePath, r2)];
        }
        function u({ keyword: e2, it: { errSchemaPath: t2 } }, { schemaPath: r2, parentSchema: a2 }) {
          let n2 = a2 ? t2 : o.str`${t2}/${e2}`;
          return r2 && (n2 = o.str`${n2}${(0, s.getErrorPath)(r2, s.Type.Str)}`), [c.schemaPath, n2];
        }
      }, { "./codegen": 2, "./names": 6, "./util": 10 }], 5: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.resolveSchema = r.getCompilingSchema = r.resolveRef = r.compileSchema = r.SchemaEnv = void 0;
        const o = e("./codegen"), s = e("../runtime/validation_error"), a = e("./names"), n = e("./resolve"), i = e("./util"), c = e("./validate");
        class l {
          constructor(e2) {
            var t2;
            let r2;
            this.refs = {}, this.dynamicAnchors = {}, "object" == typeof e2.schema && (r2 = e2.schema), this.schema = e2.schema, this.schemaId = e2.schemaId, this.root = e2.root || this, this.baseId = null !== (t2 = e2.baseId) && void 0 !== t2 ? t2 : (0, n.normalizeId)(null == r2 ? void 0 : r2[e2.schemaId || "$id"]), this.schemaPath = e2.schemaPath, this.localRefs = e2.localRefs, this.meta = e2.meta, this.$async = null == r2 ? void 0 : r2.$async, this.refs = {};
          }
        }
        function d(e2) {
          const t2 = f.call(this, e2);
          if (t2)
            return t2;
          const r2 = (0, n.getFullPath)(this.opts.uriResolver, e2.root.baseId), { es5: i2, lines: l2 } = this.opts.code, { ownProperties: d2 } = this.opts, u2 = new o.CodeGen(this.scope, { es5: i2, lines: l2, ownProperties: d2 });
          let p2;
          e2.$async && (p2 = u2.scopeValue("Error", { ref: s.default, code: o._`require("ajv/dist/runtime/validation_error").default` }));
          const m2 = u2.scopeName("validate");
          e2.validateName = m2;
          const h2 = { gen: u2, allErrors: this.opts.allErrors, data: a.default.data, parentData: a.default.parentData, parentDataProperty: a.default.parentDataProperty, dataNames: [a.default.data], dataPathArr: [o.nil], dataLevel: 0, dataTypes: [], definedProperties: /* @__PURE__ */ new Set(), topSchemaRef: u2.scopeValue("schema", true === this.opts.code.source ? { ref: e2.schema, code: (0, o.stringify)(e2.schema) } : { ref: e2.schema }), validateName: m2, ValidationError: p2, schema: e2.schema, schemaEnv: e2, rootId: r2, baseId: e2.baseId || r2, schemaPath: o.nil, errSchemaPath: e2.schemaPath || (this.opts.jtd ? "" : "#"), errorPath: o._`""`, opts: this.opts, self: this };
          let y2;
          try {
            this._compilations.add(e2), (0, c.validateFunctionCode)(h2), u2.optimize(this.opts.code.optimize);
            const t3 = u2.toString();
            y2 = `${u2.scopeRefs(a.default.scope)}return ${t3}`, this.opts.code.process && (y2 = this.opts.code.process(y2, e2));
            const r3 = new Function(`${a.default.self}`, `${a.default.scope}`, y2)(this, this.scope.get());
            if (this.scope.value(m2, { ref: r3 }), r3.errors = null, r3.schema = e2.schema, r3.schemaEnv = e2, e2.$async && (r3.$async = true), true === this.opts.code.source && (r3.source = { validateName: m2, validateCode: t3, scopeValues: u2._values }), this.opts.unevaluated) {
              const { props: e3, items: t4 } = h2;
              r3.evaluated = { props: e3 instanceof o.Name ? void 0 : e3, items: t4 instanceof o.Name ? void 0 : t4, dynamicProps: e3 instanceof o.Name, dynamicItems: t4 instanceof o.Name }, r3.source && (r3.source.evaluated = (0, o.stringify)(r3.evaluated));
            }
            return e2.validate = r3, e2;
          } catch (t3) {
            throw delete e2.validate, delete e2.validateName, y2 && this.logger.error("Error compiling schema, function code:", y2), t3;
          } finally {
            this._compilations.delete(e2);
          }
        }
        function u(e2) {
          return (0, n.inlineRef)(e2.schema, this.opts.inlineRefs) ? e2.schema : e2.validate ? e2 : d.call(this, e2);
        }
        function f(e2) {
          for (const o2 of this._compilations)
            if ((t2 = o2).schema === (r2 = e2).schema && t2.root === r2.root && t2.baseId === r2.baseId)
              return o2;
          var t2, r2;
        }
        function p(e2, t2) {
          let r2;
          for (; "string" == typeof (r2 = this.refs[t2]); )
            t2 = r2;
          return r2 || this.schemas[t2] || m.call(this, e2, t2);
        }
        function m(e2, t2) {
          const r2 = this.opts.uriResolver.parse(t2), o2 = (0, n._getFullPath)(this.opts.uriResolver, r2);
          let s2 = (0, n.getFullPath)(this.opts.uriResolver, e2.baseId, void 0);
          if (Object.keys(e2.schema).length > 0 && o2 === s2)
            return y.call(this, r2, e2);
          const a2 = (0, n.normalizeId)(o2), i2 = this.refs[a2] || this.schemas[a2];
          if ("string" == typeof i2) {
            const t3 = m.call(this, e2, i2);
            if ("object" != typeof (null == t3 ? void 0 : t3.schema))
              return;
            return y.call(this, r2, t3);
          }
          if ("object" == typeof (null == i2 ? void 0 : i2.schema)) {
            if (i2.validate || d.call(this, i2), a2 === (0, n.normalizeId)(t2)) {
              const { schema: t3 } = i2, { schemaId: r3 } = this.opts, o3 = t3[r3];
              return o3 && (s2 = (0, n.resolveUrl)(this.opts.uriResolver, s2, o3)), new l({ schema: t3, schemaId: r3, root: e2, baseId: s2 });
            }
            return y.call(this, r2, i2);
          }
        }
        r.SchemaEnv = l, r.compileSchema = d, r.resolveRef = function(e2, t2, r2) {
          var o2;
          r2 = (0, n.resolveUrl)(this.opts.uriResolver, t2, r2);
          const s2 = e2.refs[r2];
          if (s2)
            return s2;
          let a2 = p.call(this, e2, r2);
          if (void 0 === a2) {
            const s3 = null === (o2 = e2.localRefs) || void 0 === o2 ? void 0 : o2[r2], { schemaId: n2 } = this.opts;
            s3 && (a2 = new l({ schema: s3, schemaId: n2, root: e2, baseId: t2 }));
          }
          return void 0 !== a2 ? e2.refs[r2] = u.call(this, a2) : void 0;
        }, r.getCompilingSchema = f, r.resolveSchema = m;
        const h = /* @__PURE__ */ new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
        function y(e2, { baseId: t2, schema: r2, root: o2 }) {
          var s2;
          if ("/" !== (null === (s2 = e2.fragment) || void 0 === s2 ? void 0 : s2[0]))
            return;
          for (const o3 of e2.fragment.slice(1).split("/")) {
            if ("boolean" == typeof r2)
              return;
            const e3 = r2[(0, i.unescapeFragment)(o3)];
            if (void 0 === e3)
              return;
            const s3 = "object" == typeof (r2 = e3) && r2[this.opts.schemaId];
            !h.has(o3) && s3 && (t2 = (0, n.resolveUrl)(this.opts.uriResolver, t2, s3));
          }
          let a2;
          if ("boolean" != typeof r2 && r2.$ref && !(0, i.schemaHasRulesButRef)(r2, this.RULES)) {
            const e3 = (0, n.resolveUrl)(this.opts.uriResolver, t2, r2.$ref);
            a2 = m.call(this, o2, e3);
          }
          const { schemaId: c2 } = this.opts;
          return a2 = a2 || new l({ schema: r2, schemaId: c2, root: o2, baseId: t2 }), a2.schema !== a2.root.schema ? a2 : void 0;
        }
      }, { "../runtime/validation_error": 24, "./codegen": 2, "./names": 6, "./resolve": 8, "./util": 10, "./validate": 15 }], 6: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./codegen"), s = { data: new o.Name("data"), valCxt: new o.Name("valCxt"), instancePath: new o.Name("instancePath"), parentData: new o.Name("parentData"), parentDataProperty: new o.Name("parentDataProperty"), rootData: new o.Name("rootData"), dynamicAnchors: new o.Name("dynamicAnchors"), vErrors: new o.Name("vErrors"), errors: new o.Name("errors"), this: new o.Name("this"), self: new o.Name("self"), scope: new o.Name("scope"), json: new o.Name("json"), jsonPos: new o.Name("jsonPos"), jsonLen: new o.Name("jsonLen"), jsonPart: new o.Name("jsonPart") };
        r.default = s;
      }, { "./codegen": 2 }], 7: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./resolve");
        class s extends Error {
          constructor(e2, t2, r2, s2) {
            super(s2 || `can't resolve reference ${r2} from id ${t2}`), this.missingRef = (0, o.resolveUrl)(e2, t2, r2), this.missingSchema = (0, o.normalizeId)((0, o.getFullPath)(e2, this.missingRef));
          }
        }
        r.default = s;
      }, { "./resolve": 8 }], 8: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.getSchemaRefs = r.resolveUrl = r.normalizeId = r._getFullPath = r.getFullPath = r.inlineRef = void 0;
        const o = e("./util"), s = e("fast-deep-equal"), a = e("json-schema-traverse"), n = /* @__PURE__ */ new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
        r.inlineRef = function(e2, t2 = true) {
          return "boolean" == typeof e2 || (true === t2 ? !c(e2) : !!t2 && l(e2) <= t2);
        };
        const i = /* @__PURE__ */ new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
        function c(e2) {
          for (const t2 in e2) {
            if (i.has(t2))
              return true;
            const r2 = e2[t2];
            if (Array.isArray(r2) && r2.some(c))
              return true;
            if ("object" == typeof r2 && c(r2))
              return true;
          }
          return false;
        }
        function l(e2) {
          let t2 = 0;
          for (const r2 in e2) {
            if ("$ref" === r2)
              return Infinity;
            if (t2++, !n.has(r2) && ("object" == typeof e2[r2] && (0, o.eachItem)(e2[r2], (e3) => t2 += l(e3)), Infinity === t2))
              return Infinity;
          }
          return t2;
        }
        function d(e2, t2 = "", r2) {
          false !== r2 && (t2 = p(t2));
          const o2 = e2.parse(t2);
          return u(e2, o2);
        }
        function u(e2, t2) {
          return e2.serialize(t2).split("#")[0] + "#";
        }
        r.getFullPath = d, r._getFullPath = u;
        const f = /#\/?$/;
        function p(e2) {
          return e2 ? e2.replace(f, "") : "";
        }
        r.normalizeId = p, r.resolveUrl = function(e2, t2, r2) {
          return r2 = p(r2), e2.resolve(t2, r2);
        };
        const m = /^[a-z_][-a-z0-9._]*$/i;
        r.getSchemaRefs = function(e2, t2) {
          if ("boolean" == typeof e2)
            return {};
          const { schemaId: r2, uriResolver: o2 } = this.opts, n2 = p(e2[r2] || t2), i2 = { "": n2 }, c2 = d(o2, n2, false), l2 = {}, u2 = /* @__PURE__ */ new Set();
          return a(e2, { allKeys: true }, (e3, t3, o3, s2) => {
            if (void 0 === s2)
              return;
            const a2 = c2 + t3;
            let n3 = i2[s2];
            function d2(t4) {
              if (t4 = p(n3 ? (0, this.opts.uriResolver.resolve)(n3, t4) : t4), u2.has(t4))
                throw h(t4);
              u2.add(t4);
              let r3 = this.refs[t4];
              return "string" == typeof r3 && (r3 = this.refs[r3]), "object" == typeof r3 ? f2(e3, r3.schema, t4) : t4 !== p(a2) && ("#" === t4[0] ? (f2(e3, l2[t4], t4), l2[t4] = e3) : this.refs[t4] = a2), t4;
            }
            function y(e4) {
              if ("string" == typeof e4) {
                if (!m.test(e4))
                  throw new Error(`invalid anchor "${e4}"`);
                d2.call(this, `#${e4}`);
              }
            }
            "string" == typeof e3[r2] && (n3 = d2.call(this, e3[r2])), y.call(this, e3.$anchor), y.call(this, e3.$dynamicAnchor), i2[t3] = n3;
          }), l2;
          function f2(e3, t3, r3) {
            if (void 0 !== t3 && !s(e3, t3))
              throw h(r3);
          }
          function h(e3) {
            return new Error(`reference "${e3}" resolves to more than one schema`);
          }
        };
      }, { "./util": 10, "fast-deep-equal": 63, "json-schema-traverse": 64 }], 9: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.getRules = r.isJSONType = void 0;
        const o = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null", "object", "array"]);
        r.isJSONType = function(e2) {
          return "string" == typeof e2 && o.has(e2);
        }, r.getRules = function() {
          const e2 = { number: { type: "number", rules: [] }, string: { type: "string", rules: [] }, array: { type: "array", rules: [] }, object: { type: "object", rules: [] } };
          return { types: { ...e2, integer: true, boolean: true, null: true }, rules: [{ rules: [] }, e2.number, e2.string, e2.array, e2.object], post: { rules: [] }, all: {}, keywords: {} };
        };
      }, {}], 10: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.checkStrictMode = r.getErrorPath = r.Type = r.useFunc = r.setEvaluated = r.evaluatedPropsToName = r.mergeEvaluated = r.eachItem = r.unescapeJsonPointer = r.escapeJsonPointer = r.escapeFragment = r.unescapeFragment = r.schemaRefOrVal = r.schemaHasRulesButRef = r.schemaHasRules = r.checkUnknownRules = r.alwaysValidSchema = r.toHash = void 0;
        const o = e("./codegen"), s = e("./codegen/code");
        function a(e2, t2 = e2.schema) {
          const { opts: r2, self: o2 } = e2;
          if (!r2.strictSchema)
            return;
          if ("boolean" == typeof t2)
            return;
          const s2 = o2.RULES.keywords;
          for (const r3 in t2)
            s2[r3] || m(e2, `unknown keyword: "${r3}"`);
        }
        function n(e2, t2) {
          if ("boolean" == typeof e2)
            return !e2;
          for (const r2 in e2)
            if (t2[r2])
              return true;
          return false;
        }
        function i(e2) {
          return "number" == typeof e2 ? `${e2}` : e2.replace(/~/g, "~0").replace(/\//g, "~1");
        }
        function c(e2) {
          return e2.replace(/~1/g, "/").replace(/~0/g, "~");
        }
        function l({ mergeNames: e2, mergeToName: t2, mergeValues: r2, resultToName: s2 }) {
          return (a2, n2, i2, c2) => {
            const l2 = void 0 === i2 ? n2 : i2 instanceof o.Name ? (n2 instanceof o.Name ? e2(a2, n2, i2) : t2(a2, n2, i2), i2) : n2 instanceof o.Name ? (t2(a2, i2, n2), n2) : r2(n2, i2);
            return c2 !== o.Name || l2 instanceof o.Name ? l2 : s2(a2, l2);
          };
        }
        function d(e2, t2) {
          if (true === t2)
            return e2.var("props", true);
          const r2 = e2.var("props", o._`{}`);
          return void 0 !== t2 && u(e2, r2, t2), r2;
        }
        function u(e2, t2, r2) {
          Object.keys(r2).forEach((r3) => e2.assign(o._`${t2}${(0, o.getProperty)(r3)}`, true));
        }
        r.toHash = function(e2) {
          const t2 = {};
          for (const r2 of e2)
            t2[r2] = true;
          return t2;
        }, r.alwaysValidSchema = function(e2, t2) {
          return "boolean" == typeof t2 ? t2 : 0 === Object.keys(t2).length || (a(e2, t2), !n(t2, e2.self.RULES.all));
        }, r.checkUnknownRules = a, r.schemaHasRules = n, r.schemaHasRulesButRef = function(e2, t2) {
          if ("boolean" == typeof e2)
            return !e2;
          for (const r2 in e2)
            if ("$ref" !== r2 && t2.all[r2])
              return true;
          return false;
        }, r.schemaRefOrVal = function({ topSchemaRef: e2, schemaPath: t2 }, r2, s2, a2) {
          if (!a2) {
            if ("number" == typeof r2 || "boolean" == typeof r2)
              return r2;
            if ("string" == typeof r2)
              return o._`${r2}`;
          }
          return o._`${e2}${t2}${(0, o.getProperty)(s2)}`;
        }, r.unescapeFragment = function(e2) {
          return c(decodeURIComponent(e2));
        }, r.escapeFragment = function(e2) {
          return encodeURIComponent(i(e2));
        }, r.escapeJsonPointer = i, r.unescapeJsonPointer = c, r.eachItem = function(e2, t2) {
          if (Array.isArray(e2))
            for (const r2 of e2)
              t2(r2);
          else
            t2(e2);
        }, r.mergeEvaluated = { props: l({ mergeNames(e2, t2, r2) {
          return e2.if(o._`${r2} !== true && ${t2} !== undefined`, () => {
            e2.if(o._`${t2} === true`, () => e2.assign(r2, true), () => e2.assign(r2, o._`${r2} || {}`).code(o._`Object.assign(${r2}, ${t2})`));
          });
        }, mergeToName(e2, t2, r2) {
          return e2.if(o._`${r2} !== true`, () => {
            true === t2 ? e2.assign(r2, true) : (e2.assign(r2, o._`${r2} || {}`), u(e2, r2, t2));
          });
        }, mergeValues(e2, t2) {
          return true === e2 || { ...e2, ...t2 };
        }, resultToName: d }), items: l({ mergeNames(e2, t2, r2) {
          return e2.if(o._`${r2} !== true && ${t2} !== undefined`, () => e2.assign(r2, o._`${t2} === true ? true : ${r2} > ${t2} ? ${r2} : ${t2}`));
        }, mergeToName(e2, t2, r2) {
          return e2.if(o._`${r2} !== true`, () => e2.assign(r2, true === t2 || o._`${r2} > ${t2} ? ${r2} : ${t2}`));
        }, mergeValues(e2, t2) {
          return true === e2 || Math.max(e2, t2);
        }, resultToName(e2, t2) {
          return e2.var("items", t2);
        } }) }, r.evaluatedPropsToName = d, r.setEvaluated = u;
        const f = {};
        var p;
        function m(e2, t2, r2 = e2.opts.strictSchema) {
          if (r2) {
            if (t2 = `strict mode: ${t2}`, true === r2)
              throw new Error(t2);
            e2.self.logger.warn(t2);
          }
        }
        r.useFunc = function(e2, t2) {
          return e2.scopeValue("func", { ref: t2, code: f[t2.code] || (f[t2.code] = new s._Code(t2.code)) });
        }, function(e2) {
          e2[e2.Num = 0] = "Num", e2[e2.Str = 1] = "Str";
        }(p = r.Type || (r.Type = {})), r.getErrorPath = function(e2, t2, r2) {
          if (e2 instanceof o.Name) {
            const s2 = t2 === p.Num;
            return r2 ? s2 ? o._`"[" + ${e2} + "]"` : o._`"['" + ${e2} + "']"` : s2 ? o._`"/" + ${e2}` : o._`"/" + ${e2}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
          }
          return r2 ? (0, o.getProperty)(e2).toString() : "/" + i(e2);
        }, r.checkStrictMode = m;
      }, { "./codegen": 2, "./codegen/code": 1 }], 11: [function(e, t, r) {
        "use strict";
        function o(e2, t2) {
          return t2.rules.some((t3) => s(e2, t3));
        }
        function s(e2, t2) {
          var r2;
          return void 0 !== e2[t2.keyword] || (null === (r2 = t2.definition.implements) || void 0 === r2 ? void 0 : r2.some((t3) => void 0 !== e2[t3]));
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.shouldUseRule = r.shouldUseGroup = r.schemaHasRulesForType = void 0, r.schemaHasRulesForType = function({ schema: e2, self: t2 }, r2) {
          const s2 = t2.RULES.types[r2];
          return s2 && true !== s2 && o(e2, s2);
        }, r.shouldUseGroup = o, r.shouldUseRule = s;
      }, {}], 12: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.boolOrEmptySchema = r.topBoolOrEmptySchema = void 0;
        const o = e("../errors"), s = e("../codegen"), a = e("../names"), n = { message: "boolean schema is false" };
        function i(e2, t2) {
          const { gen: r2, data: s2 } = e2;
          (0, o.reportError)({ gen: r2, keyword: "false schema", data: s2, schema: false, schemaCode: false, schemaValue: false, params: {}, it: e2 }, n, void 0, t2);
        }
        r.topBoolOrEmptySchema = function(e2) {
          const { gen: t2, schema: r2, validateName: o2 } = e2;
          false === r2 ? i(e2, false) : "object" == typeof r2 && true === r2.$async ? t2.return(a.default.data) : (t2.assign(s._`${o2}.errors`, null), t2.return(true));
        }, r.boolOrEmptySchema = function(e2, t2) {
          const { gen: r2, schema: o2 } = e2;
          false === o2 ? (r2.var(t2, false), i(e2)) : r2.var(t2, true);
        };
      }, { "../codegen": 2, "../errors": 4, "../names": 6 }], 13: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.reportTypeError = r.checkDataTypes = r.checkDataType = r.coerceAndCheckDataType = r.getJSONTypes = r.getSchemaTypes = r.DataType = void 0;
        const o = e("../rules"), s = e("./applicability"), a = e("../errors"), n = e("../codegen"), i = e("../util");
        var c;
        function l(e2) {
          const t2 = Array.isArray(e2) ? e2 : e2 ? [e2] : [];
          if (t2.every(o.isJSONType))
            return t2;
          throw new Error("type must be JSONType or JSONType[]: " + t2.join(","));
        }
        !function(e2) {
          e2[e2.Correct = 0] = "Correct", e2[e2.Wrong = 1] = "Wrong";
        }(c = r.DataType || (r.DataType = {})), r.getSchemaTypes = function(e2) {
          const t2 = l(e2.type);
          if (t2.includes("null")) {
            if (false === e2.nullable)
              throw new Error("type: null contradicts nullable: false");
          } else {
            if (!t2.length && void 0 !== e2.nullable)
              throw new Error('"nullable" cannot be used without "type"');
            true === e2.nullable && t2.push("null");
          }
          return t2;
        }, r.getJSONTypes = l, r.coerceAndCheckDataType = function(e2, t2) {
          const { gen: r2, data: o2, opts: a2 } = e2, i2 = function(e3, t3) {
            return t3 ? e3.filter((e4) => d.has(e4) || "array" === t3 && "array" === e4) : [];
          }(t2, a2.coerceTypes), l2 = t2.length > 0 && !(0 === i2.length && 1 === t2.length && (0, s.schemaHasRulesForType)(e2, t2[0]));
          if (l2) {
            const s2 = f(t2, o2, a2.strictNumbers, c.Wrong);
            r2.if(s2, () => {
              i2.length ? function(e3, t3, r3) {
                const { gen: o3, data: s3, opts: a3 } = e3, i3 = o3.let("dataType", n._`typeof ${s3}`), c2 = o3.let("coerced", n._`undefined`);
                "array" === a3.coerceTypes && o3.if(n._`${i3} == 'object' && Array.isArray(${s3}) && ${s3}.length == 1`, () => o3.assign(s3, n._`${s3}[0]`).assign(i3, n._`typeof ${s3}`).if(f(t3, s3, a3.strictNumbers), () => o3.assign(c2, s3)));
                o3.if(n._`${c2} !== undefined`);
                for (const e4 of r3)
                  (d.has(e4) || "array" === e4 && "array" === a3.coerceTypes) && l3(e4);
                function l3(e4) {
                  switch (e4) {
                    case "string":
                      return void o3.elseIf(n._`${i3} == "number" || ${i3} == "boolean"`).assign(c2, n._`"" + ${s3}`).elseIf(n._`${s3} === null`).assign(c2, n._`""`);
                    case "number":
                      return void o3.elseIf(n._`${i3} == "boolean" || ${s3} === null
              || (${i3} == "string" && ${s3} && ${s3} == +${s3})`).assign(c2, n._`+${s3}`);
                    case "integer":
                      return void o3.elseIf(n._`${i3} === "boolean" || ${s3} === null
              || (${i3} === "string" && ${s3} && ${s3} == +${s3} && !(${s3} % 1))`).assign(c2, n._`+${s3}`);
                    case "boolean":
                      return void o3.elseIf(n._`${s3} === "false" || ${s3} === 0 || ${s3} === null`).assign(c2, false).elseIf(n._`${s3} === "true" || ${s3} === 1`).assign(c2, true);
                    case "null":
                      return o3.elseIf(n._`${s3} === "" || ${s3} === 0 || ${s3} === false`), void o3.assign(c2, null);
                    case "array":
                      o3.elseIf(n._`${i3} === "string" || ${i3} === "number"
              || ${i3} === "boolean" || ${s3} === null`).assign(c2, n._`[${s3}]`);
                  }
                }
                o3.else(), m(e3), o3.endIf(), o3.if(n._`${c2} !== undefined`, () => {
                  o3.assign(s3, c2), function({ gen: e4, parentData: t4, parentDataProperty: r4 }, o4) {
                    e4.if(n._`${t4} !== undefined`, () => e4.assign(n._`${t4}[${r4}]`, o4));
                  }(e3, c2);
                });
              }(e2, t2, i2) : m(e2);
            });
          }
          return l2;
        };
        const d = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
        function u(e2, t2, r2, o2 = c.Correct) {
          const s2 = o2 === c.Correct ? n.operators.EQ : n.operators.NEQ;
          let a2;
          switch (e2) {
            case "null":
              return n._`${t2} ${s2} null`;
            case "array":
              a2 = n._`Array.isArray(${t2})`;
              break;
            case "object":
              a2 = n._`${t2} && typeof ${t2} == "object" && !Array.isArray(${t2})`;
              break;
            case "integer":
              a2 = i2(n._`!(${t2} % 1) && !isNaN(${t2})`);
              break;
            case "number":
              a2 = i2();
              break;
            default:
              return n._`typeof ${t2} ${s2} ${e2}`;
          }
          return o2 === c.Correct ? a2 : (0, n.not)(a2);
          function i2(e3 = n.nil) {
            return (0, n.and)(n._`typeof ${t2} == "number"`, e3, r2 ? n._`isFinite(${t2})` : n.nil);
          }
        }
        function f(e2, t2, r2, o2) {
          if (1 === e2.length)
            return u(e2[0], t2, r2, o2);
          let s2;
          const a2 = (0, i.toHash)(e2);
          if (a2.array && a2.object) {
            const e3 = n._`typeof ${t2} != "object"`;
            s2 = a2.null ? e3 : n._`!${t2} || ${e3}`, delete a2.null, delete a2.array, delete a2.object;
          } else
            s2 = n.nil;
          a2.number && delete a2.integer;
          for (const e3 in a2)
            s2 = (0, n.and)(s2, u(e3, t2, r2, o2));
          return s2;
        }
        r.checkDataType = u, r.checkDataTypes = f;
        const p = { message({ schema: e2 }) {
          return `must be ${e2}`;
        }, params({ schema: e2, schemaValue: t2 }) {
          return "string" == typeof e2 ? n._`{type: ${e2}}` : n._`{type: ${t2}}`;
        } };
        function m(e2) {
          const t2 = function(e3) {
            const { gen: t3, data: r2, schema: o2 } = e3, s2 = (0, i.schemaRefOrVal)(e3, o2, "type");
            return { gen: t3, keyword: "type", data: r2, schema: o2.type, schemaCode: s2, schemaValue: s2, parentSchema: o2, params: {}, it: e3 };
          }(e2);
          (0, a.reportError)(t2, p);
        }
        r.reportTypeError = m;
      }, { "../codegen": 2, "../errors": 4, "../rules": 9, "../util": 10, "./applicability": 11 }], 14: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.assignDefaults = void 0;
        const o = e("../codegen"), s = e("../util");
        function a(e2, t2, r2) {
          const { gen: a2, compositeRule: n, data: i, opts: c } = e2;
          if (void 0 === r2)
            return;
          const l = o._`${i}${(0, o.getProperty)(t2)}`;
          if (n)
            return void (0, s.checkStrictMode)(e2, `default is ignored for: ${l}`);
          let d = o._`${l} === undefined`;
          "empty" === c.useDefaults && (d = o._`${d} || ${l} === null || ${l} === ""`), a2.if(d, o._`${l} = ${(0, o.stringify)(r2)}`);
        }
        r.assignDefaults = function(e2, t2) {
          const { properties: r2, items: o2 } = e2.schema;
          if ("object" === t2 && r2)
            for (const t3 in r2)
              a(e2, t3, r2[t3].default);
          else
            "array" === t2 && Array.isArray(o2) && o2.forEach((t3, r3) => a(e2, r3, t3.default));
        };
      }, { "../codegen": 2, "../util": 10 }], 15: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.getData = r.KeywordCxt = r.validateFunctionCode = void 0;
        const o = e("./boolSchema"), s = e("./dataType"), a = e("./applicability"), n = e("./dataType"), i = e("./defaults"), c = e("./keyword"), l = e("./subschema"), d = e("../codegen"), u = e("../names"), f = e("../resolve"), p = e("../util"), m = e("../errors");
        function h({ gen: e2, validateName: t2, schema: r2, schemaEnv: o2, opts: s2 }, a2) {
          s2.code.es5 ? e2.func(t2, d._`${u.default.data}, ${u.default.valCxt}`, o2.$async, () => {
            e2.code(d._`"use strict"; ${y(r2, s2)}`), function(e3, t3) {
              e3.if(u.default.valCxt, () => {
                e3.var(u.default.instancePath, d._`${u.default.valCxt}.${u.default.instancePath}`), e3.var(u.default.parentData, d._`${u.default.valCxt}.${u.default.parentData}`), e3.var(u.default.parentDataProperty, d._`${u.default.valCxt}.${u.default.parentDataProperty}`), e3.var(u.default.rootData, d._`${u.default.valCxt}.${u.default.rootData}`), t3.dynamicRef && e3.var(u.default.dynamicAnchors, d._`${u.default.valCxt}.${u.default.dynamicAnchors}`);
              }, () => {
                e3.var(u.default.instancePath, d._`""`), e3.var(u.default.parentData, d._`undefined`), e3.var(u.default.parentDataProperty, d._`undefined`), e3.var(u.default.rootData, u.default.data), t3.dynamicRef && e3.var(u.default.dynamicAnchors, d._`{}`);
              });
            }(e2, s2), e2.code(a2);
          }) : e2.func(t2, d._`${u.default.data}, ${function(e3) {
            return d._`{${u.default.instancePath}="", ${u.default.parentData}, ${u.default.parentDataProperty}, ${u.default.rootData}=${u.default.data}${e3.dynamicRef ? d._`, ${u.default.dynamicAnchors}={}` : d.nil}}={}`;
          }(s2)}`, o2.$async, () => e2.code(y(r2, s2)).code(a2));
        }
        function y(e2, t2) {
          const r2 = "object" == typeof e2 && e2[t2.schemaId];
          return r2 && (t2.code.source || t2.code.process) ? d._`/*# sourceURL=${r2} */` : d.nil;
        }
        function v(e2, t2) {
          $(e2) && (_(e2), g(e2)) ? function(e3, t3) {
            const { schema: r2, gen: o2, opts: s2 } = e3;
            s2.$comment && r2.$comment && b(e3);
            (function(e4) {
              const t4 = e4.schema[e4.opts.schemaId];
              t4 && (e4.baseId = (0, f.resolveUrl)(e4.opts.uriResolver, e4.baseId, t4));
            })(e3), function(e4) {
              if (e4.schema.$async && !e4.schemaEnv.$async)
                throw new Error("async schema in sync schema");
            }(e3);
            const a2 = o2.const("_errs", u.default.errors);
            w(e3, a2), o2.var(t3, d._`${a2} === ${u.default.errors}`);
          }(e2, t2) : (0, o.boolOrEmptySchema)(e2, t2);
        }
        function g({ schema: e2, self: t2 }) {
          if ("boolean" == typeof e2)
            return !e2;
          for (const r2 in e2)
            if (t2.RULES.all[r2])
              return true;
          return false;
        }
        function $(e2) {
          return "boolean" != typeof e2.schema;
        }
        function _(e2) {
          (0, p.checkUnknownRules)(e2), function(e3) {
            const { schema: t2, errSchemaPath: r2, opts: o2, self: s2 } = e3;
            t2.$ref && o2.ignoreKeywordsWithRef && (0, p.schemaHasRulesButRef)(t2, s2.RULES) && s2.logger.warn(`$ref: keywords ignored in schema at path "${r2}"`);
          }(e2);
        }
        function w(e2, t2) {
          if (e2.opts.jtd)
            return E(e2, [], false, t2);
          const r2 = (0, s.getSchemaTypes)(e2.schema);
          E(e2, r2, !(0, s.coerceAndCheckDataType)(e2, r2), t2);
        }
        function b({ gen: e2, schemaEnv: t2, schema: r2, errSchemaPath: o2, opts: s2 }) {
          const a2 = r2.$comment;
          if (true === s2.$comment)
            e2.code(d._`${u.default.self}.logger.log(${a2})`);
          else if ("function" == typeof s2.$comment) {
            const r3 = d.str`${o2}/$comment`, s3 = e2.scopeValue("root", { ref: t2.root });
            e2.code(d._`${u.default.self}.opts.$comment(${a2}, ${r3}, ${s3}.schema)`);
          }
        }
        function E(e2, t2, r2, o2) {
          const { gen: s2, schema: i2, data: c2, allErrors: l2, opts: f2, self: m2 } = e2, { RULES: h2 } = m2;
          function y2(p2) {
            (0, a.shouldUseGroup)(i2, p2) && (p2.type ? (s2.if((0, n.checkDataType)(p2.type, c2, f2.strictNumbers)), P(e2, p2), 1 === t2.length && t2[0] === p2.type && r2 && (s2.else(), (0, n.reportTypeError)(e2)), s2.endIf()) : P(e2, p2), l2 || s2.if(d._`${u.default.errors} === ${o2 || 0}`));
          }
          !i2.$ref || !f2.ignoreKeywordsWithRef && (0, p.schemaHasRulesButRef)(i2, h2) ? (f2.jtd || function(e3, t3) {
            if (e3.schemaEnv.meta || !e3.opts.strictTypes)
              return;
            (function(e4, t4) {
              if (!t4.length)
                return;
              if (!e4.dataTypes.length)
                return void (e4.dataTypes = t4);
              t4.forEach((t5) => {
                N(e4.dataTypes, t5) || k(e4, `type "${t5}" not allowed by context "${e4.dataTypes.join(",")}"`);
              }), e4.dataTypes = e4.dataTypes.filter((e5) => N(t4, e5));
            })(e3, t3), e3.opts.allowUnionTypes || function(e4, t4) {
              t4.length > 1 && (2 !== t4.length || !t4.includes("null")) && k(e4, "use allowUnionTypes to allow union type keyword");
            }(e3, t3);
            !function(e4, t4) {
              const r3 = e4.self.RULES.all;
              for (const o3 in r3) {
                const s3 = r3[o3];
                if ("object" == typeof s3 && (0, a.shouldUseRule)(e4.schema, s3)) {
                  const { type: r4 } = s3.definition;
                  r4.length && !r4.some((e5) => S(t4, e5)) && k(e4, `missing type "${r4.join(",")}" for keyword "${o3}"`);
                }
              }
            }(e3, e3.dataTypes);
          }(e2, t2), s2.block(() => {
            for (const e3 of h2.rules)
              y2(e3);
            y2(h2.post);
          })) : s2.block(() => C(e2, "$ref", h2.all.$ref.definition));
        }
        function P(e2, t2) {
          const { gen: r2, schema: o2, opts: { useDefaults: s2 } } = e2;
          s2 && (0, i.assignDefaults)(e2, t2.type), r2.block(() => {
            for (const r3 of t2.rules)
              (0, a.shouldUseRule)(o2, r3) && C(e2, r3.keyword, r3.definition, t2.type);
          });
        }
        function S(e2, t2) {
          return e2.includes(t2) || "number" === t2 && e2.includes("integer");
        }
        function N(e2, t2) {
          return e2.includes(t2) || "integer" === t2 && e2.includes("number");
        }
        function k(e2, t2) {
          (0, p.checkStrictMode)(e2, t2 += ` at "${e2.schemaEnv.baseId + e2.errSchemaPath}" (strictTypes)`, e2.opts.strictTypes);
        }
        r.validateFunctionCode = function(e2) {
          $(e2) && (_(e2), g(e2)) ? function(e3) {
            const { schema: t2, opts: r2, gen: o2 } = e3;
            h(e3, () => {
              r2.$comment && t2.$comment && b(e3), function(e4) {
                const { schema: t3, opts: r3 } = e4;
                void 0 !== t3.default && r3.useDefaults && r3.strictSchema && (0, p.checkStrictMode)(e4, "default is ignored in the schema root");
              }(e3), o2.let(u.default.vErrors, null), o2.let(u.default.errors, 0), r2.unevaluated && function(e4) {
                const { gen: t3, validateName: r3 } = e4;
                e4.evaluated = t3.const("evaluated", d._`${r3}.evaluated`), t3.if(d._`${e4.evaluated}.dynamicProps`, () => t3.assign(d._`${e4.evaluated}.props`, d._`undefined`)), t3.if(d._`${e4.evaluated}.dynamicItems`, () => t3.assign(d._`${e4.evaluated}.items`, d._`undefined`));
              }(e3), w(e3), function(e4) {
                const { gen: t3, schemaEnv: r3, validateName: o3, ValidationError: s2, opts: a2 } = e4;
                r3.$async ? t3.if(d._`${u.default.errors} === 0`, () => t3.return(u.default.data), () => t3.throw(d._`new ${s2}(${u.default.vErrors})`)) : (t3.assign(d._`${o3}.errors`, u.default.vErrors), a2.unevaluated && function({ gen: e5, evaluated: t4, props: r4, items: o4 }) {
                  r4 instanceof d.Name && e5.assign(d._`${t4}.props`, r4);
                  o4 instanceof d.Name && e5.assign(d._`${t4}.items`, o4);
                }(e4), t3.return(d._`${u.default.errors} === 0`));
              }(e3);
            });
          }(e2) : h(e2, () => (0, o.topBoolOrEmptySchema)(e2));
        };
        class j {
          constructor(e2, t2, r2) {
            if ((0, c.validateKeywordUsage)(e2, t2, r2), this.gen = e2.gen, this.allErrors = e2.allErrors, this.keyword = r2, this.data = e2.data, this.schema = e2.schema[r2], this.$data = t2.$data && e2.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, p.schemaRefOrVal)(e2, this.schema, r2, this.$data), this.schemaType = t2.schemaType, this.parentSchema = e2.schema, this.params = {}, this.it = e2, this.def = t2, this.$data)
              this.schemaCode = e2.gen.const("vSchema", T(this.$data, e2));
            else if (this.schemaCode = this.schemaValue, !(0, c.validSchemaType)(this.schema, t2.schemaType, t2.allowUndefined))
              throw new Error(`${r2} value must be ${JSON.stringify(t2.schemaType)}`);
            ("code" in t2 ? t2.trackErrors : false !== t2.errors) && (this.errsCount = e2.gen.const("_errs", u.default.errors));
          }
          result(e2, t2, r2) {
            this.failResult((0, d.not)(e2), t2, r2);
          }
          failResult(e2, t2, r2) {
            this.gen.if(e2), r2 ? r2() : this.error(), t2 ? (this.gen.else(), t2(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
          }
          pass(e2, t2) {
            this.failResult((0, d.not)(e2), void 0, t2);
          }
          fail(e2) {
            if (void 0 === e2)
              return this.error(), void (this.allErrors || this.gen.if(false));
            this.gen.if(e2), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
          }
          fail$data(e2) {
            if (!this.$data)
              return this.fail(e2);
            const { schemaCode: t2 } = this;
            this.fail(d._`${t2} !== undefined && (${(0, d.or)(this.invalid$data(), e2)})`);
          }
          error(e2, t2, r2) {
            if (t2)
              return this.setParams(t2), this._error(e2, r2), void this.setParams({});
            this._error(e2, r2);
          }
          _error(e2, t2) {
            (e2 ? m.reportExtraError : m.reportError)(this, this.def.error, t2);
          }
          $dataError() {
            (0, m.reportError)(this, this.def.$dataError || m.keyword$DataError);
          }
          reset() {
            if (void 0 === this.errsCount)
              throw new Error('add "trackErrors" to keyword definition');
            (0, m.resetErrorsCount)(this.gen, this.errsCount);
          }
          ok(e2) {
            this.allErrors || this.gen.if(e2);
          }
          setParams(e2, t2) {
            t2 ? Object.assign(this.params, e2) : this.params = e2;
          }
          block$data(e2, t2, r2 = d.nil) {
            this.gen.block(() => {
              this.check$data(e2, r2), t2();
            });
          }
          check$data(e2 = d.nil, t2 = d.nil) {
            if (!this.$data)
              return;
            const { gen: r2, schemaCode: o2, schemaType: s2, def: a2 } = this;
            r2.if((0, d.or)(d._`${o2} === undefined`, t2)), e2 !== d.nil && r2.assign(e2, true), (s2.length || a2.validateSchema) && (r2.elseIf(this.invalid$data()), this.$dataError(), e2 !== d.nil && r2.assign(e2, false)), r2.else();
          }
          invalid$data() {
            const { gen: e2, schemaCode: t2, schemaType: r2, def: o2, it: s2 } = this;
            return (0, d.or)(function() {
              if (r2.length) {
                if (!(t2 instanceof d.Name))
                  throw new Error("ajv implementation error");
                const e3 = Array.isArray(r2) ? r2 : [r2];
                return d._`${(0, n.checkDataTypes)(e3, t2, s2.opts.strictNumbers, n.DataType.Wrong)}`;
              }
              return d.nil;
            }(), function() {
              if (o2.validateSchema) {
                const r3 = e2.scopeValue("validate$data", { ref: o2.validateSchema });
                return d._`!${r3}(${t2})`;
              }
              return d.nil;
            }());
          }
          subschema(e2, t2) {
            const r2 = (0, l.getSubschema)(this.it, e2);
            (0, l.extendSubschemaData)(r2, this.it, e2), (0, l.extendSubschemaMode)(r2, e2);
            const o2 = { ...this.it, ...r2, items: void 0, props: void 0 };
            return v(o2, t2), o2;
          }
          mergeEvaluated(e2, t2) {
            const { it: r2, gen: o2 } = this;
            r2.opts.unevaluated && (true !== r2.props && void 0 !== e2.props && (r2.props = p.mergeEvaluated.props(o2, e2.props, r2.props, t2)), true !== r2.items && void 0 !== e2.items && (r2.items = p.mergeEvaluated.items(o2, e2.items, r2.items, t2)));
          }
          mergeValidEvaluated(e2, t2) {
            const { it: r2, gen: o2 } = this;
            if (r2.opts.unevaluated && (true !== r2.props || true !== r2.items))
              return o2.if(t2, () => this.mergeEvaluated(e2, d.Name)), true;
          }
        }
        function C(e2, t2, r2, o2) {
          const s2 = new j(e2, r2, t2);
          "code" in r2 ? r2.code(s2, o2) : s2.$data && r2.validate ? (0, c.funcKeywordCode)(s2, r2) : "macro" in r2 ? (0, c.macroKeywordCode)(s2, r2) : (r2.compile || r2.validate) && (0, c.funcKeywordCode)(s2, r2);
        }
        r.KeywordCxt = j;
        const O = /^\/(?:[^~]|~0|~1)*$/, x = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
        function T(e2, { dataLevel: t2, dataNames: r2, dataPathArr: o2 }) {
          let s2, a2;
          if ("" === e2)
            return u.default.rootData;
          if ("/" === e2[0]) {
            if (!O.test(e2))
              throw new Error(`Invalid JSON-pointer: ${e2}`);
            s2 = e2, a2 = u.default.rootData;
          } else {
            const n3 = x.exec(e2);
            if (!n3)
              throw new Error(`Invalid JSON-pointer: ${e2}`);
            const i3 = +n3[1];
            if (s2 = n3[2], "#" === s2) {
              if (i3 >= t2)
                throw new Error(c2("property/index", i3));
              return o2[t2 - i3];
            }
            if (i3 > t2)
              throw new Error(c2("data", i3));
            if (a2 = r2[t2 - i3], !s2)
              return a2;
          }
          let n2 = a2;
          const i2 = s2.split("/");
          for (const e3 of i2)
            e3 && (a2 = d._`${a2}${(0, d.getProperty)((0, p.unescapeJsonPointer)(e3))}`, n2 = d._`${n2} && ${a2}`);
          return n2;
          function c2(e3, r3) {
            return `Cannot access ${e3} ${r3} levels up, current level is ${t2}`;
          }
        }
        r.getData = T;
      }, { "../codegen": 2, "../errors": 4, "../names": 6, "../resolve": 8, "../util": 10, "./applicability": 11, "./boolSchema": 12, "./dataType": 13, "./defaults": 14, "./keyword": 16, "./subschema": 17 }], 16: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.validateKeywordUsage = r.validSchemaType = r.funcKeywordCode = r.macroKeywordCode = void 0;
        const o = e("../codegen"), s = e("../names"), a = e("../../vocabularies/code"), n = e("../errors");
        function i(e2) {
          const { gen: t2, data: r2, it: s2 } = e2;
          t2.if(s2.parentData, () => t2.assign(r2, o._`${s2.parentData}[${s2.parentDataProperty}]`));
        }
        function c(e2, t2, r2) {
          if (void 0 === r2)
            throw new Error(`keyword "${t2}" failed to compile`);
          return e2.scopeValue("keyword", "function" == typeof r2 ? { ref: r2 } : { ref: r2, code: (0, o.stringify)(r2) });
        }
        r.macroKeywordCode = function(e2, t2) {
          const { gen: r2, keyword: s2, schema: a2, parentSchema: n2, it: i2 } = e2, l = t2.macro.call(i2.self, a2, n2, i2), d = c(r2, s2, l);
          false !== i2.opts.validateSchema && i2.self.validateSchema(l, true);
          const u = r2.name("valid");
          e2.subschema({ schema: l, schemaPath: o.nil, errSchemaPath: `${i2.errSchemaPath}/${s2}`, topSchemaRef: d, compositeRule: true }, u), e2.pass(u, () => e2.error(true));
        }, r.funcKeywordCode = function(e2, t2) {
          var r2;
          const { gen: l, keyword: d, schema: u, parentSchema: f, $data: p, it: m } = e2;
          !function({ schemaEnv: e3 }, t3) {
            if (t3.async && !e3.$async)
              throw new Error("async keyword in sync schema");
          }(m, t2);
          const h = !p && t2.compile ? t2.compile.call(m.self, u, f, m) : t2.validate, y = c(l, d, h), v = l.let("valid");
          function g(r3 = t2.async ? o._`await ` : o.nil) {
            l.assign(v, o._`${r3}${(0, a.callValidateCode)(e2, y, m.opts.passContext ? s.default.this : s.default.self, !("compile" in t2 && !p || false === t2.schema))}`, t2.modifying);
          }
          function $(e3) {
            var r3;
            l.if((0, o.not)(null !== (r3 = t2.valid) && void 0 !== r3 ? r3 : v), e3);
          }
          e2.block$data(v, function() {
            if (false === t2.errors)
              g(), t2.modifying && i(e2), $(() => e2.error());
            else {
              const r3 = t2.async ? function() {
                const e3 = l.let("ruleErrs", null);
                return l.try(() => g(o._`await `), (t3) => l.assign(v, false).if(o._`${t3} instanceof ${m.ValidationError}`, () => l.assign(e3, o._`${t3}.errors`), () => l.throw(t3))), e3;
              }() : function() {
                const e3 = o._`${y}.errors`;
                return l.assign(e3, null), g(o.nil), e3;
              }();
              t2.modifying && i(e2), $(() => function(e3, t3) {
                const { gen: r4 } = e3;
                r4.if(o._`Array.isArray(${t3})`, () => {
                  r4.assign(s.default.vErrors, o._`${s.default.vErrors} === null ? ${t3} : ${s.default.vErrors}.concat(${t3})`).assign(s.default.errors, o._`${s.default.vErrors}.length`), (0, n.extendErrors)(e3);
                }, () => e3.error());
              }(e2, r3));
            }
          }), e2.ok(null !== (r2 = t2.valid) && void 0 !== r2 ? r2 : v);
        }, r.validSchemaType = function(e2, t2, r2 = false) {
          return !t2.length || t2.some((t3) => "array" === t3 ? Array.isArray(e2) : "object" === t3 ? e2 && "object" == typeof e2 && !Array.isArray(e2) : typeof e2 == t3 || r2 && void 0 === e2);
        }, r.validateKeywordUsage = function({ schema: e2, opts: t2, self: r2, errSchemaPath: o2 }, s2, a2) {
          if (Array.isArray(s2.keyword) ? !s2.keyword.includes(a2) : s2.keyword !== a2)
            throw new Error("ajv implementation error");
          const n2 = s2.dependencies;
          if (null == n2 ? void 0 : n2.some((t3) => !Object.prototype.hasOwnProperty.call(e2, t3)))
            throw new Error(`parent schema must have dependencies of ${a2}: ${n2.join(",")}`);
          if (s2.validateSchema) {
            if (!s2.validateSchema(e2[a2])) {
              const e3 = `keyword "${a2}" value is invalid at path "${o2}": ` + r2.errorsText(s2.validateSchema.errors);
              if ("log" !== t2.validateSchema)
                throw new Error(e3);
              r2.logger.error(e3);
            }
          }
        };
      }, { "../../vocabularies/code": 42, "../codegen": 2, "../errors": 4, "../names": 6 }], 17: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.extendSubschemaMode = r.extendSubschemaData = r.getSubschema = void 0;
        const o = e("../codegen"), s = e("../util");
        r.getSubschema = function(e2, { keyword: t2, schemaProp: r2, schema: a, schemaPath: n, errSchemaPath: i, topSchemaRef: c }) {
          if (void 0 !== t2 && void 0 !== a)
            throw new Error('both "keyword" and "schema" passed, only one allowed');
          if (void 0 !== t2) {
            const a2 = e2.schema[t2];
            return void 0 === r2 ? { schema: a2, schemaPath: o._`${e2.schemaPath}${(0, o.getProperty)(t2)}`, errSchemaPath: `${e2.errSchemaPath}/${t2}` } : { schema: a2[r2], schemaPath: o._`${e2.schemaPath}${(0, o.getProperty)(t2)}${(0, o.getProperty)(r2)}`, errSchemaPath: `${e2.errSchemaPath}/${t2}/${(0, s.escapeFragment)(r2)}` };
          }
          if (void 0 !== a) {
            if (void 0 === n || void 0 === i || void 0 === c)
              throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
            return { schema: a, schemaPath: n, topSchemaRef: c, errSchemaPath: i };
          }
          throw new Error('either "keyword" or "schema" must be passed');
        }, r.extendSubschemaData = function(e2, t2, { dataProp: r2, dataPropType: a, data: n, dataTypes: i, propertyName: c }) {
          if (void 0 !== n && void 0 !== r2)
            throw new Error('both "data" and "dataProp" passed, only one allowed');
          const { gen: l } = t2;
          if (void 0 !== r2) {
            const { errorPath: n2, dataPathArr: i2, opts: c2 } = t2;
            d(l.let("data", o._`${t2.data}${(0, o.getProperty)(r2)}`, true)), e2.errorPath = o.str`${n2}${(0, s.getErrorPath)(r2, a, c2.jsPropertySyntax)}`, e2.parentDataProperty = o._`${r2}`, e2.dataPathArr = [...i2, e2.parentDataProperty];
          }
          if (void 0 !== n) {
            d(n instanceof o.Name ? n : l.let("data", n, true)), void 0 !== c && (e2.propertyName = c);
          }
          function d(r3) {
            e2.data = r3, e2.dataLevel = t2.dataLevel + 1, e2.dataTypes = [], t2.definedProperties = /* @__PURE__ */ new Set(), e2.parentData = t2.data, e2.dataNames = [...t2.dataNames, r3];
          }
          i && (e2.dataTypes = i);
        }, r.extendSubschemaMode = function(e2, { jtdDiscriminator: t2, jtdMetadata: r2, compositeRule: o2, createErrors: s2, allErrors: a }) {
          void 0 !== o2 && (e2.compositeRule = o2), void 0 !== s2 && (e2.createErrors = s2), void 0 !== a && (e2.allErrors = a), e2.jtdDiscriminator = t2, e2.jtdMetadata = r2;
        };
      }, { "../codegen": 2, "../util": 10 }], 18: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.CodeGen = r.Name = r.nil = r.stringify = r.str = r._ = r.KeywordCxt = void 0;
        var o = e("./compile/validate");
        Object.defineProperty(r, "KeywordCxt", { enumerable: true, get() {
          return o.KeywordCxt;
        } });
        var s = e("./compile/codegen");
        Object.defineProperty(r, "_", { enumerable: true, get() {
          return s._;
        } }), Object.defineProperty(r, "str", { enumerable: true, get() {
          return s.str;
        } }), Object.defineProperty(r, "stringify", { enumerable: true, get() {
          return s.stringify;
        } }), Object.defineProperty(r, "nil", { enumerable: true, get() {
          return s.nil;
        } }), Object.defineProperty(r, "Name", { enumerable: true, get() {
          return s.Name;
        } }), Object.defineProperty(r, "CodeGen", { enumerable: true, get() {
          return s.CodeGen;
        } });
        const a = e("./runtime/validation_error"), n = e("./compile/ref_error"), i = e("./compile/rules"), c = e("./compile"), l = e("./compile/codegen"), d = e("./compile/resolve"), u = e("./compile/validate/dataType"), f = e("./compile/util"), p = e("./refs/data.json"), m = e("./runtime/uri"), h = (e2, t2) => new RegExp(e2, t2);
        h.code = "new RegExp";
        const y = ["removeAdditional", "useDefaults", "coerceTypes"], v = /* @__PURE__ */ new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]), g = { errorDataPath: "", format: "`validateFormats: false` can be used instead.", nullable: '"nullable" keyword is supported by default.', jsonPointers: "Deprecated jsPropertySyntax can be used instead.", extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.", missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.", processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`", sourceCode: "Use option `code: {source: true}`", strictDefaults: "It is default now, see option `strict`.", strictKeywords: "It is default now, see option `strict`.", uniqueItems: '"uniqueItems" keyword is always validated.', unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).", cache: "Map is used as cache, schema object as key.", serialize: "Map is used as cache, schema object as key.", ajvErrors: "It is default now." }, $ = { ignoreKeywordsWithRef: "", jsPropertySyntax: "", unicode: '"minLength"/"maxLength" account for unicode characters by default.' };
        function _(e2) {
          var t2, r2, o2, s2, a2, n2, i2, c2, l2, d2, u2, f2, p2, y2, v2, g2, $2, _2, w2, b2, E2, P2, S2, N2, k2;
          const j2 = e2.strict, C2 = null === (t2 = e2.code) || void 0 === t2 ? void 0 : t2.optimize, O2 = true === C2 || void 0 === C2 ? 1 : C2 || 0, x2 = null !== (o2 = null === (r2 = e2.code) || void 0 === r2 ? void 0 : r2.regExp) && void 0 !== o2 ? o2 : h, T2 = null !== (s2 = e2.uriResolver) && void 0 !== s2 ? s2 : m.default;
          return { strictSchema: null === (n2 = null !== (a2 = e2.strictSchema) && void 0 !== a2 ? a2 : j2) || void 0 === n2 || n2, strictNumbers: null === (c2 = null !== (i2 = e2.strictNumbers) && void 0 !== i2 ? i2 : j2) || void 0 === c2 || c2, strictTypes: null !== (d2 = null !== (l2 = e2.strictTypes) && void 0 !== l2 ? l2 : j2) && void 0 !== d2 ? d2 : "log", strictTuples: null !== (f2 = null !== (u2 = e2.strictTuples) && void 0 !== u2 ? u2 : j2) && void 0 !== f2 ? f2 : "log", strictRequired: null !== (y2 = null !== (p2 = e2.strictRequired) && void 0 !== p2 ? p2 : j2) && void 0 !== y2 && y2, code: e2.code ? { ...e2.code, optimize: O2, regExp: x2 } : { optimize: O2, regExp: x2 }, loopRequired: null !== (v2 = e2.loopRequired) && void 0 !== v2 ? v2 : 200, loopEnum: null !== (g2 = e2.loopEnum) && void 0 !== g2 ? g2 : 200, meta: null === ($2 = e2.meta) || void 0 === $2 || $2, messages: null === (_2 = e2.messages) || void 0 === _2 || _2, inlineRefs: null === (w2 = e2.inlineRefs) || void 0 === w2 || w2, schemaId: null !== (b2 = e2.schemaId) && void 0 !== b2 ? b2 : "$id", addUsedSchema: null === (E2 = e2.addUsedSchema) || void 0 === E2 || E2, validateSchema: null === (P2 = e2.validateSchema) || void 0 === P2 || P2, validateFormats: null === (S2 = e2.validateFormats) || void 0 === S2 || S2, unicodeRegExp: null === (N2 = e2.unicodeRegExp) || void 0 === N2 || N2, int32range: null === (k2 = e2.int32range) || void 0 === k2 || k2, uriResolver: T2 };
        }
        class w {
          constructor(e2 = {}) {
            this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), e2 = this.opts = { ...e2, ..._(e2) };
            const { es5: t2, lines: r2 } = this.opts.code;
            this.scope = new l.ValueScope({ scope: {}, prefixes: v, es5: t2, lines: r2 }), this.logger = function(e3) {
              if (false === e3)
                return j;
              if (void 0 === e3)
                return console;
              if (e3.log && e3.warn && e3.error)
                return e3;
              throw new Error("logger must implement log, warn and error methods");
            }(e2.logger);
            const o2 = e2.validateFormats;
            e2.validateFormats = false, this.RULES = (0, i.getRules)(), b.call(this, g, e2, "NOT SUPPORTED"), b.call(this, $, e2, "DEPRECATED", "warn"), this._metaOpts = k.call(this), e2.formats && S.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), e2.keywords && N.call(this, e2.keywords), "object" == typeof e2.meta && this.addMetaSchema(e2.meta), P.call(this), e2.validateFormats = o2;
          }
          _addVocabularies() {
            this.addKeyword("$async");
          }
          _addDefaultMetaSchema() {
            const { $data: e2, meta: t2, schemaId: r2 } = this.opts;
            let o2 = p;
            "id" === r2 && (o2 = { ...p }, o2.id = o2.$id, delete o2.$id), t2 && e2 && this.addMetaSchema(o2, o2[r2], false);
          }
          defaultMeta() {
            const { meta: e2, schemaId: t2 } = this.opts;
            return this.opts.defaultMeta = "object" == typeof e2 ? e2[t2] || e2 : void 0;
          }
          validate(e2, t2) {
            let r2;
            if ("string" == typeof e2) {
              if (r2 = this.getSchema(e2), !r2)
                throw new Error(`no schema with key or ref "${e2}"`);
            } else
              r2 = this.compile(e2);
            const o2 = r2(t2);
            return "$async" in r2 || (this.errors = r2.errors), o2;
          }
          compile(e2, t2) {
            const r2 = this._addSchema(e2, t2);
            return r2.validate || this._compileSchemaEnv(r2);
          }
          compileAsync(e2, t2) {
            if ("function" != typeof this.opts.loadSchema)
              throw new Error("options.loadSchema should be a function");
            const { loadSchema: r2 } = this.opts;
            return o2.call(this, e2, t2);
            async function o2(e3, t3) {
              await s2.call(this, e3.$schema);
              const r3 = this._addSchema(e3, t3);
              return r3.validate || a2.call(this, r3);
            }
            async function s2(e3) {
              e3 && !this.getSchema(e3) && await o2.call(this, { $ref: e3 }, true);
            }
            async function a2(e3) {
              try {
                return this._compileSchemaEnv(e3);
              } catch (t3) {
                if (!(t3 instanceof n.default))
                  throw t3;
                return i2.call(this, t3), await c2.call(this, t3.missingSchema), a2.call(this, e3);
              }
            }
            function i2({ missingSchema: e3, missingRef: t3 }) {
              if (this.refs[e3])
                throw new Error(`AnySchema ${e3} is loaded but ${t3} cannot be resolved`);
            }
            async function c2(e3) {
              const r3 = await l2.call(this, e3);
              this.refs[e3] || await s2.call(this, r3.$schema), this.refs[e3] || this.addSchema(r3, e3, t2);
            }
            async function l2(e3) {
              const t3 = this._loading[e3];
              if (t3)
                return t3;
              try {
                return await (this._loading[e3] = r2(e3));
              } finally {
                delete this._loading[e3];
              }
            }
          }
          addSchema(e2, t2, r2, o2 = this.opts.validateSchema) {
            if (Array.isArray(e2)) {
              for (const t3 of e2)
                this.addSchema(t3, void 0, r2, o2);
              return this;
            }
            let s2;
            if ("object" == typeof e2) {
              const { schemaId: t3 } = this.opts;
              if (s2 = e2[t3], void 0 !== s2 && "string" != typeof s2)
                throw new Error(`schema ${t3} must be string`);
            }
            return t2 = (0, d.normalizeId)(t2 || s2), this._checkUnique(t2), this.schemas[t2] = this._addSchema(e2, r2, t2, o2, true), this;
          }
          addMetaSchema(e2, t2, r2 = this.opts.validateSchema) {
            return this.addSchema(e2, t2, true, r2), this;
          }
          validateSchema(e2, t2) {
            if ("boolean" == typeof e2)
              return true;
            let r2;
            if (r2 = e2.$schema, void 0 !== r2 && "string" != typeof r2)
              throw new Error("$schema must be a string");
            if (r2 = r2 || this.opts.defaultMeta || this.defaultMeta(), !r2)
              return this.logger.warn("meta-schema not available"), this.errors = null, true;
            const o2 = this.validate(r2, e2);
            if (!o2 && t2) {
              const e3 = "schema is invalid: " + this.errorsText();
              if ("log" !== this.opts.validateSchema)
                throw new Error(e3);
              this.logger.error(e3);
            }
            return o2;
          }
          getSchema(e2) {
            let t2;
            for (; "string" == typeof (t2 = E.call(this, e2)); )
              e2 = t2;
            if (void 0 === t2) {
              const { schemaId: r2 } = this.opts, o2 = new c.SchemaEnv({ schema: {}, schemaId: r2 });
              if (t2 = c.resolveSchema.call(this, o2, e2), !t2)
                return;
              this.refs[e2] = t2;
            }
            return t2.validate || this._compileSchemaEnv(t2);
          }
          removeSchema(e2) {
            if (e2 instanceof RegExp)
              return this._removeAllSchemas(this.schemas, e2), this._removeAllSchemas(this.refs, e2), this;
            switch (typeof e2) {
              case "undefined":
                return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
              case "string": {
                const t2 = E.call(this, e2);
                return "object" == typeof t2 && this._cache.delete(t2.schema), delete this.schemas[e2], delete this.refs[e2], this;
              }
              case "object": {
                this._cache.delete(e2);
                let t2 = e2[this.opts.schemaId];
                return t2 && (t2 = (0, d.normalizeId)(t2), delete this.schemas[t2], delete this.refs[t2]), this;
              }
              default:
                throw new Error("ajv.removeSchema: invalid parameter");
            }
          }
          addVocabulary(e2) {
            for (const t2 of e2)
              this.addKeyword(t2);
            return this;
          }
          addKeyword(e2, t2) {
            let r2;
            if ("string" == typeof e2)
              r2 = e2, "object" == typeof t2 && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), t2.keyword = r2);
            else {
              if ("object" != typeof e2 || void 0 !== t2)
                throw new Error("invalid addKeywords parameters");
              if (r2 = (t2 = e2).keyword, Array.isArray(r2) && !r2.length)
                throw new Error("addKeywords: keyword must be string or non-empty array");
            }
            if (O.call(this, r2, t2), !t2)
              return (0, f.eachItem)(r2, (e3) => x.call(this, e3)), this;
            I.call(this, t2);
            const o2 = { ...t2, type: (0, u.getJSONTypes)(t2.type), schemaType: (0, u.getJSONTypes)(t2.schemaType) };
            return (0, f.eachItem)(r2, 0 === o2.type.length ? (e3) => x.call(this, e3, o2) : (e3) => o2.type.forEach((t3) => x.call(this, e3, o2, t3))), this;
          }
          getKeyword(e2) {
            const t2 = this.RULES.all[e2];
            return "object" == typeof t2 ? t2.definition : !!t2;
          }
          removeKeyword(e2) {
            const { RULES: t2 } = this;
            delete t2.keywords[e2], delete t2.all[e2];
            for (const r2 of t2.rules) {
              const t3 = r2.rules.findIndex((t4) => t4.keyword === e2);
              t3 >= 0 && r2.rules.splice(t3, 1);
            }
            return this;
          }
          addFormat(e2, t2) {
            return "string" == typeof t2 && (t2 = new RegExp(t2)), this.formats[e2] = t2, this;
          }
          errorsText(e2 = this.errors, { separator: t2 = ", ", dataVar: r2 = "data" } = {}) {
            return e2 && 0 !== e2.length ? e2.map((e3) => `${r2}${e3.instancePath} ${e3.message}`).reduce((e3, r3) => e3 + t2 + r3) : "No errors";
          }
          $dataMetaSchema(e2, t2) {
            const r2 = this.RULES.all;
            e2 = JSON.parse(JSON.stringify(e2));
            for (const o2 of t2) {
              const t3 = o2.split("/").slice(1);
              let s2 = e2;
              for (const e3 of t3)
                s2 = s2[e3];
              for (const e3 in r2) {
                const t4 = r2[e3];
                if ("object" != typeof t4)
                  continue;
                const { $data: o3 } = t4.definition, a2 = s2[e3];
                o3 && a2 && (s2[e3] = D(a2));
              }
            }
            return e2;
          }
          _removeAllSchemas(e2, t2) {
            for (const r2 in e2) {
              const o2 = e2[r2];
              t2 && !t2.test(r2) || ("string" == typeof o2 ? delete e2[r2] : o2 && !o2.meta && (this._cache.delete(o2.schema), delete e2[r2]));
            }
          }
          _addSchema(e2, t2, r2, o2 = this.opts.validateSchema, s2 = this.opts.addUsedSchema) {
            let a2;
            const { schemaId: n2 } = this.opts;
            if ("object" == typeof e2)
              a2 = e2[n2];
            else {
              if (this.opts.jtd)
                throw new Error("schema must be object");
              if ("boolean" != typeof e2)
                throw new Error("schema must be object or boolean");
            }
            let i2 = this._cache.get(e2);
            if (void 0 !== i2)
              return i2;
            r2 = (0, d.normalizeId)(a2 || r2);
            const l2 = d.getSchemaRefs.call(this, e2, r2);
            return i2 = new c.SchemaEnv({ schema: e2, schemaId: n2, meta: t2, baseId: r2, localRefs: l2 }), this._cache.set(i2.schema, i2), s2 && !r2.startsWith("#") && (r2 && this._checkUnique(r2), this.refs[r2] = i2), o2 && this.validateSchema(e2, true), i2;
          }
          _checkUnique(e2) {
            if (this.schemas[e2] || this.refs[e2])
              throw new Error(`schema with key or id "${e2}" already exists`);
          }
          _compileSchemaEnv(e2) {
            if (e2.meta ? this._compileMetaSchema(e2) : c.compileSchema.call(this, e2), !e2.validate)
              throw new Error("ajv implementation error");
            return e2.validate;
          }
          _compileMetaSchema(e2) {
            const t2 = this.opts;
            this.opts = this._metaOpts;
            try {
              c.compileSchema.call(this, e2);
            } finally {
              this.opts = t2;
            }
          }
        }
        function b(e2, t2, r2, o2 = "error") {
          for (const s2 in e2) {
            const a2 = s2;
            a2 in t2 && this.logger[o2](`${r2}: option ${s2}. ${e2[a2]}`);
          }
        }
        function E(e2) {
          return e2 = (0, d.normalizeId)(e2), this.schemas[e2] || this.refs[e2];
        }
        function P() {
          const e2 = this.opts.schemas;
          if (e2)
            if (Array.isArray(e2))
              this.addSchema(e2);
            else
              for (const t2 in e2)
                this.addSchema(e2[t2], t2);
        }
        function S() {
          for (const e2 in this.opts.formats) {
            const t2 = this.opts.formats[e2];
            t2 && this.addFormat(e2, t2);
          }
        }
        function N(e2) {
          if (Array.isArray(e2))
            this.addVocabulary(e2);
          else {
            this.logger.warn("keywords option as map is deprecated, pass array");
            for (const t2 in e2) {
              const r2 = e2[t2];
              r2.keyword || (r2.keyword = t2), this.addKeyword(r2);
            }
          }
        }
        function k() {
          const e2 = { ...this.opts };
          for (const t2 of y)
            delete e2[t2];
          return e2;
        }
        r.default = w, w.ValidationError = a.default, w.MissingRefError = n.default;
        const j = { log() {
        }, warn() {
        }, error() {
        } };
        const C = /^[a-z_$][a-z0-9_$:-]*$/i;
        function O(e2, t2) {
          const { RULES: r2 } = this;
          if ((0, f.eachItem)(e2, (e3) => {
            if (r2.keywords[e3])
              throw new Error(`Keyword ${e3} is already defined`);
            if (!C.test(e3))
              throw new Error(`Keyword ${e3} has invalid name`);
          }), t2 && t2.$data && !("code" in t2) && !("validate" in t2))
            throw new Error('$data keyword must have "code" or "validate" function');
        }
        function x(e2, t2, r2) {
          var o2;
          const s2 = null == t2 ? void 0 : t2.post;
          if (r2 && s2)
            throw new Error('keyword with "post" flag cannot have "type"');
          const { RULES: a2 } = this;
          let n2 = s2 ? a2.post : a2.rules.find(({ type: e3 }) => e3 === r2);
          if (n2 || (n2 = { type: r2, rules: [] }, a2.rules.push(n2)), a2.keywords[e2] = true, !t2)
            return;
          const i2 = { keyword: e2, definition: { ...t2, type: (0, u.getJSONTypes)(t2.type), schemaType: (0, u.getJSONTypes)(t2.schemaType) } };
          t2.before ? T.call(this, n2, i2, t2.before) : n2.rules.push(i2), a2.all[e2] = i2, null === (o2 = t2.implements) || void 0 === o2 || o2.forEach((e3) => this.addKeyword(e3));
        }
        function T(e2, t2, r2) {
          const o2 = e2.rules.findIndex((e3) => e3.keyword === r2);
          o2 >= 0 ? e2.rules.splice(o2, 0, t2) : (e2.rules.push(t2), this.logger.warn(`rule ${r2} is not defined`));
        }
        function I(e2) {
          let { metaSchema: t2 } = e2;
          void 0 !== t2 && (e2.$data && this.opts.$data && (t2 = D(t2)), e2.validateSchema = this.compile(t2, true));
        }
        const R = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
        function D(e2) {
          return { anyOf: [e2, R] };
        }
      }, { "./compile": 5, "./compile/codegen": 2, "./compile/ref_error": 7, "./compile/resolve": 8, "./compile/rules": 9, "./compile/util": 10, "./compile/validate": 15, "./compile/validate/dataType": 13, "./refs/data.json": 19, "./runtime/uri": 23, "./runtime/validation_error": 24 }], 19: [function(e, t, r) {
        t.exports = { $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", description: "Meta-schema for $data reference (JSON AnySchema extension proposal)", type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
      }, {}], 20: [function(e, t, r) {
        t.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
      }, {}], 21: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("fast-deep-equal");
        o.code = 'require("ajv/dist/runtime/equal").default', r.default = o;
      }, { "fast-deep-equal": 63 }], 22: [function(e, t, r) {
        "use strict";
        function o(e2) {
          const t2 = e2.length;
          let r2, o2 = 0, s = 0;
          for (; s < t2; )
            o2++, r2 = e2.charCodeAt(s++), r2 >= 55296 && r2 <= 56319 && s < t2 && (r2 = e2.charCodeAt(s), 56320 == (64512 & r2) && s++);
          return o2;
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = o, o.code = 'require("ajv/dist/runtime/ucs2length").default';
      }, {}], 23: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("uri-js");
        o.code = 'require("ajv/dist/runtime/uri").default', r.default = o;
      }, { "uri-js": 65 }], 24: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        class o extends Error {
          constructor(e2) {
            super("validation failed"), this.errors = e2, this.ajv = this.validation = true;
          }
        }
        r.default = o;
      }, {}], 25: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.validateAdditionalItems = void 0;
        const o = e("../../compile/codegen"), s = e("../../compile/util"), a = { keyword: "additionalItems", type: "array", schemaType: ["boolean", "object"], before: "uniqueItems", error: { message({ params: { len: e2 } }) {
          return o.str`must NOT have more than ${e2} items`;
        }, params({ params: { len: e2 } }) {
          return o._`{limit: ${e2}}`;
        } }, code(e2) {
          const { parentSchema: t2, it: r2 } = e2, { items: o2 } = t2;
          Array.isArray(o2) ? n(e2, o2) : (0, s.checkStrictMode)(r2, '"additionalItems" is ignored when "items" is not an array of schemas');
        } };
        function n(e2, t2) {
          const { gen: r2, schema: a2, data: n2, keyword: i, it: c } = e2;
          c.items = true;
          const l = r2.const("len", o._`${n2}.length`);
          if (false === a2)
            e2.setParams({ len: t2.length }), e2.pass(o._`${l} <= ${t2.length}`);
          else if ("object" == typeof a2 && !(0, s.alwaysValidSchema)(c, a2)) {
            const a3 = r2.var("valid", o._`${l} <= ${t2.length}`);
            r2.if((0, o.not)(a3), () => function(a4) {
              r2.forRange("i", t2.length, l, (t3) => {
                e2.subschema({ keyword: i, dataProp: t3, dataPropType: s.Type.Num }, a4), c.allErrors || r2.if((0, o.not)(a4), () => r2.break());
              });
            }(a3)), e2.ok(a3);
          }
        }
        r.validateAdditionalItems = n, r.default = a;
      }, { "../../compile/codegen": 2, "../../compile/util": 10 }], 26: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../code"), s = e("../../compile/codegen"), a = e("../../compile/names"), n = e("../../compile/util");
        r.default = { keyword: "additionalProperties", type: ["object"], schemaType: ["boolean", "object"], allowUndefined: true, trackErrors: true, error: { message: "must NOT have additional properties", params({ params: e2 }) {
          return s._`{additionalProperty: ${e2.additionalProperty}}`;
        } }, code(e2) {
          const { gen: t2, schema: r2, parentSchema: i, data: c, errsCount: l, it: d } = e2;
          if (!l)
            throw new Error("ajv implementation error");
          const { allErrors: u, opts: f } = d;
          if (d.props = true, "all" !== f.removeAdditional && (0, n.alwaysValidSchema)(d, r2))
            return;
          const p = (0, o.allSchemaProperties)(i.properties), m = (0, o.allSchemaProperties)(i.patternProperties);
          function h(e3) {
            t2.code(s._`delete ${c}[${e3}]`);
          }
          function y(o2) {
            if ("all" === f.removeAdditional || f.removeAdditional && false === r2)
              h(o2);
            else {
              if (false === r2)
                return e2.setParams({ additionalProperty: o2 }), e2.error(), void (u || t2.break());
              if ("object" == typeof r2 && !(0, n.alwaysValidSchema)(d, r2)) {
                const r3 = t2.name("valid");
                "failing" === f.removeAdditional ? (v(o2, r3, false), t2.if((0, s.not)(r3), () => {
                  e2.reset(), h(o2);
                })) : (v(o2, r3), u || t2.if((0, s.not)(r3), () => t2.break()));
              }
            }
          }
          function v(t3, r3, o2) {
            const s2 = { keyword: "additionalProperties", dataProp: t3, dataPropType: n.Type.Str };
            false === o2 && Object.assign(s2, { compositeRule: true, createErrors: false, allErrors: false }), e2.subschema(s2, r3);
          }
          t2.forIn("key", c, (r3) => {
            p.length || m.length ? t2.if(function(r4) {
              let a2;
              if (p.length > 8) {
                const e3 = (0, n.schemaRefOrVal)(d, i.properties, "properties");
                a2 = (0, o.isOwnProperty)(t2, e3, r4);
              } else
                a2 = p.length ? (0, s.or)(...p.map((e3) => s._`${r4} === ${e3}`)) : s.nil;
              return m.length && (a2 = (0, s.or)(a2, ...m.map((t3) => s._`${(0, o.usePattern)(e2, t3)}.test(${r4})`))), (0, s.not)(a2);
            }(r3), () => y(r3)) : y(r3);
          }), e2.ok(s._`${l} === ${a.default.errors}`);
        } };
      }, { "../../compile/codegen": 2, "../../compile/names": 6, "../../compile/util": 10, "../code": 42 }], 27: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/util");
        r.default = { keyword: "allOf", schemaType: "array", code(e2) {
          const { gen: t2, schema: r2, it: s } = e2;
          if (!Array.isArray(r2))
            throw new Error("ajv implementation error");
          const a = t2.name("valid");
          r2.forEach((t3, r3) => {
            if ((0, o.alwaysValidSchema)(s, t3))
              return;
            const n = e2.subschema({ keyword: "allOf", schemaProp: r3 }, a);
            e2.ok(a), e2.mergeEvaluated(n);
          });
        } };
      }, { "../../compile/util": 10 }], 28: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../code");
        r.default = { keyword: "anyOf", schemaType: "array", trackErrors: true, code: o.validateUnion, error: { message: "must match a schema in anyOf" } };
      }, { "../code": 42 }], 29: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util");
        r.default = { keyword: "contains", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", trackErrors: true, error: { message({ params: { min: e2, max: t2 } }) {
          return void 0 === t2 ? o.str`must contain at least ${e2} valid item(s)` : o.str`must contain at least ${e2} and no more than ${t2} valid item(s)`;
        }, params({ params: { min: e2, max: t2 } }) {
          return void 0 === t2 ? o._`{minContains: ${e2}}` : o._`{minContains: ${e2}, maxContains: ${t2}}`;
        } }, code(e2) {
          const { gen: t2, schema: r2, parentSchema: a, data: n, it: i } = e2;
          let c, l;
          const { minContains: d, maxContains: u } = a;
          i.opts.next ? (c = void 0 === d ? 1 : d, l = u) : c = 1;
          const f = t2.const("len", o._`${n}.length`);
          if (e2.setParams({ min: c, max: l }), void 0 === l && 0 === c)
            return void (0, s.checkStrictMode)(i, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          if (void 0 !== l && c > l)
            return (0, s.checkStrictMode)(i, '"minContains" > "maxContains" is always invalid'), void e2.fail();
          if ((0, s.alwaysValidSchema)(i, r2)) {
            let t3 = o._`${f} >= ${c}`;
            return void 0 !== l && (t3 = o._`${t3} && ${f} <= ${l}`), void e2.pass(t3);
          }
          i.items = true;
          const p = t2.name("valid");
          function m() {
            const e3 = t2.name("_valid"), r3 = t2.let("count", 0);
            h(e3, () => t2.if(e3, () => function(e4) {
              t2.code(o._`${e4}++`), void 0 === l ? t2.if(o._`${e4} >= ${c}`, () => t2.assign(p, true).break()) : (t2.if(o._`${e4} > ${l}`, () => t2.assign(p, false).break()), 1 === c ? t2.assign(p, true) : t2.if(o._`${e4} >= ${c}`, () => t2.assign(p, true)));
            }(r3)));
          }
          function h(r3, o2) {
            t2.forRange("i", 0, f, (t3) => {
              e2.subschema({ keyword: "contains", dataProp: t3, dataPropType: s.Type.Num, compositeRule: true }, r3), o2();
            });
          }
          void 0 === l && 1 === c ? h(p, () => t2.if(p, () => t2.break())) : 0 === c ? (t2.let(p, true), void 0 !== l && t2.if(o._`${n}.length > 0`, m)) : (t2.let(p, false), m()), e2.result(p, () => e2.reset());
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10 }], 30: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.validateSchemaDeps = r.validatePropertyDeps = r.error = void 0;
        const o = e("../../compile/codegen"), s = e("../../compile/util"), a = e("../code");
        r.error = { message({ params: { property: e2, depsCount: t2, deps: r2 } }) {
          return o.str`must have ${1 === t2 ? "property" : "properties"} ${r2} when property ${e2} is present`;
        }, params({ params: { property: e2, depsCount: t2, deps: r2, missingProperty: s2 } }) {
          return o._`{property: ${e2},
    missingProperty: ${s2},
    depsCount: ${t2},
    deps: ${r2}}`;
        } };
        const n = { keyword: "dependencies", type: "object", schemaType: "object", error: r.error, code(e2) {
          const [t2, r2] = function({ schema: e3 }) {
            const t3 = {}, r3 = {};
            for (const o2 in e3) {
              if ("__proto__" === o2)
                continue;
              (Array.isArray(e3[o2]) ? t3 : r3)[o2] = e3[o2];
            }
            return [t3, r3];
          }(e2);
          i(e2, t2), c(e2, r2);
        } };
        function i(e2, t2 = e2.schema) {
          const { gen: r2, data: s2, it: n2 } = e2;
          if (0 === Object.keys(t2).length)
            return;
          const i2 = r2.let("missing");
          for (const c2 in t2) {
            const l = t2[c2];
            if (0 === l.length)
              continue;
            const d = (0, a.propertyInData)(r2, s2, c2, n2.opts.ownProperties);
            e2.setParams({ property: c2, depsCount: l.length, deps: l.join(", ") }), n2.allErrors ? r2.if(d, () => {
              for (const t3 of l)
                (0, a.checkReportMissingProp)(e2, t3);
            }) : (r2.if(o._`${d} && (${(0, a.checkMissingProp)(e2, l, i2)})`), (0, a.reportMissingProp)(e2, i2), r2.else());
          }
        }
        function c(e2, t2 = e2.schema) {
          const { gen: r2, data: o2, keyword: n2, it: i2 } = e2, c2 = r2.name("valid");
          for (const l in t2)
            (0, s.alwaysValidSchema)(i2, t2[l]) || (r2.if((0, a.propertyInData)(r2, o2, l, i2.opts.ownProperties), () => {
              const t3 = e2.subschema({ keyword: n2, schemaProp: l }, c2);
              e2.mergeValidEvaluated(t3, c2);
            }, () => r2.var(c2, true)), e2.ok(c2));
        }
        r.validatePropertyDeps = i, r.validateSchemaDeps = c, r.default = n;
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../code": 42 }], 31: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util");
        function a(e2, t2) {
          const r2 = e2.schema[t2];
          return void 0 !== r2 && !(0, s.alwaysValidSchema)(e2, r2);
        }
        r.default = { keyword: "if", schemaType: ["object", "boolean"], trackErrors: true, error: { message({ params: e2 }) {
          return o.str`must match "${e2.ifClause}" schema`;
        }, params({ params: e2 }) {
          return o._`{failingKeyword: ${e2.ifClause}}`;
        } }, code(e2) {
          const { gen: t2, parentSchema: r2, it: n } = e2;
          void 0 === r2.then && void 0 === r2.else && (0, s.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
          const i = a(n, "then"), c = a(n, "else");
          if (!i && !c)
            return;
          const l = t2.let("valid", true), d = t2.name("_valid");
          if (function() {
            const t3 = e2.subschema({ keyword: "if", compositeRule: true, createErrors: false, allErrors: false }, d);
            e2.mergeEvaluated(t3);
          }(), e2.reset(), i && c) {
            const r3 = t2.let("ifClause");
            e2.setParams({ ifClause: r3 }), t2.if(d, u("then", r3), u("else", r3));
          } else
            i ? t2.if(d, u("then")) : t2.if((0, o.not)(d), u("else"));
          function u(r3, s2) {
            return () => {
              const a2 = e2.subschema({ keyword: r3 }, d);
              t2.assign(l, d), e2.mergeValidEvaluated(a2, l), s2 ? t2.assign(s2, o._`${r3}`) : e2.setParams({ ifClause: r3 });
            };
          }
          e2.pass(l, () => e2.error(true));
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10 }], 32: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./additionalItems"), s = e("./prefixItems"), a = e("./items"), n = e("./items2020"), i = e("./contains"), c = e("./dependencies"), l = e("./propertyNames"), d = e("./additionalProperties"), u = e("./properties"), f = e("./patternProperties"), p = e("./not"), m = e("./anyOf"), h = e("./oneOf"), y = e("./allOf"), v = e("./if"), g = e("./thenElse");
        r.default = function(e2 = false) {
          const t2 = [p.default, m.default, h.default, y.default, v.default, g.default, l.default, d.default, c.default, u.default, f.default];
          return e2 ? t2.push(s.default, n.default) : t2.push(o.default, a.default), t2.push(i.default), t2;
        };
      }, { "./additionalItems": 25, "./additionalProperties": 26, "./allOf": 27, "./anyOf": 28, "./contains": 29, "./dependencies": 30, "./if": 31, "./items": 33, "./items2020": 34, "./not": 35, "./oneOf": 36, "./patternProperties": 37, "./prefixItems": 38, "./properties": 39, "./propertyNames": 40, "./thenElse": 41 }], 33: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.validateTuple = void 0;
        const o = e("../../compile/codegen"), s = e("../../compile/util"), a = e("../code"), n = { keyword: "items", type: "array", schemaType: ["object", "array", "boolean"], before: "uniqueItems", code(e2) {
          const { schema: t2, it: r2 } = e2;
          if (Array.isArray(t2))
            return i(e2, "additionalItems", t2);
          r2.items = true, (0, s.alwaysValidSchema)(r2, t2) || e2.ok((0, a.validateArray)(e2));
        } };
        function i(e2, t2, r2 = e2.schema) {
          const { gen: a2, parentSchema: n2, data: i2, keyword: c, it: l } = e2;
          !function(e3) {
            const { opts: o2, errSchemaPath: a3 } = l, n3 = r2.length, i3 = n3 === e3.minItems && (n3 === e3.maxItems || false === e3[t2]);
            if (o2.strictTuples && !i3) {
              (0, s.checkStrictMode)(l, `"${c}" is ${n3}-tuple, but minItems or maxItems/${t2} are not specified or different at path "${a3}"`, o2.strictTuples);
            }
          }(n2), l.opts.unevaluated && r2.length && true !== l.items && (l.items = s.mergeEvaluated.items(a2, r2.length, l.items));
          const d = a2.name("valid"), u = a2.const("len", o._`${i2}.length`);
          r2.forEach((t3, r3) => {
            (0, s.alwaysValidSchema)(l, t3) || (a2.if(o._`${u} > ${r3}`, () => e2.subschema({ keyword: c, schemaProp: r3, dataProp: r3 }, d)), e2.ok(d));
          });
        }
        r.validateTuple = i, r.default = n;
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../code": 42 }], 34: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util"), a = e("../code"), n = e("./additionalItems");
        r.default = { keyword: "items", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", error: { message({ params: { len: e2 } }) {
          return o.str`must NOT have more than ${e2} items`;
        }, params({ params: { len: e2 } }) {
          return o._`{limit: ${e2}}`;
        } }, code(e2) {
          const { schema: t2, parentSchema: r2, it: o2 } = e2, { prefixItems: i } = r2;
          o2.items = true, (0, s.alwaysValidSchema)(o2, t2) || (i ? (0, n.validateAdditionalItems)(e2, i) : e2.ok((0, a.validateArray)(e2)));
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../code": 42, "./additionalItems": 25 }], 35: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/util");
        r.default = { keyword: "not", schemaType: ["object", "boolean"], trackErrors: true, code(e2) {
          const { gen: t2, schema: r2, it: s } = e2;
          if ((0, o.alwaysValidSchema)(s, r2))
            return void e2.fail();
          const a = t2.name("valid");
          e2.subschema({ keyword: "not", compositeRule: true, createErrors: false, allErrors: false }, a), e2.failResult(a, () => e2.reset(), () => e2.error());
        }, error: { message: "must NOT be valid" } };
      }, { "../../compile/util": 10 }], 36: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util");
        r.default = { keyword: "oneOf", schemaType: "array", trackErrors: true, error: { message: "must match exactly one schema in oneOf", params({ params: e2 }) {
          return o._`{passingSchemas: ${e2.passing}}`;
        } }, code(e2) {
          const { gen: t2, schema: r2, parentSchema: a, it: n } = e2;
          if (!Array.isArray(r2))
            throw new Error("ajv implementation error");
          if (n.opts.discriminator && a.discriminator)
            return;
          const i = r2, c = t2.let("valid", false), l = t2.let("passing", null), d = t2.name("_valid");
          e2.setParams({ passing: l }), t2.block(function() {
            i.forEach((r3, a2) => {
              let i2;
              (0, s.alwaysValidSchema)(n, r3) ? t2.var(d, true) : i2 = e2.subschema({ keyword: "oneOf", schemaProp: a2, compositeRule: true }, d), a2 > 0 && t2.if(o._`${d} && ${c}`).assign(c, false).assign(l, o._`[${l}, ${a2}]`).else(), t2.if(d, () => {
                t2.assign(c, true), t2.assign(l, a2), i2 && e2.mergeEvaluated(i2, o.Name);
              });
            });
          }), e2.result(c, () => e2.reset(), () => e2.error(true));
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10 }], 37: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../code"), s = e("../../compile/codegen"), a = e("../../compile/util"), n = e("../../compile/util");
        r.default = { keyword: "patternProperties", type: "object", schemaType: "object", code(e2) {
          const { gen: t2, schema: r2, data: i, parentSchema: c, it: l } = e2, { opts: d } = l, u = (0, o.allSchemaProperties)(r2), f = u.filter((e3) => (0, a.alwaysValidSchema)(l, r2[e3]));
          if (0 === u.length || f.length === u.length && (!l.opts.unevaluated || true === l.props))
            return;
          const p = d.strictSchema && !d.allowMatchingProperties && c.properties, m = t2.name("valid");
          true === l.props || l.props instanceof s.Name || (l.props = (0, n.evaluatedPropsToName)(t2, l.props));
          const { props: h } = l;
          function y(e3) {
            for (const t3 in p)
              new RegExp(e3).test(t3) && (0, a.checkStrictMode)(l, `property ${t3} matches pattern ${e3} (use allowMatchingProperties)`);
          }
          function v(r3) {
            t2.forIn("key", i, (a2) => {
              t2.if(s._`${(0, o.usePattern)(e2, r3)}.test(${a2})`, () => {
                const o2 = f.includes(r3);
                o2 || e2.subschema({ keyword: "patternProperties", schemaProp: r3, dataProp: a2, dataPropType: n.Type.Str }, m), l.opts.unevaluated && true !== h ? t2.assign(s._`${h}[${a2}]`, true) : o2 || l.allErrors || t2.if((0, s.not)(m), () => t2.break());
              });
            });
          }
          !function() {
            for (const e3 of u)
              p && y(e3), l.allErrors ? v(e3) : (t2.var(m, true), v(e3), t2.if(m));
          }();
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../code": 42 }], 38: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./items");
        r.default = { keyword: "prefixItems", type: "array", schemaType: ["array"], before: "uniqueItems", code(e2) {
          return (0, o.validateTuple)(e2, "items");
        } };
      }, { "./items": 33 }], 39: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/validate"), s = e("../code"), a = e("../../compile/util"), n = e("./additionalProperties");
        r.default = { keyword: "properties", type: "object", schemaType: "object", code(e2) {
          const { gen: t2, schema: r2, parentSchema: i, data: c, it: l } = e2;
          "all" === l.opts.removeAdditional && void 0 === i.additionalProperties && n.default.code(new o.KeywordCxt(l, n.default, "additionalProperties"));
          const d = (0, s.allSchemaProperties)(r2);
          for (const e3 of d)
            l.definedProperties.add(e3);
          l.opts.unevaluated && d.length && true !== l.props && (l.props = a.mergeEvaluated.props(t2, (0, a.toHash)(d), l.props));
          const u = d.filter((e3) => !(0, a.alwaysValidSchema)(l, r2[e3]));
          if (0 === u.length)
            return;
          const f = t2.name("valid");
          for (const r3 of u)
            p(r3) ? m(r3) : (t2.if((0, s.propertyInData)(t2, c, r3, l.opts.ownProperties)), m(r3), l.allErrors || t2.else().var(f, true), t2.endIf()), e2.it.definedProperties.add(r3), e2.ok(f);
          function p(e3) {
            return l.opts.useDefaults && !l.compositeRule && void 0 !== r2[e3].default;
          }
          function m(t3) {
            e2.subschema({ keyword: "properties", schemaProp: t3, dataProp: t3 }, f);
          }
        } };
      }, { "../../compile/util": 10, "../../compile/validate": 15, "../code": 42, "./additionalProperties": 26 }], 40: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util");
        r.default = { keyword: "propertyNames", type: "object", schemaType: ["object", "boolean"], error: { message: "property name must be valid", params({ params: e2 }) {
          return o._`{propertyName: ${e2.propertyName}}`;
        } }, code(e2) {
          const { gen: t2, schema: r2, data: a, it: n } = e2;
          if ((0, s.alwaysValidSchema)(n, r2))
            return;
          const i = t2.name("valid");
          t2.forIn("key", a, (r3) => {
            e2.setParams({ propertyName: r3 }), e2.subschema({ keyword: "propertyNames", data: r3, dataTypes: ["string"], propertyName: r3, compositeRule: true }, i), t2.if((0, o.not)(i), () => {
              e2.error(true), n.allErrors || t2.break();
            });
          }), e2.ok(i);
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10 }], 41: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/util");
        r.default = { keyword: ["then", "else"], schemaType: ["object", "boolean"], code({ keyword: e2, parentSchema: t2, it: r2 }) {
          void 0 === t2.if && (0, o.checkStrictMode)(r2, `"${e2}" without "if" is ignored`);
        } };
      }, { "../../compile/util": 10 }], 42: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.validateUnion = r.validateArray = r.usePattern = r.callValidateCode = r.schemaProperties = r.allSchemaProperties = r.noPropertyInData = r.propertyInData = r.isOwnProperty = r.hasPropFunc = r.reportMissingProp = r.checkMissingProp = r.checkReportMissingProp = void 0;
        const o = e("../compile/codegen"), s = e("../compile/util"), a = e("../compile/names"), n = e("../compile/util");
        function i(e2) {
          return e2.scopeValue("func", { ref: Object.prototype.hasOwnProperty, code: o._`Object.prototype.hasOwnProperty` });
        }
        function c(e2, t2, r2) {
          return o._`${i(e2)}.call(${t2}, ${r2})`;
        }
        function l(e2, t2, r2, s2) {
          const a2 = o._`${t2}${(0, o.getProperty)(r2)} === undefined`;
          return s2 ? (0, o.or)(a2, (0, o.not)(c(e2, t2, r2))) : a2;
        }
        function d(e2) {
          return e2 ? Object.keys(e2).filter((e3) => "__proto__" !== e3) : [];
        }
        r.checkReportMissingProp = function(e2, t2) {
          const { gen: r2, data: s2, it: a2 } = e2;
          r2.if(l(r2, s2, t2, a2.opts.ownProperties), () => {
            e2.setParams({ missingProperty: o._`${t2}` }, true), e2.error();
          });
        }, r.checkMissingProp = function({ gen: e2, data: t2, it: { opts: r2 } }, s2, a2) {
          return (0, o.or)(...s2.map((s3) => (0, o.and)(l(e2, t2, s3, r2.ownProperties), o._`${a2} = ${s3}`)));
        }, r.reportMissingProp = function(e2, t2) {
          e2.setParams({ missingProperty: t2 }, true), e2.error();
        }, r.hasPropFunc = i, r.isOwnProperty = c, r.propertyInData = function(e2, t2, r2, s2) {
          const a2 = o._`${t2}${(0, o.getProperty)(r2)} !== undefined`;
          return s2 ? o._`${a2} && ${c(e2, t2, r2)}` : a2;
        }, r.noPropertyInData = l, r.allSchemaProperties = d, r.schemaProperties = function(e2, t2) {
          return d(t2).filter((r2) => !(0, s.alwaysValidSchema)(e2, t2[r2]));
        }, r.callValidateCode = function({ schemaCode: e2, data: t2, it: { gen: r2, topSchemaRef: s2, schemaPath: n2, errorPath: i2 }, it: c2 }, l2, d2, u2) {
          const f = u2 ? o._`${e2}, ${t2}, ${s2}${n2}` : t2, p = [[a.default.instancePath, (0, o.strConcat)(a.default.instancePath, i2)], [a.default.parentData, c2.parentData], [a.default.parentDataProperty, c2.parentDataProperty], [a.default.rootData, a.default.rootData]];
          c2.opts.dynamicRef && p.push([a.default.dynamicAnchors, a.default.dynamicAnchors]);
          const m = o._`${f}, ${r2.object(...p)}`;
          return d2 !== o.nil ? o._`${l2}.call(${d2}, ${m})` : o._`${l2}(${m})`;
        };
        const u = o._`new RegExp`;
        r.usePattern = function({ gen: e2, it: { opts: t2 } }, r2) {
          const s2 = t2.unicodeRegExp ? "u" : "", { regExp: a2 } = t2.code, i2 = a2(r2, s2);
          return e2.scopeValue("pattern", { key: i2.toString(), ref: i2, code: o._`${"new RegExp" === a2.code ? u : (0, n.useFunc)(e2, a2)}(${r2}, ${s2})` });
        }, r.validateArray = function(e2) {
          const { gen: t2, data: r2, keyword: a2, it: n2 } = e2, i2 = t2.name("valid");
          if (n2.allErrors) {
            const e3 = t2.let("valid", true);
            return c2(() => t2.assign(e3, false)), e3;
          }
          return t2.var(i2, true), c2(() => t2.break()), i2;
          function c2(n3) {
            const c3 = t2.const("len", o._`${r2}.length`);
            t2.forRange("i", 0, c3, (r3) => {
              e2.subschema({ keyword: a2, dataProp: r3, dataPropType: s.Type.Num }, i2), t2.if((0, o.not)(i2), n3);
            });
          }
        }, r.validateUnion = function(e2) {
          const { gen: t2, schema: r2, keyword: a2, it: n2 } = e2;
          if (!Array.isArray(r2))
            throw new Error("ajv implementation error");
          if (r2.some((e3) => (0, s.alwaysValidSchema)(n2, e3)) && !n2.opts.unevaluated)
            return;
          const i2 = t2.let("valid", false), c2 = t2.name("_valid");
          t2.block(() => r2.forEach((r3, s2) => {
            const n3 = e2.subschema({ keyword: a2, schemaProp: s2, compositeRule: true }, c2);
            t2.assign(i2, o._`${i2} || ${c2}`);
            e2.mergeValidEvaluated(n3, c2) || t2.if((0, o.not)(i2));
          })), e2.result(i2, () => e2.reset(), () => e2.error(true));
        };
      }, { "../compile/codegen": 2, "../compile/names": 6, "../compile/util": 10 }], 43: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        r.default = { keyword: "id", code() {
          throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
        } };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./id"), s = e("./ref");
        r.default = ["$schema", "$id", "$defs", "$vocabulary", { keyword: "$comment" }, "definitions", o.default, s.default];
      }, { "./id": 43, "./ref": 45 }], 45: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.callRef = r.getValidate = void 0;
        const o = e("../../compile/ref_error"), s = e("../code"), a = e("../../compile/codegen"), n = e("../../compile/names"), i = e("../../compile"), c = e("../../compile/util"), l = { keyword: "$ref", schemaType: "string", code(e2) {
          const { gen: t2, schema: r2, it: s2 } = e2, { baseId: n2, schemaEnv: c2, validateName: l2, opts: f, self: p } = s2, { root: m } = c2;
          if (("#" === r2 || "#/" === r2) && n2 === m.baseId)
            return function() {
              if (c2 === m)
                return u(e2, l2, c2, c2.$async);
              const r3 = t2.scopeValue("root", { ref: m });
              return u(e2, a._`${r3}.validate`, m, m.$async);
            }();
          const h = i.resolveRef.call(p, m, n2, r2);
          if (void 0 === h)
            throw new o.default(s2.opts.uriResolver, n2, r2);
          return h instanceof i.SchemaEnv ? function(t3) {
            const r3 = d(e2, t3);
            u(e2, r3, t3, t3.$async);
          }(h) : function(o2) {
            const s3 = t2.scopeValue("schema", true === f.code.source ? { ref: o2, code: (0, a.stringify)(o2) } : { ref: o2 }), n3 = t2.name("valid"), i2 = e2.subschema({ schema: o2, dataTypes: [], schemaPath: a.nil, topSchemaRef: s3, errSchemaPath: r2 }, n3);
            e2.mergeEvaluated(i2), e2.ok(n3);
          }(h);
        } };
        function d(e2, t2) {
          const { gen: r2 } = e2;
          return t2.validate ? r2.scopeValue("validate", { ref: t2.validate }) : a._`${r2.scopeValue("wrapper", { ref: t2 })}.validate`;
        }
        function u(e2, t2, r2, o2) {
          const { gen: i2, it: l2 } = e2, { allErrors: d2, schemaEnv: u2, opts: f } = l2, p = f.passContext ? n.default.this : a.nil;
          function m(e3) {
            const t3 = a._`${e3}.errors`;
            i2.assign(n.default.vErrors, a._`${n.default.vErrors} === null ? ${t3} : ${n.default.vErrors}.concat(${t3})`), i2.assign(n.default.errors, a._`${n.default.vErrors}.length`);
          }
          function h(e3) {
            var t3;
            if (!l2.opts.unevaluated)
              return;
            const o3 = null === (t3 = null == r2 ? void 0 : r2.validate) || void 0 === t3 ? void 0 : t3.evaluated;
            if (true !== l2.props)
              if (o3 && !o3.dynamicProps)
                void 0 !== o3.props && (l2.props = c.mergeEvaluated.props(i2, o3.props, l2.props));
              else {
                const t4 = i2.var("props", a._`${e3}.evaluated.props`);
                l2.props = c.mergeEvaluated.props(i2, t4, l2.props, a.Name);
              }
            if (true !== l2.items)
              if (o3 && !o3.dynamicItems)
                void 0 !== o3.items && (l2.items = c.mergeEvaluated.items(i2, o3.items, l2.items));
              else {
                const t4 = i2.var("items", a._`${e3}.evaluated.items`);
                l2.items = c.mergeEvaluated.items(i2, t4, l2.items, a.Name);
              }
          }
          o2 ? function() {
            if (!u2.$async)
              throw new Error("async schema referenced by sync schema");
            const r3 = i2.let("valid");
            i2.try(() => {
              i2.code(a._`await ${(0, s.callValidateCode)(e2, t2, p)}`), h(t2), d2 || i2.assign(r3, true);
            }, (e3) => {
              i2.if(a._`!(${e3} instanceof ${l2.ValidationError})`, () => i2.throw(e3)), m(e3), d2 || i2.assign(r3, false);
            }), e2.ok(r3);
          }() : e2.result((0, s.callValidateCode)(e2, t2, p), () => h(t2), () => m(t2));
        }
        r.getValidate = d, r.callRef = u, r.default = l;
      }, { "../../compile": 5, "../../compile/codegen": 2, "../../compile/names": 6, "../../compile/ref_error": 7, "../../compile/util": 10, "../code": 42 }], 46: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../discriminator/types"), a = e("../../compile"), n = e("../../compile/util");
        r.default = { keyword: "discriminator", type: "object", schemaType: "object", error: { message({ params: { discrError: e2, tagName: t2 } }) {
          return e2 === s.DiscrError.Tag ? `tag "${t2}" must be string` : `value of tag "${t2}" must be in oneOf`;
        }, params({ params: { discrError: e2, tag: t2, tagName: r2 } }) {
          return o._`{error: ${e2}, tag: ${r2}, tagValue: ${t2}}`;
        } }, code(e2) {
          const { gen: t2, data: r2, schema: i, parentSchema: c, it: l } = e2, { oneOf: d } = c;
          if (!l.opts.discriminator)
            throw new Error("discriminator: requires discriminator option");
          const u = i.propertyName;
          if ("string" != typeof u)
            throw new Error("discriminator: requires propertyName");
          if (i.mapping)
            throw new Error("discriminator: mapping is not supported");
          if (!d)
            throw new Error("discriminator: requires oneOf keyword");
          const f = t2.let("valid", false), p = t2.const("tag", o._`${r2}${(0, o.getProperty)(u)}`);
          function m(r3) {
            const s2 = t2.name("valid"), a2 = e2.subschema({ keyword: "oneOf", schemaProp: r3 }, s2);
            return e2.mergeEvaluated(a2, o.Name), s2;
          }
          t2.if(o._`typeof ${p} == "string"`, () => function() {
            const r3 = function() {
              var e3;
              const t3 = {}, r4 = s2(c);
              let o2 = true;
              for (let t4 = 0; t4 < d.length; t4++) {
                let c2 = d[t4];
                (null == c2 ? void 0 : c2.$ref) && !(0, n.schemaHasRulesButRef)(c2, l.self.RULES) && (c2 = a.resolveRef.call(l.self, l.schemaEnv.root, l.baseId, null == c2 ? void 0 : c2.$ref), c2 instanceof a.SchemaEnv && (c2 = c2.schema));
                const f3 = null === (e3 = null == c2 ? void 0 : c2.properties) || void 0 === e3 ? void 0 : e3[u];
                if ("object" != typeof f3)
                  throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${u}"`);
                o2 = o2 && (r4 || s2(c2)), i2(f3, t4);
              }
              if (!o2)
                throw new Error(`discriminator: "${u}" must be required`);
              return t3;
              function s2({ required: e4 }) {
                return Array.isArray(e4) && e4.includes(u);
              }
              function i2(e4, t4) {
                if (e4.const)
                  f2(e4.const, t4);
                else {
                  if (!e4.enum)
                    throw new Error(`discriminator: "properties/${u}" must have "const" or "enum"`);
                  for (const r5 of e4.enum)
                    f2(r5, t4);
                }
              }
              function f2(e4, r5) {
                if ("string" != typeof e4 || e4 in t3)
                  throw new Error(`discriminator: "${u}" values must be unique strings`);
                t3[e4] = r5;
              }
            }();
            t2.if(false);
            for (const e3 in r3)
              t2.elseIf(o._`${p} === ${e3}`), t2.assign(f, m(r3[e3]));
            t2.else(), e2.error(false, { discrError: s.DiscrError.Mapping, tag: p, tagName: u }), t2.endIf();
          }(), () => e2.error(false, { discrError: s.DiscrError.Tag, tag: p, tagName: u })), e2.ok(f);
        } };
      }, { "../../compile": 5, "../../compile/codegen": 2, "../../compile/util": 10, "../discriminator/types": 47 }], 47: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.DiscrError = void 0, function(e2) {
          e2.Tag = "tag", e2.Mapping = "mapping";
        }(r.DiscrError || (r.DiscrError = {}));
      }, {}], 48: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./core"), s = e("./validation"), a = e("./applicator"), n = e("./format"), i = e("./metadata"), c = [o.default, s.default, (0, a.default)(), n.default, i.metadataVocabulary, i.contentVocabulary];
        r.default = c;
      }, { "./applicator": 32, "./core": 44, "./format": 50, "./metadata": 51, "./validation": 54 }], 49: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen");
        r.default = { keyword: "format", type: ["number", "string"], schemaType: "string", $data: true, error: { message({ schemaCode: e2 }) {
          return o.str`must match format "${e2}"`;
        }, params({ schemaCode: e2 }) {
          return o._`{format: ${e2}}`;
        } }, code(e2, t2) {
          const { gen: r2, data: s, $data: a, schema: n, schemaCode: i, it: c } = e2, { opts: l, errSchemaPath: d, schemaEnv: u, self: f } = c;
          l.validateFormats && (a ? function() {
            const a2 = r2.scopeValue("formats", { ref: f.formats, code: l.code.formats }), n2 = r2.const("fDef", o._`${a2}[${i}]`), c2 = r2.let("fType"), d2 = r2.let("format");
            r2.if(o._`typeof ${n2} == "object" && !(${n2} instanceof RegExp)`, () => r2.assign(c2, o._`${n2}.type || "string"`).assign(d2, o._`${n2}.validate`), () => r2.assign(c2, o._`"string"`).assign(d2, n2)), e2.fail$data((0, o.or)(false === l.strictSchema ? o.nil : o._`${i} && !${d2}`, function() {
              const e3 = u.$async ? o._`(${n2}.async ? await ${d2}(${s}) : ${d2}(${s}))` : o._`${d2}(${s})`, r3 = o._`(typeof ${d2} == "function" ? ${e3} : ${d2}.test(${s}))`;
              return o._`${d2} && ${d2} !== true && ${c2} === ${t2} && !${r3}`;
            }()));
          }() : function() {
            const a2 = f.formats[n];
            if (!a2)
              return void function() {
                if (false === l.strictSchema)
                  return void f.logger.warn(e3());
                throw new Error(e3());
                function e3() {
                  return `unknown format "${n}" ignored in schema at path "${d}"`;
                }
              }();
            if (true === a2)
              return;
            const [i2, c2, p] = function(e3) {
              const t3 = e3 instanceof RegExp ? (0, o.regexpCode)(e3) : l.code.formats ? o._`${l.code.formats}${(0, o.getProperty)(n)}` : void 0, s2 = r2.scopeValue("formats", { key: n, ref: e3, code: t3 });
              if ("object" == typeof e3 && !(e3 instanceof RegExp))
                return [e3.type || "string", e3.validate, o._`${s2}.validate`];
              return ["string", e3, s2];
            }(a2);
            i2 === t2 && e2.pass(function() {
              if ("object" == typeof a2 && !(a2 instanceof RegExp) && a2.async) {
                if (!u.$async)
                  throw new Error("async format in sync schema");
                return o._`await ${p}(${s})`;
              }
              return "function" == typeof c2 ? o._`${p}(${s})` : o._`${p}.test(${s})`;
            }());
          }());
        } };
      }, { "../../compile/codegen": 2 }], 50: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./format");
        r.default = [o.default];
      }, { "./format": 49 }], 51: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.contentVocabulary = r.metadataVocabulary = void 0, r.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"], r.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
      }, {}], 52: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util"), a = e("../../runtime/equal");
        r.default = { keyword: "const", $data: true, error: { message: "must be equal to constant", params({ schemaCode: e2 }) {
          return o._`{allowedValue: ${e2}}`;
        } }, code(e2) {
          const { gen: t2, data: r2, $data: n, schemaCode: i, schema: c } = e2;
          n || c && "object" == typeof c ? e2.fail$data(o._`!${(0, s.useFunc)(t2, a.default)}(${r2}, ${i})`) : e2.fail(o._`${c} !== ${r2}`);
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../../runtime/equal": 21 }], 53: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util"), a = e("../../runtime/equal");
        r.default = { keyword: "enum", schemaType: "array", $data: true, error: { message: "must be equal to one of the allowed values", params({ schemaCode: e2 }) {
          return o._`{allowedValues: ${e2}}`;
        } }, code(e2) {
          const { gen: t2, data: r2, $data: n, schema: i, schemaCode: c, it: l } = e2;
          if (!n && 0 === i.length)
            throw new Error("enum must have non-empty array");
          let d;
          const u = () => null != d ? d : d = (0, s.useFunc)(t2, a.default);
          let f;
          if (i.length >= l.opts.loopEnum || n)
            f = t2.let("valid"), e2.block$data(f, function() {
              t2.assign(f, false), t2.forOf("v", c, (e3) => t2.if(o._`${u()}(${r2}, ${e3})`, () => t2.assign(f, true).break()));
            });
          else {
            if (!Array.isArray(i))
              throw new Error("ajv implementation error");
            const e3 = t2.const("vSchema", c);
            f = (0, o.or)(...i.map((t3, s2) => function(e4, t4) {
              const s3 = i[t4];
              return "object" == typeof s3 && null !== s3 ? o._`${u()}(${r2}, ${e4}[${t4}])` : o._`${r2} === ${s3}`;
            }(e3, s2)));
          }
          e2.pass(f);
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../../runtime/equal": 21 }], 54: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("./limitNumber"), s = e("./multipleOf"), a = e("./limitLength"), n = e("./pattern"), i = e("./limitProperties"), c = e("./required"), l = e("./limitItems"), d = e("./uniqueItems"), u = e("./const"), f = e("./enum");
        r.default = [o.default, s.default, a.default, n.default, i.default, c.default, l.default, d.default, { keyword: "type", schemaType: ["string", "array"] }, { keyword: "nullable", schemaType: "boolean" }, u.default, f.default];
      }, { "./const": 52, "./enum": 53, "./limitItems": 55, "./limitLength": 56, "./limitNumber": 57, "./limitProperties": 58, "./multipleOf": 59, "./pattern": 60, "./required": 61, "./uniqueItems": 62 }], 55: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen");
        r.default = { keyword: ["maxItems", "minItems"], type: "array", schemaType: "number", $data: true, error: { message: ({ keyword: e2, schemaCode: t2 }) => o.str`must NOT have ${"maxItems" === e2 ? "more" : "fewer"} than ${t2} items`, params({ schemaCode: e2 }) {
          return o._`{limit: ${e2}}`;
        } }, code(e2) {
          const { keyword: t2, data: r2, schemaCode: s } = e2;
          e2.fail$data(o._`${r2}.length ${"maxItems" === t2 ? o.operators.GT : o.operators.LT} ${s}`);
        } };
      }, { "../../compile/codegen": 2 }], 56: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = e("../../compile/util"), a = e("../../runtime/ucs2length");
        r.default = { keyword: ["maxLength", "minLength"], type: "string", schemaType: "number", $data: true, error: { message: ({ keyword: e2, schemaCode: t2 }) => o.str`must NOT have ${"maxLength" === e2 ? "more" : "fewer"} than ${t2} characters`, params({ schemaCode: e2 }) {
          return o._`{limit: ${e2}}`;
        } }, code(e2) {
          const { keyword: t2, data: r2, schemaCode: n, it: i } = e2, c = "maxLength" === t2 ? o.operators.GT : o.operators.LT, l = false === i.opts.unicode ? o._`${r2}.length` : o._`${(0, s.useFunc)(e2.gen, a.default)}(${r2})`;
          e2.fail$data(o._`${l} ${c} ${n}`);
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../../runtime/ucs2length": 22 }], 57: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen"), s = o.operators, a = { maximum: { okStr: "<=", ok: s.LTE, fail: s.GT }, minimum: { okStr: ">=", ok: s.GTE, fail: s.LT }, exclusiveMaximum: { okStr: "<", ok: s.LT, fail: s.GTE }, exclusiveMinimum: { okStr: ">", ok: s.GT, fail: s.LTE } }, n = { message({ keyword: e2, schemaCode: t2 }) {
          return o.str`must be ${a[e2].okStr} ${t2}`;
        }, params({ keyword: e2, schemaCode: t2 }) {
          return o._`{comparison: ${a[e2].okStr}, limit: ${t2}}`;
        } }, i = { keyword: Object.keys(a), type: "number", schemaType: "number", $data: true, error: n, code(e2) {
          const { keyword: t2, data: r2, schemaCode: s2 } = e2;
          e2.fail$data(o._`${r2} ${a[t2].fail} ${s2} || isNaN(${r2})`);
        } };
        r.default = i;
      }, { "../../compile/codegen": 2 }], 58: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen");
        r.default = { keyword: ["maxProperties", "minProperties"], type: "object", schemaType: "number", $data: true, error: { message: ({ keyword: e2, schemaCode: t2 }) => o.str`must NOT have ${"maxProperties" === e2 ? "more" : "fewer"} than ${t2} properties`, params({ schemaCode: e2 }) {
          return o._`{limit: ${e2}}`;
        } }, code(e2) {
          const { keyword: t2, data: r2, schemaCode: s } = e2;
          e2.fail$data(o._`Object.keys(${r2}).length ${"maxProperties" === t2 ? o.operators.GT : o.operators.LT} ${s}`);
        } };
      }, { "../../compile/codegen": 2 }], 59: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/codegen");
        r.default = { keyword: "multipleOf", type: "number", schemaType: "number", $data: true, error: { message({ schemaCode: e2 }) {
          return o.str`must be multiple of ${e2}`;
        }, params({ schemaCode: e2 }) {
          return o._`{multipleOf: ${e2}}`;
        } }, code(e2) {
          const { gen: t2, data: r2, schemaCode: s, it: a } = e2, n = a.opts.multipleOfPrecision, i = t2.let("res"), c = n ? o._`Math.abs(Math.round(${i}) - ${i}) > 1e-${n}` : o._`${i} !== parseInt(${i})`;
          e2.fail$data(o._`(${s} === 0 || (${i} = ${r2}/${s}, ${c}))`);
        } };
      }, { "../../compile/codegen": 2 }], 60: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../code"), s = e("../../compile/codegen");
        r.default = { keyword: "pattern", type: "string", schemaType: "string", $data: true, error: { message({ schemaCode: e2 }) {
          return s.str`must match pattern "${e2}"`;
        }, params({ schemaCode: e2 }) {
          return s._`{pattern: ${e2}}`;
        } }, code(e2) {
          const { data: t2, $data: r2, schema: a, schemaCode: n, it: i } = e2, c = r2 ? s._`(new RegExp(${n}, ${i.opts.unicodeRegExp ? "u" : ""}))` : (0, o.usePattern)(e2, a);
          e2.fail$data(s._`!${c}.test(${t2})`);
        } };
      }, { "../../compile/codegen": 2, "../code": 42 }], 61: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../code"), s = e("../../compile/codegen"), a = e("../../compile/util");
        r.default = { keyword: "required", type: "object", schemaType: "array", $data: true, error: { message({ params: { missingProperty: e2 } }) {
          return s.str`must have required property '${e2}'`;
        }, params({ params: { missingProperty: e2 } }) {
          return s._`{missingProperty: ${e2}}`;
        } }, code(e2) {
          const { gen: t2, schema: r2, schemaCode: n, data: i, $data: c, it: l } = e2, { opts: d } = l;
          if (!c && 0 === r2.length)
            return;
          const u = r2.length >= d.loopRequired;
          if (l.allErrors ? function() {
            if (u || c)
              e2.block$data(s.nil, f);
            else
              for (const t3 of r2)
                (0, o.checkReportMissingProp)(e2, t3);
          }() : function() {
            const a2 = t2.let("missing");
            if (u || c) {
              const r3 = t2.let("valid", true);
              e2.block$data(r3, () => function(r4, a3) {
                e2.setParams({ missingProperty: r4 }), t2.forOf(r4, n, () => {
                  t2.assign(a3, (0, o.propertyInData)(t2, i, r4, d.ownProperties)), t2.if((0, s.not)(a3), () => {
                    e2.error(), t2.break();
                  });
                }, s.nil);
              }(a2, r3)), e2.ok(r3);
            } else
              t2.if((0, o.checkMissingProp)(e2, r2, a2)), (0, o.reportMissingProp)(e2, a2), t2.else();
          }(), d.strictRequired) {
            const t3 = e2.parentSchema.properties, { definedProperties: o2 } = e2.it;
            for (const e3 of r2)
              if (void 0 === (null == t3 ? void 0 : t3[e3]) && !o2.has(e3)) {
                (0, a.checkStrictMode)(l, `required property "${e3}" is not defined at "${l.schemaEnv.baseId + l.errSchemaPath}" (strictRequired)`, l.opts.strictRequired);
              }
          }
          function f() {
            t2.forOf("prop", n, (r3) => {
              e2.setParams({ missingProperty: r3 }), t2.if((0, o.noPropertyInData)(t2, i, r3, d.ownProperties), () => e2.error());
            });
          }
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../code": 42 }], 62: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const o = e("../../compile/validate/dataType"), s = e("../../compile/codegen"), a = e("../../compile/util"), n = e("../../runtime/equal");
        r.default = { keyword: "uniqueItems", type: "array", schemaType: "boolean", $data: true, error: { message({ params: { i: e2, j: t2 } }) {
          return s.str`must NOT have duplicate items (items ## ${t2} and ${e2} are identical)`;
        }, params({ params: { i: e2, j: t2 } }) {
          return s._`{i: ${e2}, j: ${t2}}`;
        } }, code(e2) {
          const { gen: t2, data: r2, $data: i, schema: c, parentSchema: l, schemaCode: d, it: u } = e2;
          if (!i && !c)
            return;
          const f = t2.let("valid"), p = l.items ? (0, o.getSchemaTypes)(l.items) : [];
          function m(a2, n2) {
            const i2 = t2.name("item"), c2 = (0, o.checkDataTypes)(p, i2, u.opts.strictNumbers, o.DataType.Wrong), l2 = t2.const("indices", s._`{}`);
            t2.for(s._`;${a2}--;`, () => {
              t2.let(i2, s._`${r2}[${a2}]`), t2.if(c2, s._`continue`), p.length > 1 && t2.if(s._`typeof ${i2} == "string"`, s._`${i2} += "_"`), t2.if(s._`typeof ${l2}[${i2}] == "number"`, () => {
                t2.assign(n2, s._`${l2}[${i2}]`), e2.error(), t2.assign(f, false).break();
              }).code(s._`${l2}[${i2}] = ${a2}`);
            });
          }
          function h(o2, i2) {
            const c2 = (0, a.useFunc)(t2, n.default), l2 = t2.name("outer");
            t2.label(l2).for(s._`;${o2}--;`, () => t2.for(s._`${i2} = ${o2}; ${i2}--;`, () => t2.if(s._`${c2}(${r2}[${o2}], ${r2}[${i2}])`, () => {
              e2.error(), t2.assign(f, false).break(l2);
            })));
          }
          e2.block$data(f, function() {
            const o2 = t2.let("i", s._`${r2}.length`), a2 = t2.let("j");
            e2.setParams({ i: o2, j: a2 }), t2.assign(f, true), t2.if(s._`${o2} > 1`, () => (p.length > 0 && !p.some((e3) => "object" === e3 || "array" === e3) ? m : h)(o2, a2));
          }, s._`${d} === false`), e2.ok(f);
        } };
      }, { "../../compile/codegen": 2, "../../compile/util": 10, "../../compile/validate/dataType": 13, "../../runtime/equal": 21 }], 63: [function(e, t, r) {
        "use strict";
        t.exports = function e2(t2, r2) {
          if (t2 === r2)
            return true;
          if (t2 && r2 && "object" == typeof t2 && "object" == typeof r2) {
            if (t2.constructor !== r2.constructor)
              return false;
            var o, s, a;
            if (Array.isArray(t2)) {
              if ((o = t2.length) != r2.length)
                return false;
              for (s = o; 0 != s--; )
                if (!e2(t2[s], r2[s]))
                  return false;
              return true;
            }
            if (t2.constructor === RegExp)
              return t2.source === r2.source && t2.flags === r2.flags;
            if (t2.valueOf !== Object.prototype.valueOf)
              return t2.valueOf() === r2.valueOf();
            if (t2.toString !== Object.prototype.toString)
              return t2.toString() === r2.toString();
            if ((o = (a = Object.keys(t2)).length) !== Object.keys(r2).length)
              return false;
            for (s = o; 0 != s--; )
              if (!Object.prototype.hasOwnProperty.call(r2, a[s]))
                return false;
            for (s = o; 0 != s--; ) {
              var n = a[s];
              if (!e2(t2[n], r2[n]))
                return false;
            }
            return true;
          }
          return t2 != t2 && r2 != r2;
        };
      }, {}], 64: [function(e, t, r) {
        "use strict";
        var o = t.exports = function(e2, t2, r2) {
          "function" == typeof t2 && (r2 = t2, t2 = {}), s(t2, "function" == typeof (r2 = t2.cb || r2) ? r2 : r2.pre || function() {
          }, r2.post || function() {
          }, e2, "", e2);
        };
        function s(e2, t2, r2, a, n, i, c, l, d, u) {
          if (a && "object" == typeof a && !Array.isArray(a)) {
            for (var f in t2(a, n, i, c, l, d, u), a) {
              var p = a[f];
              if (Array.isArray(p)) {
                if (f in o.arrayKeywords)
                  for (var m = 0; m < p.length; m++)
                    s(e2, t2, r2, p[m], n + "/" + f + "/" + m, i, n, f, a, m);
              } else if (f in o.propsKeywords) {
                if (p && "object" == typeof p)
                  for (var h in p)
                    s(e2, t2, r2, p[h], n + "/" + f + "/" + h.replace(/~/g, "~0").replace(/\//g, "~1"), i, n, f, a, h);
              } else
                (f in o.keywords || e2.allKeys && !(f in o.skipKeywords)) && s(e2, t2, r2, p, n + "/" + f, i, n, f, a);
            }
            r2(a, n, i, c, l, d, u);
          }
        }
        o.keywords = { additionalItems: true, items: true, contains: true, additionalProperties: true, propertyNames: true, not: true, if: true, then: true, else: true }, o.arrayKeywords = { items: true, allOf: true, anyOf: true, oneOf: true }, o.propsKeywords = { $defs: true, definitions: true, properties: true, patternProperties: true, dependencies: true }, o.skipKeywords = { default: true, enum: true, const: true, required: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
      }, {}], 65: [function(e, t, r) {
        !function(e2, o) {
          o("object" == typeof r && void 0 !== t ? r : e2.URI = e2.URI || {});
        }(this, function(e2) {
          "use strict";
          function t2() {
            for (var e3 = arguments.length, t3 = Array(e3), r3 = 0; r3 < e3; r3++)
              t3[r3] = arguments[r3];
            if (t3.length > 1) {
              t3[0] = t3[0].slice(0, -1);
              for (var o2 = t3.length - 1, s2 = 1; s2 < o2; ++s2)
                t3[s2] = t3[s2].slice(1, -1);
              return t3[o2] = t3[o2].slice(1), t3.join("");
            }
            return t3[0];
          }
          function r2(e3) {
            return "(?:" + e3 + ")";
          }
          function o(e3) {
            return void 0 === e3 ? "undefined" : null === e3 ? "null" : Object.prototype.toString.call(e3).split(" ").pop().split("]").shift().toLowerCase();
          }
          function s(e3) {
            return e3.toUpperCase();
          }
          function a(e3) {
            var o2 = "[A-Za-z]", s2 = "[0-9]", a2 = t2(s2, "[A-Fa-f]"), n2 = r2(r2("%[EFef]" + a2 + "%" + a2 + a2 + "%" + a2 + a2) + "|" + r2("%[89A-Fa-f]" + a2 + "%" + a2 + a2) + "|" + r2("%" + a2 + a2)), i2 = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", c2 = t2("[\\:\\/\\?\\#\\[\\]\\@]", i2), l2 = e3 ? "[\\uE000-\\uF8FF]" : "[]", d2 = t2(o2, s2, "[\\-\\.\\_\\~]", e3 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"), u2 = r2(o2 + t2(o2, s2, "[\\+\\-\\.]") + "*"), f2 = r2(r2(n2 + "|" + t2(d2, i2, "[\\:]")) + "*"), p2 = (r2(r2("25[0-5]") + "|" + r2("2[0-4][0-9]") + "|" + r2("1[0-9][0-9]") + "|" + r2("[1-9][0-9]") + "|" + s2), r2(r2("25[0-5]") + "|" + r2("2[0-4][0-9]") + "|" + r2("1[0-9][0-9]") + "|" + r2("0?[1-9][0-9]") + "|0?0?" + s2)), m2 = r2(p2 + "\\." + p2 + "\\." + p2 + "\\." + p2), h2 = r2(a2 + "{1,4}"), y2 = r2(r2(h2 + "\\:" + h2) + "|" + m2), v2 = r2(r2(h2 + "\\:") + "{6}" + y2), g2 = r2("\\:\\:" + r2(h2 + "\\:") + "{5}" + y2), $2 = r2(r2(h2) + "?\\:\\:" + r2(h2 + "\\:") + "{4}" + y2), _2 = r2(r2(r2(h2 + "\\:") + "{0,1}" + h2) + "?\\:\\:" + r2(h2 + "\\:") + "{3}" + y2), w2 = r2(r2(r2(h2 + "\\:") + "{0,2}" + h2) + "?\\:\\:" + r2(h2 + "\\:") + "{2}" + y2), b2 = r2(r2(r2(h2 + "\\:") + "{0,3}" + h2) + "?\\:\\:" + h2 + "\\:" + y2), E2 = r2(r2(r2(h2 + "\\:") + "{0,4}" + h2) + "?\\:\\:" + y2), P2 = r2(r2(r2(h2 + "\\:") + "{0,5}" + h2) + "?\\:\\:" + h2), S2 = r2(r2(r2(h2 + "\\:") + "{0,6}" + h2) + "?\\:\\:"), N2 = r2([v2, g2, $2, _2, w2, b2, E2, P2, S2].join("|")), k2 = r2(r2(d2 + "|" + n2) + "+"), j2 = (r2(N2 + "\\%25" + k2), r2(N2 + r2("\\%25|\\%(?!" + a2 + "{2})") + k2)), C2 = r2("[vV]" + a2 + "+\\." + t2(d2, i2, "[\\:]") + "+"), O2 = r2("\\[" + r2(j2 + "|" + N2 + "|" + C2) + "\\]"), x2 = r2(r2(n2 + "|" + t2(d2, i2)) + "*"), T2 = r2(O2 + "|" + m2 + "(?!" + x2 + ")|" + x2), I2 = r2("[0-9]*"), R2 = r2(r2(f2 + "@") + "?" + T2 + r2("\\:" + I2) + "?"), D2 = r2(n2 + "|" + t2(d2, i2, "[\\:\\@]")), A2 = r2(D2 + "*"), M2 = r2(D2 + "+"), V2 = r2(r2(n2 + "|" + t2(d2, i2, "[\\@]")) + "+"), F2 = r2(r2("\\/" + A2) + "*"), q2 = r2("\\/" + r2(M2 + F2) + "?"), U2 = r2(V2 + F2), z2 = r2(M2 + F2), K2 = "(?!" + D2 + ")", L2 = (r2(F2 + "|" + q2 + "|" + U2 + "|" + z2 + "|" + K2), r2(r2(D2 + "|" + t2("[\\/\\?]", l2)) + "*")), H2 = r2(r2(D2 + "|[\\/\\?]") + "*"), G2 = r2(r2("\\/\\/" + R2 + F2) + "|" + q2 + "|" + z2 + "|" + K2), J2 = r2(u2 + "\\:" + G2 + r2("\\?" + L2) + "?" + r2("\\#" + H2) + "?"), B2 = r2(r2("\\/\\/" + R2 + F2) + "|" + q2 + "|" + U2 + "|" + K2), W2 = r2(B2 + r2("\\?" + L2) + "?" + r2("\\#" + H2) + "?");
            r2(J2 + "|" + W2), r2(u2 + "\\:" + G2 + r2("\\?" + L2) + "?"), r2(r2("\\/\\/(" + r2("(" + f2 + ")@") + "?(" + T2 + ")" + r2("\\:(" + I2 + ")") + "?)") + "?(" + F2 + "|" + q2 + "|" + z2 + "|" + K2 + ")"), r2("\\?(" + L2 + ")"), r2("\\#(" + H2 + ")"), r2(r2("\\/\\/(" + r2("(" + f2 + ")@") + "?(" + T2 + ")" + r2("\\:(" + I2 + ")") + "?)") + "?(" + F2 + "|" + q2 + "|" + U2 + "|" + K2 + ")"), r2("\\?(" + L2 + ")"), r2("\\#(" + H2 + ")"), r2(r2("\\/\\/(" + r2("(" + f2 + ")@") + "?(" + T2 + ")" + r2("\\:(" + I2 + ")") + "?)") + "?(" + F2 + "|" + q2 + "|" + z2 + "|" + K2 + ")"), r2("\\?(" + L2 + ")"), r2("\\#(" + H2 + ")"), r2("(" + f2 + ")@"), r2("\\:(" + I2 + ")");
            return { NOT_SCHEME: new RegExp(t2("[^]", o2, s2, "[\\+\\-\\.]"), "g"), NOT_USERINFO: new RegExp(t2("[^\\%\\:]", d2, i2), "g"), NOT_HOST: new RegExp(t2("[^\\%\\[\\]\\:]", d2, i2), "g"), NOT_PATH: new RegExp(t2("[^\\%\\/\\:\\@]", d2, i2), "g"), NOT_PATH_NOSCHEME: new RegExp(t2("[^\\%\\/\\@]", d2, i2), "g"), NOT_QUERY: new RegExp(t2("[^\\%]", d2, i2, "[\\:\\@\\/\\?]", l2), "g"), NOT_FRAGMENT: new RegExp(t2("[^\\%]", d2, i2, "[\\:\\@\\/\\?]"), "g"), ESCAPE: new RegExp(t2("[^]", d2, i2), "g"), UNRESERVED: new RegExp(d2, "g"), OTHER_CHARS: new RegExp(t2("[^\\%]", d2, c2), "g"), PCT_ENCODED: new RegExp(n2, "g"), IPV4ADDRESS: new RegExp("^(" + m2 + ")$"), IPV6ADDRESS: new RegExp("^\\[?(" + N2 + ")" + r2(r2("\\%25|\\%(?!" + a2 + "{2})") + "(" + k2 + ")") + "?\\]?$") };
          }
          var n = a(false), i = a(true), c = function(e3, t3) {
            if (Array.isArray(e3))
              return e3;
            if (Symbol.iterator in Object(e3))
              return function(e4, t4) {
                var r3 = [], o2 = true, s2 = false, a2 = void 0;
                try {
                  for (var n2, i2 = e4[Symbol.iterator](); !(o2 = (n2 = i2.next()).done) && (r3.push(n2.value), !t4 || r3.length !== t4); o2 = true)
                    ;
                } catch (e5) {
                  s2 = true, a2 = e5;
                } finally {
                  try {
                    !o2 && i2.return && i2.return();
                  } finally {
                    if (s2)
                      throw a2;
                  }
                }
                return r3;
              }(e3, t3);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }, l = 2147483647, d = 36, u = /^xn--/, f = /[^\0-\x7E]/, p = /[\x2E\u3002\uFF0E\uFF61]/g, m = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, h = Math.floor, y = String.fromCharCode;
          function v(e3) {
            throw new RangeError(m[e3]);
          }
          function g(e3, t3) {
            var r3 = e3.split("@"), o2 = "";
            r3.length > 1 && (o2 = r3[0] + "@", e3 = r3[1]);
            var s2 = function(e4, t4) {
              for (var r4 = [], o3 = e4.length; o3--; )
                r4[o3] = t4(e4[o3]);
              return r4;
            }((e3 = e3.replace(p, ".")).split("."), t3).join(".");
            return o2 + s2;
          }
          function $(e3) {
            for (var t3 = [], r3 = 0, o2 = e3.length; r3 < o2; ) {
              var s2 = e3.charCodeAt(r3++);
              if (s2 >= 55296 && s2 <= 56319 && r3 < o2) {
                var a2 = e3.charCodeAt(r3++);
                56320 == (64512 & a2) ? t3.push(((1023 & s2) << 10) + (1023 & a2) + 65536) : (t3.push(s2), r3--);
              } else
                t3.push(s2);
            }
            return t3;
          }
          var _ = function(e3, t3) {
            return e3 + 22 + 75 * (e3 < 26) - ((0 != t3) << 5);
          }, w = function(e3, t3, r3) {
            var o2 = 0;
            for (e3 = r3 ? h(e3 / 700) : e3 >> 1, e3 += h(e3 / t3); e3 > 455; o2 += d)
              e3 = h(e3 / 35);
            return h(o2 + 36 * e3 / (e3 + 38));
          }, b = function(e3) {
            var t3, r3 = [], o2 = e3.length, s2 = 0, a2 = 128, n2 = 72, i2 = e3.lastIndexOf("-");
            i2 < 0 && (i2 = 0);
            for (var c2 = 0; c2 < i2; ++c2)
              e3.charCodeAt(c2) >= 128 && v("not-basic"), r3.push(e3.charCodeAt(c2));
            for (var u2 = i2 > 0 ? i2 + 1 : 0; u2 < o2; ) {
              for (var f2 = s2, p2 = 1, m2 = d; ; m2 += d) {
                u2 >= o2 && v("invalid-input");
                var y2 = (t3 = e3.charCodeAt(u2++)) - 48 < 10 ? t3 - 22 : t3 - 65 < 26 ? t3 - 65 : t3 - 97 < 26 ? t3 - 97 : d;
                (y2 >= d || y2 > h((l - s2) / p2)) && v("overflow"), s2 += y2 * p2;
                var g2 = m2 <= n2 ? 1 : m2 >= n2 + 26 ? 26 : m2 - n2;
                if (y2 < g2)
                  break;
                var $2 = d - g2;
                p2 > h(l / $2) && v("overflow"), p2 *= $2;
              }
              var _2 = r3.length + 1;
              n2 = w(s2 - f2, _2, 0 == f2), h(s2 / _2) > l - a2 && v("overflow"), a2 += h(s2 / _2), s2 %= _2, r3.splice(s2++, 0, a2);
            }
            return String.fromCodePoint.apply(String, r3);
          }, E = function(e3) {
            var t3 = [], r3 = (e3 = $(e3)).length, o2 = 128, s2 = 0, a2 = 72, n2 = true, i2 = false, c2 = void 0;
            try {
              for (var u2, f2 = e3[Symbol.iterator](); !(n2 = (u2 = f2.next()).done); n2 = true) {
                var p2 = u2.value;
                p2 < 128 && t3.push(y(p2));
              }
            } catch (e4) {
              i2 = true, c2 = e4;
            } finally {
              try {
                !n2 && f2.return && f2.return();
              } finally {
                if (i2)
                  throw c2;
              }
            }
            var m2 = t3.length, g2 = m2;
            for (m2 && t3.push("-"); g2 < r3; ) {
              var b2 = l, E2 = true, P2 = false, S2 = void 0;
              try {
                for (var N2, k2 = e3[Symbol.iterator](); !(E2 = (N2 = k2.next()).done); E2 = true) {
                  var j2 = N2.value;
                  j2 >= o2 && j2 < b2 && (b2 = j2);
                }
              } catch (e4) {
                P2 = true, S2 = e4;
              } finally {
                try {
                  !E2 && k2.return && k2.return();
                } finally {
                  if (P2)
                    throw S2;
                }
              }
              var C2 = g2 + 1;
              b2 - o2 > h((l - s2) / C2) && v("overflow"), s2 += (b2 - o2) * C2, o2 = b2;
              var O2 = true, x2 = false, T2 = void 0;
              try {
                for (var I2, R2 = e3[Symbol.iterator](); !(O2 = (I2 = R2.next()).done); O2 = true) {
                  var D2 = I2.value;
                  if (D2 < o2 && ++s2 > l && v("overflow"), D2 == o2) {
                    for (var A2 = s2, M2 = d; ; M2 += d) {
                      var V2 = M2 <= a2 ? 1 : M2 >= a2 + 26 ? 26 : M2 - a2;
                      if (A2 < V2)
                        break;
                      var F2 = A2 - V2, q2 = d - V2;
                      t3.push(y(_(V2 + F2 % q2, 0))), A2 = h(F2 / q2);
                    }
                    t3.push(y(_(A2, 0))), a2 = w(s2, C2, g2 == m2), s2 = 0, ++g2;
                  }
                }
              } catch (e4) {
                x2 = true, T2 = e4;
              } finally {
                try {
                  !O2 && R2.return && R2.return();
                } finally {
                  if (x2)
                    throw T2;
                }
              }
              ++s2, ++o2;
            }
            return t3.join("");
          }, P = function(e3) {
            return g(e3, function(e4) {
              return f.test(e4) ? "xn--" + E(e4) : e4;
            });
          }, S = function(e3) {
            return g(e3, function(e4) {
              return u.test(e4) ? b(e4.slice(4).toLowerCase()) : e4;
            });
          }, N = {};
          function k(e3) {
            var t3 = e3.charCodeAt(0);
            return t3 < 16 ? "%0" + t3.toString(16).toUpperCase() : t3 < 128 ? "%" + t3.toString(16).toUpperCase() : t3 < 2048 ? "%" + (t3 >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & t3 | 128).toString(16).toUpperCase() : "%" + (t3 >> 12 | 224).toString(16).toUpperCase() + "%" + (t3 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & t3 | 128).toString(16).toUpperCase();
          }
          function j(e3) {
            for (var t3 = "", r3 = 0, o2 = e3.length; r3 < o2; ) {
              var s2 = parseInt(e3.substr(r3 + 1, 2), 16);
              if (s2 < 128)
                t3 += String.fromCharCode(s2), r3 += 3;
              else if (s2 >= 194 && s2 < 224) {
                if (o2 - r3 >= 6) {
                  var a2 = parseInt(e3.substr(r3 + 4, 2), 16);
                  t3 += String.fromCharCode((31 & s2) << 6 | 63 & a2);
                } else
                  t3 += e3.substr(r3, 6);
                r3 += 6;
              } else if (s2 >= 224) {
                if (o2 - r3 >= 9) {
                  var n2 = parseInt(e3.substr(r3 + 4, 2), 16), i2 = parseInt(e3.substr(r3 + 7, 2), 16);
                  t3 += String.fromCharCode((15 & s2) << 12 | (63 & n2) << 6 | 63 & i2);
                } else
                  t3 += e3.substr(r3, 9);
                r3 += 9;
              } else
                t3 += e3.substr(r3, 3), r3 += 3;
            }
            return t3;
          }
          function C(e3, t3) {
            function r3(e4) {
              var r4 = j(e4);
              return r4.match(t3.UNRESERVED) ? r4 : e4;
            }
            return e3.scheme && (e3.scheme = String(e3.scheme).replace(t3.PCT_ENCODED, r3).toLowerCase().replace(t3.NOT_SCHEME, "")), void 0 !== e3.userinfo && (e3.userinfo = String(e3.userinfo).replace(t3.PCT_ENCODED, r3).replace(t3.NOT_USERINFO, k).replace(t3.PCT_ENCODED, s)), void 0 !== e3.host && (e3.host = String(e3.host).replace(t3.PCT_ENCODED, r3).toLowerCase().replace(t3.NOT_HOST, k).replace(t3.PCT_ENCODED, s)), void 0 !== e3.path && (e3.path = String(e3.path).replace(t3.PCT_ENCODED, r3).replace(e3.scheme ? t3.NOT_PATH : t3.NOT_PATH_NOSCHEME, k).replace(t3.PCT_ENCODED, s)), void 0 !== e3.query && (e3.query = String(e3.query).replace(t3.PCT_ENCODED, r3).replace(t3.NOT_QUERY, k).replace(t3.PCT_ENCODED, s)), void 0 !== e3.fragment && (e3.fragment = String(e3.fragment).replace(t3.PCT_ENCODED, r3).replace(t3.NOT_FRAGMENT, k).replace(t3.PCT_ENCODED, s)), e3;
          }
          function O(e3) {
            return e3.replace(/^0*(.*)/, "$1") || "0";
          }
          function x(e3, t3) {
            var r3 = e3.match(t3.IPV4ADDRESS) || [], o2 = c(r3, 2)[1];
            return o2 ? o2.split(".").map(O).join(".") : e3;
          }
          function T(e3, t3) {
            var r3 = e3.match(t3.IPV6ADDRESS) || [], o2 = c(r3, 3), s2 = o2[1], a2 = o2[2];
            if (s2) {
              for (var n2 = s2.toLowerCase().split("::").reverse(), i2 = c(n2, 2), l2 = i2[0], d2 = i2[1], u2 = d2 ? d2.split(":").map(O) : [], f2 = l2.split(":").map(O), p2 = t3.IPV4ADDRESS.test(f2[f2.length - 1]), m2 = p2 ? 7 : 8, h2 = f2.length - m2, y2 = Array(m2), v2 = 0; v2 < m2; ++v2)
                y2[v2] = u2[v2] || f2[h2 + v2] || "";
              p2 && (y2[m2 - 1] = x(y2[m2 - 1], t3));
              var g2 = y2.reduce(function(e4, t4, r4) {
                if (!t4 || "0" === t4) {
                  var o3 = e4[e4.length - 1];
                  o3 && o3.index + o3.length === r4 ? o3.length++ : e4.push({ index: r4, length: 1 });
                }
                return e4;
              }, []).sort(function(e4, t4) {
                return t4.length - e4.length;
              })[0], $2 = void 0;
              if (g2 && g2.length > 1) {
                var _2 = y2.slice(0, g2.index), w2 = y2.slice(g2.index + g2.length);
                $2 = _2.join(":") + "::" + w2.join(":");
              } else
                $2 = y2.join(":");
              return a2 && ($2 += "%" + a2), $2;
            }
            return e3;
          }
          var I = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, R = void 0 === "".match(/(){0}/)[1];
          function D(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = {}, o2 = false !== t3.iri ? i : n;
            "suffix" === t3.reference && (e3 = (t3.scheme ? t3.scheme + ":" : "") + "//" + e3);
            var s2 = e3.match(I);
            if (s2) {
              R ? (r3.scheme = s2[1], r3.userinfo = s2[3], r3.host = s2[4], r3.port = parseInt(s2[5], 10), r3.path = s2[6] || "", r3.query = s2[7], r3.fragment = s2[8], isNaN(r3.port) && (r3.port = s2[5])) : (r3.scheme = s2[1] || void 0, r3.userinfo = -1 !== e3.indexOf("@") ? s2[3] : void 0, r3.host = -1 !== e3.indexOf("//") ? s2[4] : void 0, r3.port = parseInt(s2[5], 10), r3.path = s2[6] || "", r3.query = -1 !== e3.indexOf("?") ? s2[7] : void 0, r3.fragment = -1 !== e3.indexOf("#") ? s2[8] : void 0, isNaN(r3.port) && (r3.port = e3.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? s2[4] : void 0)), r3.host && (r3.host = T(x(r3.host, o2), o2)), r3.reference = void 0 !== r3.scheme || void 0 !== r3.userinfo || void 0 !== r3.host || void 0 !== r3.port || r3.path || void 0 !== r3.query ? void 0 === r3.scheme ? "relative" : void 0 === r3.fragment ? "absolute" : "uri" : "same-document", t3.reference && "suffix" !== t3.reference && t3.reference !== r3.reference && (r3.error = r3.error || "URI is not a " + t3.reference + " reference.");
              var a2 = N[(t3.scheme || r3.scheme || "").toLowerCase()];
              if (t3.unicodeSupport || a2 && a2.unicodeSupport)
                C(r3, o2);
              else {
                if (r3.host && (t3.domainHost || a2 && a2.domainHost))
                  try {
                    r3.host = P(r3.host.replace(o2.PCT_ENCODED, j).toLowerCase());
                  } catch (e4) {
                    r3.error = r3.error || "Host's domain name can not be converted to ASCII via punycode: " + e4;
                  }
                C(r3, n);
              }
              a2 && a2.parse && a2.parse(r3, t3);
            } else
              r3.error = r3.error || "URI can not be parsed.";
            return r3;
          }
          function A(e3, t3) {
            var r3 = false !== t3.iri ? i : n, o2 = [];
            return void 0 !== e3.userinfo && (o2.push(e3.userinfo), o2.push("@")), void 0 !== e3.host && o2.push(T(x(String(e3.host), r3), r3).replace(r3.IPV6ADDRESS, function(e4, t4, r4) {
              return "[" + t4 + (r4 ? "%25" + r4 : "") + "]";
            })), "number" != typeof e3.port && "string" != typeof e3.port || (o2.push(":"), o2.push(String(e3.port))), o2.length ? o2.join("") : void 0;
          }
          var M = /^\.\.?\//, V = /^\/\.(\/|$)/, F = /^\/\.\.(\/|$)/, q = /^\/?(?:.|\n)*?(?=\/|$)/;
          function U(e3) {
            for (var t3 = []; e3.length; )
              if (e3.match(M))
                e3 = e3.replace(M, "");
              else if (e3.match(V))
                e3 = e3.replace(V, "/");
              else if (e3.match(F))
                e3 = e3.replace(F, "/"), t3.pop();
              else if ("." === e3 || ".." === e3)
                e3 = "";
              else {
                var r3 = e3.match(q);
                if (!r3)
                  throw new Error("Unexpected dot segment condition");
                var o2 = r3[0];
                e3 = e3.slice(o2.length), t3.push(o2);
              }
            return t3.join("");
          }
          function z(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t3.iri ? i : n, o2 = [], s2 = N[(t3.scheme || e3.scheme || "").toLowerCase()];
            if (s2 && s2.serialize && s2.serialize(e3, t3), e3.host) {
              if (r3.IPV6ADDRESS.test(e3.host))
                ;
              else if (t3.domainHost || s2 && s2.domainHost)
                try {
                  e3.host = t3.iri ? S(e3.host) : P(e3.host.replace(r3.PCT_ENCODED, j).toLowerCase());
                } catch (r4) {
                  e3.error = e3.error || "Host's domain name can not be converted to " + (t3.iri ? "Unicode" : "ASCII") + " via punycode: " + r4;
                }
            }
            C(e3, r3), "suffix" !== t3.reference && e3.scheme && (o2.push(e3.scheme), o2.push(":"));
            var a2 = A(e3, t3);
            if (void 0 !== a2 && ("suffix" !== t3.reference && o2.push("//"), o2.push(a2), e3.path && "/" !== e3.path.charAt(0) && o2.push("/")), void 0 !== e3.path) {
              var c2 = e3.path;
              t3.absolutePath || s2 && s2.absolutePath || (c2 = U(c2)), void 0 === a2 && (c2 = c2.replace(/^\/\//, "/%2F")), o2.push(c2);
            }
            return void 0 !== e3.query && (o2.push("?"), o2.push(e3.query)), void 0 !== e3.fragment && (o2.push("#"), o2.push(e3.fragment)), o2.join("");
          }
          function K(e3, t3) {
            var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o2 = arguments[3], s2 = {};
            return o2 || (e3 = D(z(e3, r3), r3), t3 = D(z(t3, r3), r3)), !(r3 = r3 || {}).tolerant && t3.scheme ? (s2.scheme = t3.scheme, s2.userinfo = t3.userinfo, s2.host = t3.host, s2.port = t3.port, s2.path = U(t3.path || ""), s2.query = t3.query) : (void 0 !== t3.userinfo || void 0 !== t3.host || void 0 !== t3.port ? (s2.userinfo = t3.userinfo, s2.host = t3.host, s2.port = t3.port, s2.path = U(t3.path || ""), s2.query = t3.query) : (t3.path ? ("/" === t3.path.charAt(0) ? s2.path = U(t3.path) : (s2.path = void 0 === e3.userinfo && void 0 === e3.host && void 0 === e3.port || e3.path ? e3.path ? e3.path.slice(0, e3.path.lastIndexOf("/") + 1) + t3.path : t3.path : "/" + t3.path, s2.path = U(s2.path)), s2.query = t3.query) : (s2.path = e3.path, s2.query = void 0 !== t3.query ? t3.query : e3.query), s2.userinfo = e3.userinfo, s2.host = e3.host, s2.port = e3.port), s2.scheme = e3.scheme), s2.fragment = t3.fragment, s2;
          }
          function L(e3, t3) {
            return e3 && e3.toString().replace(t3 && t3.iri ? i.PCT_ENCODED : n.PCT_ENCODED, j);
          }
          var H = { scheme: "http", domainHost: true, parse(e3, t3) {
            return e3.host || (e3.error = e3.error || "HTTP URIs must have a host."), e3;
          }, serialize(e3, t3) {
            var r3 = "https" === String(e3.scheme).toLowerCase();
            return e3.port !== (r3 ? 443 : 80) && "" !== e3.port || (e3.port = void 0), e3.path || (e3.path = "/"), e3;
          } }, G = { scheme: "https", domainHost: H.domainHost, parse: H.parse, serialize: H.serialize };
          function J(e3) {
            return "boolean" == typeof e3.secure ? e3.secure : "wss" === String(e3.scheme).toLowerCase();
          }
          var B = { scheme: "ws", domainHost: true, parse(e3, t3) {
            var r3 = e3;
            return r3.secure = J(r3), r3.resourceName = (r3.path || "/") + (r3.query ? "?" + r3.query : ""), r3.path = void 0, r3.query = void 0, r3;
          }, serialize(e3, t3) {
            if (e3.port !== (J(e3) ? 443 : 80) && "" !== e3.port || (e3.port = void 0), "boolean" == typeof e3.secure && (e3.scheme = e3.secure ? "wss" : "ws", e3.secure = void 0), e3.resourceName) {
              var r3 = e3.resourceName.split("?"), o2 = c(r3, 2), s2 = o2[0], a2 = o2[1];
              e3.path = s2 && "/" !== s2 ? s2 : void 0, e3.query = a2, e3.resourceName = void 0;
            }
            return e3.fragment = void 0, e3;
          } }, W = { scheme: "wss", domainHost: B.domainHost, parse: B.parse, serialize: B.serialize }, Q = {}, Z = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", Y = "[0-9A-Fa-f]", X = r2(r2("%[EFef][0-9A-Fa-f]%" + Y + Y + "%" + Y + Y) + "|" + r2("%[89A-Fa-f][0-9A-Fa-f]%" + Y + Y) + "|" + r2("%" + Y + Y)), ee = t2("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'), te = new RegExp(Z, "g"), re = new RegExp(X, "g"), oe = new RegExp(t2("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', ee), "g"), se = new RegExp(t2("[^]", Z, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"), ae = se;
          function ne(e3) {
            var t3 = j(e3);
            return t3.match(te) ? t3 : e3;
          }
          var ie = { scheme: "mailto", parse(e3, t3) {
            var r3 = e3, o2 = r3.to = r3.path ? r3.path.split(",") : [];
            if (r3.path = void 0, r3.query) {
              for (var s2 = false, a2 = {}, n2 = r3.query.split("&"), i2 = 0, c2 = n2.length; i2 < c2; ++i2) {
                var l2 = n2[i2].split("=");
                switch (l2[0]) {
                  case "to":
                    for (var d2 = l2[1].split(","), u2 = 0, f2 = d2.length; u2 < f2; ++u2)
                      o2.push(d2[u2]);
                    break;
                  case "subject":
                    r3.subject = L(l2[1], t3);
                    break;
                  case "body":
                    r3.body = L(l2[1], t3);
                    break;
                  default:
                    s2 = true, a2[L(l2[0], t3)] = L(l2[1], t3);
                }
              }
              s2 && (r3.headers = a2);
            }
            r3.query = void 0;
            for (var p2 = 0, m2 = o2.length; p2 < m2; ++p2) {
              var h2 = o2[p2].split("@");
              if (h2[0] = L(h2[0]), t3.unicodeSupport)
                h2[1] = L(h2[1], t3).toLowerCase();
              else
                try {
                  h2[1] = P(L(h2[1], t3).toLowerCase());
                } catch (e4) {
                  r3.error = r3.error || "Email address's domain name can not be converted to ASCII via punycode: " + e4;
                }
              o2[p2] = h2.join("@");
            }
            return r3;
          }, serialize(e3, t3) {
            var r3, o2 = e3, a2 = null != (r3 = e3.to) ? r3 instanceof Array ? r3 : "number" != typeof r3.length || r3.split || r3.setInterval || r3.call ? [r3] : Array.prototype.slice.call(r3) : [];
            if (a2) {
              for (var n2 = 0, i2 = a2.length; n2 < i2; ++n2) {
                var c2 = String(a2[n2]), l2 = c2.lastIndexOf("@"), d2 = c2.slice(0, l2).replace(re, ne).replace(re, s).replace(oe, k), u2 = c2.slice(l2 + 1);
                try {
                  u2 = t3.iri ? S(u2) : P(L(u2, t3).toLowerCase());
                } catch (e4) {
                  o2.error = o2.error || "Email address's domain name can not be converted to " + (t3.iri ? "Unicode" : "ASCII") + " via punycode: " + e4;
                }
                a2[n2] = d2 + "@" + u2;
              }
              o2.path = a2.join(",");
            }
            var f2 = e3.headers = e3.headers || {};
            e3.subject && (f2.subject = e3.subject), e3.body && (f2.body = e3.body);
            var p2 = [];
            for (var m2 in f2)
              f2[m2] !== Q[m2] && p2.push(m2.replace(re, ne).replace(re, s).replace(se, k) + "=" + f2[m2].replace(re, ne).replace(re, s).replace(ae, k));
            return p2.length && (o2.query = p2.join("&")), o2;
          } }, ce = /^([^\:]+)\:(.*)/, le = { scheme: "urn", parse(e3, t3) {
            var r3 = e3.path && e3.path.match(ce), o2 = e3;
            if (r3) {
              var s2 = t3.scheme || o2.scheme || "urn", a2 = r3[1].toLowerCase(), n2 = r3[2], i2 = N[s2 + ":" + (t3.nid || a2)];
              o2.nid = a2, o2.nss = n2, o2.path = void 0, i2 && (o2 = i2.parse(o2, t3));
            } else
              o2.error = o2.error || "URN can not be parsed.";
            return o2;
          }, serialize(e3, t3) {
            var r3 = e3.nid, o2 = N[(t3.scheme || e3.scheme || "urn") + ":" + (t3.nid || r3)];
            o2 && (e3 = o2.serialize(e3, t3));
            var s2 = e3;
            return s2.path = (r3 || t3.nid) + ":" + e3.nss, s2;
          } }, de = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ue = { scheme: "urn:uuid", parse(e3, t3) {
            var r3 = e3;
            return r3.uuid = r3.nss, r3.nss = void 0, t3.tolerant || r3.uuid && r3.uuid.match(de) || (r3.error = r3.error || "UUID is not valid."), r3;
          }, serialize(e3, t3) {
            var r3 = e3;
            return r3.nss = (e3.uuid || "").toLowerCase(), r3;
          } };
          N[H.scheme] = H, N[G.scheme] = G, N[B.scheme] = B, N[W.scheme] = W, N[ie.scheme] = ie, N[le.scheme] = le, N[ue.scheme] = ue, e2.SCHEMES = N, e2.pctEncChar = k, e2.pctDecChars = j, e2.parse = D, e2.removeDotSegments = U, e2.serialize = z, e2.resolveComponents = K, e2.resolve = function(e3, t3, r3) {
            var o2 = function(e4, t4) {
              var r4 = e4;
              if (t4)
                for (var o3 in t4)
                  r4[o3] = t4[o3];
              return r4;
            }({ scheme: "null" }, r3);
            return z(K(D(e3, o2), D(t3, o2), o2, true), o2);
          }, e2.normalize = function(e3, t3) {
            return "string" == typeof e3 ? e3 = z(D(e3, t3), t3) : "object" === o(e3) && (e3 = D(z(e3, t3), t3)), e3;
          }, e2.equal = function(e3, t3, r3) {
            return "string" == typeof e3 ? e3 = z(D(e3, r3), r3) : "object" === o(e3) && (e3 = z(e3, r3)), "string" == typeof t3 ? t3 = z(D(t3, r3), r3) : "object" === o(t3) && (t3 = z(t3, r3)), e3 === t3;
          }, e2.escapeComponent = function(e3, t3) {
            return e3 && e3.toString().replace(t3 && t3.iri ? i.ESCAPE : n.ESCAPE, k);
          }, e2.unescapeComponent = L, Object.defineProperty(e2, "__esModule", { value: true });
        });
      }, {}], ajv: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.MissingRefError = r.ValidationError = r.CodeGen = r.Name = r.nil = r.stringify = r.str = r._ = r.KeywordCxt = void 0;
        const o = e("./core"), s = e("./vocabularies/draft7"), a = e("./vocabularies/discriminator"), n = e("./refs/json-schema-draft-07.json"), i = ["/properties"], c = "http://json-schema.org/draft-07/schema";
        class l extends o.default {
          _addVocabularies() {
            super._addVocabularies(), s.default.forEach((e2) => this.addVocabulary(e2)), this.opts.discriminator && this.addKeyword(a.default);
          }
          _addDefaultMetaSchema() {
            if (super._addDefaultMetaSchema(), !this.opts.meta)
              return;
            const e2 = this.opts.$data ? this.$dataMetaSchema(n, i) : n;
            this.addMetaSchema(e2, c, false), this.refs["http://json-schema.org/schema"] = c;
          }
          defaultMeta() {
            return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c) ? c : void 0);
          }
        }
        t.exports = r = l, Object.defineProperty(r, "__esModule", { value: true }), r.default = l;
        var d = e("./compile/validate");
        Object.defineProperty(r, "KeywordCxt", { enumerable: true, get() {
          return d.KeywordCxt;
        } });
        var u = e("./compile/codegen");
        Object.defineProperty(r, "_", { enumerable: true, get() {
          return u._;
        } }), Object.defineProperty(r, "str", { enumerable: true, get() {
          return u.str;
        } }), Object.defineProperty(r, "stringify", { enumerable: true, get() {
          return u.stringify;
        } }), Object.defineProperty(r, "nil", { enumerable: true, get() {
          return u.nil;
        } }), Object.defineProperty(r, "Name", { enumerable: true, get() {
          return u.Name;
        } }), Object.defineProperty(r, "CodeGen", { enumerable: true, get() {
          return u.CodeGen;
        } });
        var f = e("./runtime/validation_error");
        Object.defineProperty(r, "ValidationError", { enumerable: true, get() {
          return f.default;
        } });
        var p = e("./compile/ref_error");
        Object.defineProperty(r, "MissingRefError", { enumerable: true, get() {
          return p.default;
        } });
      }, { "./compile/codegen": 2, "./compile/ref_error": 7, "./compile/validate": 15, "./core": 18, "./refs/json-schema-draft-07.json": 20, "./runtime/validation_error": 24, "./vocabularies/discriminator": 46, "./vocabularies/draft7": 48 }] }, {}, [])("ajv");
    });
  }
});

export {
  require_ajv7_min
};
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
//# sourceMappingURL=chunk-KMPLO4LY.js.map
