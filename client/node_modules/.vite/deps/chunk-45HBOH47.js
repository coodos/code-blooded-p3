// ../node_modules/jsonrepair/lib/esm/JsonRepairError.js
function JsonRepairError(message, char) {
  if (!(this instanceof JsonRepairError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.message = message + " (char " + char + ")";
  this.char = char;
  this.stack = new Error().stack;
}
JsonRepairError.prototype = new Error();
JsonRepairError.prototype.constructor = Error;

// ../node_modules/jsonrepair/lib/esm/stringUtils.js
var SINGLE_QUOTES = {
  "'": true,
  "\u2018": true,
  "\u2019": true,
  "`": true,
  "\xB4": true
};
var DOUBLE_QUOTES = {
  '"': true,
  "\u201C": true,
  "\u201D": true
};
function isAlpha(c2) {
  return ALPHA_REGEX.test(c2);
}
var ALPHA_REGEX = /^[a-zA-Z_]$/;
function isHex(c2) {
  return HEX_REGEX.test(c2);
}
var HEX_REGEX = /^[0-9a-fA-F]$/;
function isDigit(c2) {
  return DIGIT_REGEX.test(c2);
}
var DIGIT_REGEX = /^[0-9]$/;
function isWhitespace(c2) {
  return c2 === " " || c2 === "	" || c2 === "\n" || c2 === "\r";
}
function isSpecialWhitespace(c2) {
  return c2 === "\xA0" || c2 >= "\u2000" && c2 <= "\u200A" || c2 === "\u202F" || c2 === "\u205F" || c2 === "\u3000";
}
function normalizeWhitespace(text) {
  var normalized = "";
  for (var i = 0; i < text.length; i++) {
    var char = text[i];
    normalized += isSpecialWhitespace(char) ? " " : char;
  }
  return normalized;
}
function isQuote(c2) {
  return SINGLE_QUOTES[c2] === true || DOUBLE_QUOTES[c2] === true;
}
function isSingleQuote(c2) {
  return SINGLE_QUOTES[c2] === true;
}
function isDoubleQuote(c2) {
  return DOUBLE_QUOTES[c2] === true;
}
function normalizeQuote(c2) {
  if (SINGLE_QUOTES[c2] === true) {
    return "'";
  }
  if (DOUBLE_QUOTES[c2] === true) {
    return '"';
  }
  return c2;
}
function stripLastOccurrence(text, textToStrip) {
  var index2 = text.lastIndexOf(textToStrip);
  return index2 !== -1 ? text.substring(0, index2) + text.substring(index2 + 1) : text;
}
function insertBeforeLastWhitespace(text, textToInsert) {
  var index2 = text.length;
  if (!isWhitespace(text[index2 - 1])) {
    return text + textToInsert;
  }
  while (isWhitespace(text[index2 - 1])) {
    index2--;
  }
  return text.substring(0, index2) + textToInsert + text.substring(index2);
}
function insertAtIndex(text, textToInsert, index2) {
  return text.substring(0, index2) + textToInsert + text.substring(index2);
}

// ../node_modules/jsonrepair/lib/esm/jsonrepair.js
var DELIMITER = 0;
var NUMBER = 1;
var STRING = 2;
var SYMBOL = 3;
var WHITESPACE = 4;
var COMMENT = 5;
var UNKNOWN = 6;
var DELIMITERS = {
  "": true,
  "{": true,
  "}": true,
  "[": true,
  "]": true,
  ":": true,
  ",": true,
  "(": true,
  ")": true,
  ";": true,
  "+": true
};
var ESCAPE_CHARACTERS = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
};
var CONTROL_CHARACTERS = {
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
var SYMBOLS = {
  null: "null",
  true: "true",
  false: "false"
};
var PYTHON_SYMBOLS = {
  None: "null",
  True: "true",
  False: "false"
};
var input = "";
var output = "";
var index = 0;
var c = "";
var token = "";
var tokenType = UNKNOWN;
function jsonrepair(text) {
  input = text;
  output = "";
  index = 0;
  c = input.charAt(0);
  token = "";
  tokenType = UNKNOWN;
  processNextToken();
  var rootLevelTokenType = tokenType;
  parseObject();
  skipComma();
  if (token === "") {
    return output;
  }
  if (rootLevelTokenType === tokenType && tokenIsStartOfValue()) {
    var stashedOutput = "";
    while (rootLevelTokenType === tokenType && tokenIsStartOfValue()) {
      output = insertBeforeLastWhitespace(output, ",");
      stashedOutput += output;
      output = "";
      parseObject();
      skipComma();
    }
    return "[\n".concat(stashedOutput).concat(output, "\n]");
  }
  throw new JsonRepairError("Unexpected characters", index - token.length);
}
function next() {
  index++;
  c = input.charAt(index);
}
function nextSkipEscape() {
  next();
  if (c === "\\") {
    next();
  }
}
function tokenIsStartOfValue() {
  return tokenType === DELIMITER && (token === "[" || token === "{") || tokenType === STRING || tokenType === NUMBER || tokenType === SYMBOL;
}
function tokenIsStartOfKey() {
  return tokenType === STRING || tokenType === NUMBER || tokenType === SYMBOL;
}
function processNextToken() {
  output += token;
  tokenType = UNKNOWN;
  token = "";
  getTokenDelimiter();
  if (tokenType === WHITESPACE) {
    token = normalizeWhitespace(token);
    processNextToken();
  }
  if (tokenType === COMMENT) {
    tokenType = UNKNOWN;
    token = "";
    processNextToken();
  }
}
function skipComma() {
  if (token === ",") {
    token = "";
    tokenType = UNKNOWN;
    processNextToken();
  }
}
function getTokenDelimiter() {
  if (DELIMITERS[c]) {
    tokenType = DELIMITER;
    token = c;
    next();
    return;
  }
  getTokenNumber();
}
function getTokenNumber() {
  if (isDigit(c) || c === "-") {
    tokenType = NUMBER;
    if (c === "-") {
      token += c;
      next();
      if (!isDigit(c)) {
        throw new JsonRepairError("Invalid number, digit expected", index);
      }
    } else if (c === "0") {
      token += c;
      next();
    } else {
    }
    while (isDigit(c)) {
      token += c;
      next();
    }
    if (c === ".") {
      token += c;
      next();
      if (!isDigit(c)) {
        throw new JsonRepairError("Invalid number, digit expected", index);
      }
      while (isDigit(c)) {
        token += c;
        next();
      }
    }
    if (c === "e" || c === "E") {
      token += c;
      next();
      if (c === "+" || c === "-") {
        token += c;
        next();
      }
      if (!isDigit(c)) {
        throw new JsonRepairError("Invalid number, digit expected", index);
      }
      while (isDigit(c)) {
        token += c;
        next();
      }
    }
    return;
  }
  getTokenEscapedString();
}
function getTokenEscapedString() {
  if (c === "\\" && input.charAt(index + 1) === '"') {
    next();
    getTokenString(nextSkipEscape);
  } else {
    getTokenString(next);
  }
}
function getTokenString(getNext) {
  if (isQuote(c)) {
    var quote = normalizeQuote(c);
    var isEndQuote = isSingleQuote(c) ? isSingleQuote : isDoubleQuote;
    token += '"';
    tokenType = STRING;
    getNext();
    while (c !== "" && !isEndQuote(c)) {
      if (c === "\\") {
        getNext();
        var unescaped = ESCAPE_CHARACTERS[c];
        if (unescaped !== void 0) {
          token += "\\" + c;
          getNext();
        } else if (c === "u") {
          token += "\\u";
          getNext();
          for (var u = 0; u < 4; u++) {
            if (!isHex(c)) {
              throw new JsonRepairError("Invalid unicode character", index - token.length);
            }
            token += c;
            getNext();
          }
        } else if (c === "'") {
          token += "'";
          getNext();
        } else {
          throw new JsonRepairError('Invalid escape character "\\' + c + '"', index);
        }
      } else if (CONTROL_CHARACTERS[c]) {
        token += CONTROL_CHARACTERS[c];
        getNext();
      } else if (c === '"') {
        token += '\\"';
        getNext();
      } else {
        token += c;
        getNext();
      }
    }
    if (normalizeQuote(c) !== quote) {
      throw new JsonRepairError("End of string expected", index - token.length);
    }
    token += '"';
    getNext();
    return;
  }
  getTokenAlpha();
}
function getTokenAlpha() {
  if (isAlpha(c)) {
    tokenType = SYMBOL;
    while (isAlpha(c) || isDigit(c) || c === "$") {
      token += c;
      next();
    }
    return;
  }
  getTokenWhitespace();
}
function getTokenWhitespace() {
  if (isWhitespace(c) || isSpecialWhitespace(c)) {
    tokenType = WHITESPACE;
    while (isWhitespace(c) || isSpecialWhitespace(c)) {
      token += c;
      next();
    }
    return;
  }
  getTokenComment();
}
function getTokenComment() {
  if (c === "/" && input[index + 1] === "*") {
    tokenType = COMMENT;
    while (c !== "" && (c !== "*" || c === "*" && input[index + 1] !== "/")) {
      token += c;
      next();
    }
    if (c === "*" && input[index + 1] === "/") {
      token += c;
      next();
      token += c;
      next();
    }
    return;
  }
  if (c === "/" && input[index + 1] === "/") {
    tokenType = COMMENT;
    while (c !== "" && c !== "\n") {
      token += c;
      next();
    }
    return;
  }
  getTokenUnknown();
}
function getTokenUnknown() {
  tokenType = UNKNOWN;
  while (c !== "") {
    token += c;
    next();
  }
  throw new JsonRepairError('Syntax error in part "' + token + '"', index - token.length);
}
function parseObject() {
  if (tokenType === DELIMITER && token === "{") {
    processNextToken();
    if (tokenType === DELIMITER && token === "}") {
      processNextToken();
      return;
    }
    while (true) {
      if (tokenType === SYMBOL || tokenType === NUMBER) {
        tokenType = STRING;
        token = '"'.concat(token, '"');
      }
      if (tokenType !== STRING) {
        throw new JsonRepairError("Object key expected", index - token.length);
      }
      processNextToken();
      if (tokenType === DELIMITER && token === ":") {
        processNextToken();
      } else {
        if (tokenIsStartOfValue()) {
          output = insertBeforeLastWhitespace(output, ":");
        } else {
          throw new JsonRepairError("Colon expected", index - token.length);
        }
      }
      parseObject();
      if (tokenType === DELIMITER && token === ",") {
        processNextToken();
        if (tokenType === DELIMITER && token === "}") {
          output = stripLastOccurrence(output, ",");
          break;
        }
        if (token === "") {
          output = stripLastOccurrence(output, ",");
          break;
        }
      } else {
        if (tokenIsStartOfKey()) {
          output = insertBeforeLastWhitespace(output, ",");
        } else {
          break;
        }
      }
    }
    if (tokenType === DELIMITER && token === "}") {
      processNextToken();
    } else {
      output = insertBeforeLastWhitespace(output, "}");
    }
    return;
  }
  parseArray();
}
function parseArray() {
  if (tokenType === DELIMITER && token === "[") {
    processNextToken();
    if (tokenType === DELIMITER && token === "]") {
      processNextToken();
      return;
    }
    while (true) {
      parseObject();
      if (tokenType === DELIMITER && token === ",") {
        processNextToken();
        if (tokenType === DELIMITER && token === "]") {
          output = stripLastOccurrence(output, ",");
          break;
        }
        if (token === "") {
          output = stripLastOccurrence(output, ",");
          break;
        }
      } else {
        if (tokenIsStartOfValue()) {
          output = insertBeforeLastWhitespace(output, ",");
        } else {
          break;
        }
      }
    }
    if (tokenType === DELIMITER && token === "]") {
      processNextToken();
    } else {
      output = insertBeforeLastWhitespace(output, "]");
    }
    return;
  }
  parseString();
}
function parseString() {
  if (tokenType === STRING) {
    processNextToken();
    while (tokenType === DELIMITER && token === "+") {
      token = "";
      processNextToken();
      if (tokenType === STRING) {
        var endIndex = output.lastIndexOf('"');
        output = output.substring(0, endIndex) + token.substring(1);
        token = "";
        processNextToken();
      }
    }
    return;
  }
  parseNumber();
}
function parseNumber() {
  if (tokenType === NUMBER) {
    processNextToken();
    return;
  }
  parseSymbol();
}
function parseSymbol() {
  if (tokenType === SYMBOL) {
    if (SYMBOLS[token]) {
      processNextToken();
      return;
    }
    if (PYTHON_SYMBOLS[token]) {
      token = PYTHON_SYMBOLS[token];
      processNextToken();
      return;
    }
    var symbol = token;
    var symbolIndex = output.length;
    token = "";
    processNextToken();
    if (tokenType === DELIMITER && token === "(") {
      token = "";
      processNextToken();
      parseObject();
      if (tokenType === DELIMITER && token === ")") {
        token = "";
        processNextToken();
        if (tokenType === DELIMITER && token === ";") {
          token = "";
          processNextToken();
        }
      }
      return;
    }
    output = insertAtIndex(output, '"'.concat(symbol), symbolIndex);
    while (tokenType === SYMBOL || tokenType === NUMBER) {
      processNextToken();
    }
    output += '"';
    return;
  }
  parseEnd();
}
function parseEnd() {
  if (token === "") {
    throw new JsonRepairError("Unexpected end of json string", index - token.length);
  } else {
    throw new JsonRepairError("Value expected", index - token.length);
  }
}

export {
  jsonrepair
};
//# sourceMappingURL=chunk-45HBOH47.js.map
