// ../node_modules/immutable-json-patch/lib/esm/typeguards.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function isJSONArray(value) {
  return Array.isArray(value);
}
function isJSONObject(value) {
  return value !== null && _typeof(value) === "object" && value.constructor === Object;
}
function isJSONPatchOperation(value) {
  return value && _typeof(value) === "object" ? typeof value.op === "string" : false;
}
function isJSONPatchAdd(value) {
  return value && _typeof(value) === "object" ? value.op === "add" : false;
}
function isJSONPatchRemove(value) {
  return value && _typeof(value) === "object" ? value.op === "remove" : false;
}
function isJSONPatchReplace(value) {
  return value && _typeof(value) === "object" ? value.op === "replace" : false;
}
function isJSONPatchCopy(value) {
  return value && _typeof(value) === "object" ? value.op === "copy" : false;
}
function isJSONPatchMove(value) {
  return value && _typeof(value) === "object" ? value.op === "move" : false;
}
function isJSONPatchTest(value) {
  return value && _typeof(value) === "object" ? value.op === "test" : false;
}

// ../node_modules/immutable-json-patch/lib/esm/utils.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function isEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}
function strictEqual(a, b) {
  return a === b;
}
function initial(array) {
  return array.slice(0, array.length - 1);
}
function last(array) {
  return array[array.length - 1];
}
function startsWith(array1, array2) {
  var isEqual2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : strictEqual;
  if (array1.length < array2.length) {
    return false;
  }
  for (var i = 0; i < array2.length; i++) {
    if (!isEqual2(array1[i], array2[i])) {
      return false;
    }
  }
  return true;
}
function isObjectOrArray(value) {
  return _typeof2(value) === "object" && value !== null;
}

// ../node_modules/immutable-json-patch/lib/esm/immutabilityHelpers.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function shallowClone(value) {
  if (isJSONArray(value)) {
    var copy2 = value.slice();
    Object.getOwnPropertySymbols(value).forEach(function(symbol) {
      copy2[symbol] = value[symbol];
    });
    return copy2;
  } else if (isJSONObject(value)) {
    var _copy = _objectSpread({}, value);
    Object.getOwnPropertySymbols(value).forEach(function(symbol) {
      _copy[symbol] = value[symbol];
    });
    return _copy;
  } else {
    return value;
  }
}
function applyProp(object, key, value) {
  if (object[key] === value) {
    return object;
  } else {
    var updatedObject = shallowClone(object);
    updatedObject[key] = value;
    return updatedObject;
  }
}
function getIn(object, path) {
  var value = object;
  var i = 0;
  while (i < path.length) {
    if (isJSONObject(value)) {
      value = value[path[i]];
    } else if (isJSONArray(value)) {
      value = value[parseInt(path[i])];
    } else {
      value = void 0;
    }
    i++;
  }
  return value;
}
function setIn(object, path, value) {
  var createPath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (path.length === 0) {
    return value;
  }
  var key = path[0];
  var updatedValue = setIn(object ? object[key] : void 0, path.slice(1), value, createPath);
  if (isJSONObject(object) || isJSONArray(object)) {
    return applyProp(object, key, updatedValue);
  } else {
    if (createPath) {
      var newObject = IS_INTEGER_REGEX.test(key) ? [] : {};
      newObject[key] = updatedValue;
      return newObject;
    } else {
      throw new Error("Path does not exist");
    }
  }
}
var IS_INTEGER_REGEX = /^\d+$/;
function updateIn(object, path, callback) {
  if (path.length === 0) {
    return callback(object);
  }
  if (!isObjectOrArray(object)) {
    throw new Error("Path doesn't exist");
  }
  var key = path[0];
  var updatedValue = updateIn(object[key], path.slice(1), callback);
  return applyProp(object, key, updatedValue);
}
function deleteIn(object, path) {
  if (path.length === 0) {
    return object;
  }
  if (!isObjectOrArray(object)) {
    throw new Error("Path does not exist");
  }
  if (path.length === 1) {
    var _key = path[0];
    if (!(_key in object)) {
      return object;
    } else {
      var updatedObject = shallowClone(object);
      if (isJSONArray(updatedObject)) {
        updatedObject.splice(parseInt(_key), 1);
      }
      if (isJSONObject(updatedObject)) {
        delete updatedObject[_key];
      }
      return updatedObject;
    }
  }
  var key = path[0];
  var updatedValue = deleteIn(object[key], path.slice(1));
  return applyProp(object, key, updatedValue);
}
function insertAt(document, path, value) {
  var parentPath = path.slice(0, path.length - 1);
  var index = path[path.length - 1];
  return updateIn(document, parentPath, function(items) {
    if (!Array.isArray(items)) {
      throw new TypeError("Array expected at path " + JSON.stringify(parentPath));
    }
    var updatedItems = shallowClone(items);
    updatedItems.splice(parseInt(index), 0, value);
    return updatedItems;
  });
}
function transform(document, callback) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var updated1 = callback(document, path);
  if (isJSONArray(updated1)) {
    var updated2;
    for (var i = 0; i < updated1.length; i++) {
      var before = updated1[i];
      var after = transform(before, callback, path.concat(i + ""));
      if (after !== before) {
        if (!updated2) {
          updated2 = shallowClone(updated1);
        }
        updated2[i] = after;
      }
    }
    return updated2 || updated1;
  } else if (isJSONObject(updated1)) {
    var _updated;
    for (var key in updated1) {
      if (Object.hasOwnProperty.call(updated1, key)) {
        var _before = updated1[key];
        var _after = transform(_before, callback, path.concat(key));
        if (_after !== _before) {
          if (!_updated) {
            _updated = shallowClone(updated1);
          }
          _updated[key] = _after;
        }
      }
    }
    return _updated || updated1;
  } else {
    return updated1;
  }
}
function existsIn(document, path) {
  if (document === void 0) {
    return false;
  }
  if (path.length === 0) {
    return true;
  }
  if (document === null) {
    return false;
  }
  return existsIn(document[path[0]], path.slice(1));
}

// ../node_modules/immutable-json-patch/lib/esm/jsonPointer.js
function parseJSONPointer(pointer) {
  var path = pointer.split("/");
  path.shift();
  return path.map(function(p) {
    return p.replace(/~1/g, "/").replace(/~0/g, "~");
  });
}
function compileJSONPointer(path) {
  return path.map(compileJSONPointerProp).join("");
}
function compileJSONPointerProp(pathProp) {
  return "/" + String(pathProp).replace(/~/g, "~0").replace(/\//g, "~1");
}
function appendToJSONPointer(pointer, pathProp) {
  return pointer + compileJSONPointerProp(pathProp);
}
function startsWithJSONPointer(pointer, searchPointer) {
  return pointer.startsWith(searchPointer) && (pointer.length === searchPointer.length || pointer[searchPointer.length] === "/");
}

// ../node_modules/immutable-json-patch/lib/esm/immutableJSONPatch.js
function immutableJSONPatch(document, operations, options) {
  var updatedDocument = document;
  for (var i = 0; i < operations.length; i++) {
    validateJSONPatchOperation(operations[i]);
    var operation = operations[i];
    if (options && options.before) {
      var result = options.before(updatedDocument, operation);
      if (result !== void 0) {
        if (result.document !== void 0) {
          updatedDocument = result.document;
        }
        if (result.json !== void 0) {
          throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
        }
        if (result.operation !== void 0) {
          operation = result.operation;
        }
      }
    }
    var previousDocument = updatedDocument;
    var path = parsePath(updatedDocument, operation.path);
    if (operation.op === "add") {
      updatedDocument = add(updatedDocument, path, operation.value);
    } else if (operation.op === "remove") {
      updatedDocument = remove(updatedDocument, path);
    } else if (operation.op === "replace") {
      updatedDocument = replace(updatedDocument, path, operation.value);
    } else if (operation.op === "copy") {
      updatedDocument = copy(updatedDocument, path, parseFrom(operation.from));
    } else if (operation.op === "move") {
      updatedDocument = move(updatedDocument, path, parseFrom(operation.from));
    } else if (operation.op === "test") {
      test(updatedDocument, path, operation.value);
    } else {
      throw new Error("Unknown JSONPatch operation " + JSON.stringify(operation));
    }
    if (options && options.after) {
      var _result = options.after(updatedDocument, operation, previousDocument);
      if (_result !== void 0) {
        updatedDocument = _result;
      }
    }
  }
  return updatedDocument;
}
function replace(document, path, value) {
  return setIn(document, path, value);
}
function remove(document, path) {
  return deleteIn(document, path);
}
function add(document, path, value) {
  if (isArrayItem(document, path)) {
    return insertAt(document, path, value);
  } else {
    return setIn(document, path, value);
  }
}
function copy(document, path, from) {
  var value = getIn(document, from);
  if (isArrayItem(document, path)) {
    return insertAt(document, path, value);
  } else {
    var _value = getIn(document, from);
    return setIn(document, path, _value);
  }
}
function move(document, path, from) {
  var value = getIn(document, from);
  var removedJson = deleteIn(document, from);
  return isArrayItem(removedJson, path) ? insertAt(removedJson, path, value) : setIn(removedJson, path, value);
}
function test(document, path, value) {
  if (value === void 0) {
    throw new Error('Test failed: no value provided (path: "'.concat(compileJSONPointer(path), '")'));
  }
  if (!existsIn(document, path)) {
    throw new Error('Test failed: path not found (path: "'.concat(compileJSONPointer(path), '")'));
  }
  var actualValue = getIn(document, path);
  if (!isEqual(actualValue, value)) {
    throw new Error('Test failed, value differs (path: "'.concat(compileJSONPointer(path), '")'));
  }
}
function isArrayItem(document, path) {
  if (path.length === 0) {
    return false;
  }
  var parent = getIn(document, initial(path));
  return Array.isArray(parent);
}
function resolvePathIndex(document, path) {
  if (last(path) !== "-") {
    return path;
  }
  var parentPath = initial(path);
  var parent = getIn(document, parentPath);
  return parentPath.concat(parent.length);
}
function validateJSONPatchOperation(operation) {
  var ops = ["add", "remove", "replace", "copy", "move", "test"];
  if (!ops.includes(operation.op)) {
    throw new Error("Unknown JSONPatch op " + JSON.stringify(operation.op));
  }
  if (typeof operation.path !== "string") {
    throw new Error('Required property "path" missing or not a string in operation ' + JSON.stringify(operation));
  }
  if (operation.op === "copy" || operation.op === "move") {
    if (typeof operation.from !== "string") {
      throw new Error('Required property "from" missing or not a string in operation ' + JSON.stringify(operation));
    }
  }
}
function parsePath(document, pointer) {
  return resolvePathIndex(document, parseJSONPointer(pointer));
}
function parseFrom(fromPointer) {
  return parseJSONPointer(fromPointer);
}

// ../node_modules/immutable-json-patch/lib/esm/revertJSONPatch.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function revertJSONPatch(document, operations, options) {
  var allRevertOperations = [];
  immutableJSONPatch(document, operations, {
    before: function before(document2, operation) {
      var revertOperations;
      var path = parsePath(document2, operation.path);
      if (operation.op === "add") {
        revertOperations = revertAdd(document2, path);
      } else if (operation.op === "remove") {
        revertOperations = revertRemove(document2, path);
      } else if (operation.op === "replace") {
        revertOperations = revertReplace(document2, path);
      } else if (operation.op === "copy") {
        revertOperations = revertCopy(document2, path);
      } else if (operation.op === "move") {
        revertOperations = revertMove(document2, path, parseFrom(operation.from));
      } else if (operation.op === "test") {
        revertOperations = [];
      } else {
        throw new Error("Unknown JSONPatch operation " + JSON.stringify(operation));
      }
      var updatedJson;
      if (options && options.before) {
        var res = options.before(document2, operation, revertOperations);
        if (res && res.revertOperations) {
          revertOperations = res.revertOperations;
        }
        if (res && res.document) {
          updatedJson = res.document;
        }
        if (res && res.json) {
          throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
        }
      }
      allRevertOperations = revertOperations.concat(allRevertOperations);
      if (updatedJson !== void 0) {
        return {
          document: updatedJson
        };
      }
    }
  });
  return allRevertOperations;
}
function revertReplace(document, path) {
  return [{
    op: "replace",
    path: compileJSONPointer(path),
    value: getIn(document, path)
  }];
}
function revertRemove(document, path) {
  return [{
    op: "add",
    path: compileJSONPointer(path),
    value: getIn(document, path)
  }];
}
function revertAdd(document, path) {
  if (isArrayItem(document, path) || !existsIn(document, path)) {
    return [{
      op: "remove",
      path: compileJSONPointer(path)
    }];
  } else {
    return revertReplace(document, path);
  }
}
function revertCopy(document, path) {
  return revertAdd(document, path);
}
function revertMove(document, path, from) {
  if (path.length < from.length && startsWith(from, path)) {
    return [{
      op: "replace",
      path: compileJSONPointer(path),
      value: document
    }];
  }
  var move2 = {
    op: "move",
    from: compileJSONPointer(path),
    path: compileJSONPointer(from)
  };
  if (!isArrayItem(document, path) && existsIn(document, path)) {
    return [move2].concat(_toConsumableArray(revertRemove(document, path)));
  } else {
    return [move2];
  }
}

export {
  isJSONArray,
  isJSONObject,
  isJSONPatchOperation,
  isJSONPatchAdd,
  isJSONPatchRemove,
  isJSONPatchReplace,
  isJSONPatchCopy,
  isJSONPatchMove,
  isJSONPatchTest,
  getIn,
  setIn,
  updateIn,
  deleteIn,
  insertAt,
  transform,
  existsIn,
  parseJSONPointer,
  compileJSONPointer,
  compileJSONPointerProp,
  appendToJSONPointer,
  startsWithJSONPointer,
  immutableJSONPatch,
  parsePath,
  parseFrom,
  revertJSONPatch
};
//# sourceMappingURL=chunk-DL33P6QM.js.map
