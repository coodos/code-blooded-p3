import {
  require_classnames
} from "./chunk-NTCP5I76.js";
import {
  require_natural_compare_lite
} from "./chunk-3UKAOOYZ.js";
import {
  json
} from "./chunk-JORM3ZMK.js";
import {
  memoizeOne
} from "./chunk-RVYQPB7C.js";
import {
  cloneDeepWith_default,
  debounce_default,
  forEachRight_default,
  groupBy_default,
  head_default,
  initial_default,
  isEmpty_default,
  isEqual_default,
  last_default,
  lodash_exports,
  map_default,
  memoize_default,
  minBy_default,
  noop_default,
  range_default,
  sortBy_default,
  throttle_default,
  times_default,
  uniqueId_default
} from "./chunk-C27PYTDT.js";
import {
  faCheckSquare,
  faClock,
  faLightbulb,
  faSquare
} from "./chunk-ZGOFM6RK.js";
import {
  require_ajv7_min
} from "./chunk-KMPLO4LY.js";
import {
  require_jmespath
} from "./chunk-ESLR72RD.js";
import {
  require_json_source_map
} from "./chunk-WL672J7G.js";
import {
  jsonrepair
} from "./chunk-45HBOH47.js";
import {
  faAngleDown,
  faAngleRight,
  faArrowDown,
  faCaretDown,
  faCaretRight,
  faCaretSquareDown,
  faCaretSquareUp,
  faCheck,
  faChevronDown,
  faChevronUp,
  faCircleNotch,
  faClone,
  faClose,
  faCode,
  faCog,
  faCopy,
  faCropAlt,
  faCut,
  faEdit,
  faEllipsisV,
  faExclamationTriangle,
  faFilter,
  faPaste,
  faPen,
  faRedo,
  faSearch,
  faSortAmountDownAlt,
  faTimes,
  faUndo,
  faWrench
} from "./chunk-56DZOPCY.js";
import {
  basicSetup
} from "./chunk-FY5WM2W2.js";
import {
  indentWithTab,
  redo,
  redoDepth,
  undo,
  undoDepth
} from "./chunk-K5F6CBPZ.js";
import {
  lintGutter,
  linter
} from "./chunk-FC42UQJG.js";
import {
  HighlightStyle,
  indentUnit,
  syntaxHighlighting
} from "./chunk-35U574GO.js";
import {
  tags
} from "./chunk-R3ETGW3Y.js";
import {
  closeSearchPanel,
  openSearchPanel,
  search
} from "./chunk-4FOJWVCE.js";
import "./chunk-7Q37634V.js";
import {
  EditorView,
  ViewUpdate,
  keymap
} from "./chunk-YUUAGPJA.js";
import {
  Compartment,
  EditorState
} from "./chunk-MXDR7YTD.js";
import {
  fade
} from "./chunk-3N7LPZ46.js";
import "./chunk-2JA7HOLX.js";
import {
  svelte_exports
} from "./chunk-2TP4T3PZ.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  add_resize_listener,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  beforeUpdate,
  bind,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  not_equal,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  setContext,
  set_attributes,
  set_custom_element_data,
  set_data_dev,
  set_input_value,
  set_style,
  set_svg_attributes,
  space,
  stop_propagation,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots
} from "./chunk-4PYYXLO3.js";
import {
  appendToJSONPointer,
  compileJSONPointer,
  compileJSONPointerProp,
  deleteIn,
  existsIn,
  getIn,
  immutableJSONPatch,
  insertAt,
  isJSONArray,
  isJSONObject,
  isJSONPatchAdd,
  isJSONPatchCopy,
  isJSONPatchMove,
  isJSONPatchRemove,
  isJSONPatchReplace,
  parseFrom,
  parseJSONPointer,
  parsePath,
  revertJSONPatch,
  setIn,
  startsWithJSONPointer,
  updateIn
} from "./chunk-DL33P6QM.js";
import {
  __toESM
} from "./chunk-BHN6OJC3.js";

// ../node_modules/svelte-jsoneditor/utils/debug.js
function createDebug(namespace, enabled = !!tryReadLocalStorage("debug")) {
  if (enabled) {
    const color = selectColor(namespace);
    return function debug5(...args) {
      console.log(`%c${namespace}`, `color:${color}`, ...args);
    };
  } else {
    return noop2;
  }
}
function noop2() {
}
function tryReadLocalStorage(key) {
  try {
    if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
      return window.localStorage[key];
    }
  } catch (error) {
  }
}
function selectColor(namespace) {
  let hash = 0;
  for (let i = 0; i < namespace.length; i++) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0;
  }
  return colors[Math.abs(hash) % colors.length];
}
var colors = [
  "#0000CC",
  "#0099FF",
  "#009400",
  "#8dd200",
  "#CCCC00",
  "#CC9933",
  "#ae04e7",
  "#ff35d7",
  "#FF3333",
  "#FF6600",
  "#FF9933",
  "#FFCC33"
];

// ../node_modules/svelte-simple-modal/src/Modal.svelte
var { Object: Object_1, window: window_1 } = globals;
var file = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-simple-modal/src/Modal.svelte";
function add_css(target) {
  append_styles(target, "svelte-7x8jg", ".svelte-7x8jg{box-sizing:border-box}.bg.svelte-7x8jg{position:fixed;z-index:1000;top:0;left:0;display:flex;flex-direction:column;justify-content:center;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.66)}@supports (-webkit-touch-callout: none){}.wrap.svelte-7x8jg{position:relative;margin:2rem;max-height:100%}.window.svelte-7x8jg{position:relative;width:40rem;max-width:100%;max-height:100%;margin:2rem auto;color:black;border-radius:0.5rem;background:white}.content.svelte-7x8jg{position:relative;padding:1rem;max-height:calc(100vh - 4rem);overflow:auto}.close.svelte-7x8jg{display:block;box-sizing:border-box;position:absolute;z-index:1000;top:1rem;right:1rem;margin:0;padding:0;width:1.5rem;height:1.5rem;border:0;color:black;border-radius:1.5rem;background:white;box-shadow:0 0 0 1px black;transition:transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);-webkit-appearance:none}.close.svelte-7x8jg:before,.close.svelte-7x8jg:after{content:'';display:block;box-sizing:border-box;position:absolute;top:50%;width:1rem;height:1px;background:black;transform-origin:center;transition:height 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1)}.close.svelte-7x8jg:before{-webkit-transform:translate(0, -50%) rotate(45deg);-moz-transform:translate(0, -50%) rotate(45deg);transform:translate(0, -50%) rotate(45deg);left:0.25rem}.close.svelte-7x8jg:after{-webkit-transform:translate(0, -50%) rotate(-45deg);-moz-transform:translate(0, -50%) rotate(-45deg);transform:translate(0, -50%) rotate(-45deg);left:0.25rem}.close.svelte-7x8jg:hover{background:black}.close.svelte-7x8jg:hover:before,.close.svelte-7x8jg:hover:after{height:2px;background:white}.close.svelte-7x8jg:focus{border-color:#3399ff;box-shadow:0 0 0 2px #3399ff}.close.svelte-7x8jg:active{transform:scale(0.9)}.close.svelte-7x8jg:hover,.close.svelte-7x8jg:focus,.close.svelte-7x8jg:active{outline:none}.svelte-7x8jg{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtnQkUsYUFBRSxDQUFBLEFBQ0EsVUFBVSxDQUFFLFVBQVUsQUFDeEIsQ0FBQSxBQUVBLEdBQUcsYUFBQyxDQUFBLEFBQ0YsUUFBUSxDQUFFLEtBQUssQ0FDZixPQUFPLENBQUUsSUFBSSxDQUNiLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLEtBQUssQ0FBRSxLQUFLLENBQ1osTUFBTSxDQUFFLEtBQUssQ0FDYixVQUFVLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQUFDakMsQ0FBQSxBQUVBLFVBQVUsQ0FBQyx1QkFBdUIsSUFBSSxDQUFDLEFBQUMsQ0FBQSxBQUt4QyxDQUFBLEFBRUEsS0FBSyxhQUFDLENBQUEsQUFDSixRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsSUFBSSxDQUNaLFVBQVUsQ0FBRSxJQUFJLEFBQ2xCLENBQUEsQUFFQSxPQUFPLGFBQUMsQ0FBQSxBQUNOLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxLQUFLLENBQ1osU0FBUyxDQUFFLElBQUksQ0FDZixVQUFVLENBQUUsSUFBSSxDQUNoQixNQUFNLENBQUUsSUFBSSxDQUFDLElBQUksQ0FDakIsS0FBSyxDQUFFLEtBQUssQ0FDWixhQUFhLENBQUUsTUFBTSxDQUNyQixVQUFVLENBQUUsS0FBSyxBQUNuQixDQUFBLEFBRUEsUUFBUSxhQUFDLENBQUEsQUFDUCxRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLFVBQVUsQ0FBRSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQzlCLFFBQVEsQ0FBRSxJQUFJLEFBQ2hCLENBQUEsQUFFQSxNQUFNLGFBQUMsQ0FBQSxBQUNMLE9BQU8sQ0FBRSxLQUFLLENBQ2QsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLElBQUksQ0FDYixHQUFHLENBQUUsSUFBSSxDQUNULEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLENBQUMsQ0FDVCxPQUFPLENBQUUsQ0FBQyxDQUNWLEtBQUssQ0FBRSxNQUFNLENBQ2IsTUFBTSxDQUFFLE1BQU0sQ0FDZCxNQUFNLENBQUUsQ0FBQyxDQUNULEtBQUssQ0FBRSxLQUFLLENBQ1osYUFBYSxDQUFFLE1BQU0sQ0FDckIsVUFBVSxDQUFFLEtBQUssQ0FDakIsVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQzNCLFVBQVUsQ0FBRSxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7TUFDekQsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNsRCxrQkFBa0IsQ0FBRSxJQUFJLEFBQzFCLENBQUEsQUFFQSxtQkFBTSxPQUFPLENBQ2IsbUJBQU0sTUFBTSxBQUFDLENBQUEsQUFDWCxPQUFPLENBQUUsRUFBRSxDQUNYLE9BQU8sQ0FBRSxLQUFLLENBQ2QsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLEdBQUcsQ0FDUixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxHQUFHLENBQ1gsVUFBVSxDQUFFLEtBQUssQ0FDakIsZ0JBQWdCLENBQUUsTUFBTSxDQUN4QixVQUFVLENBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO01BQ3RELFVBQVUsQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDcEQsQ0FBQSxBQUVBLG1CQUFNLE9BQU8sQUFBQyxDQUFBLEFBQ1osaUJBQWlCLENBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUNuRCxjQUFjLENBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUNoRCxTQUFTLENBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUMzQyxJQUFJLENBQUUsT0FBTyxBQUNmLENBQUEsQUFFQSxtQkFBTSxNQUFNLEFBQUMsQ0FBQSxBQUNYLGlCQUFpQixDQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FDcEQsY0FBYyxDQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FDakQsU0FBUyxDQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FDNUMsSUFBSSxDQUFFLE9BQU8sQUFDZixDQUFBLEFBRUEsbUJBQU0sTUFBTSxBQUFDLENBQUEsQUFDWCxVQUFVLENBQUUsS0FBSyxBQUNuQixDQUFBLEFBRUEsbUJBQU0sTUFBTSxPQUFPLENBQ25CLG1CQUFNLE1BQU0sTUFBTSxBQUFDLENBQUEsQUFDakIsTUFBTSxDQUFFLEdBQUcsQ0FDWCxVQUFVLENBQUUsS0FBSyxBQUNuQixDQUFBLEFBRUEsbUJBQU0sTUFBTSxBQUFDLENBQUEsQUFDWCxZQUFZLENBQUUsT0FBTyxDQUNyQixVQUFVLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQUFDL0IsQ0FBQSxBQUVBLG1CQUFNLE9BQU8sQUFBQyxDQUFBLEFBQ1osU0FBUyxDQUFFLE1BQU0sR0FBRyxDQUFDLEFBQ3ZCLENBQUEsQUFFQSxtQkFBTSxNQUFNLENBQ1osbUJBQU0sTUFBTSxDQUNaLG1CQUFNLE9BQU8sQUFBQyxDQUFBLEFBQ1osT0FBTyxDQUFFLElBQUksQUFDZixDQUFBLGVBQ0YiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTW9kYWwuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let div3;
  let div2;
  let div1;
  let t;
  let div0;
  let switch_instance;
  let div0_class_value;
  let div1_class_value;
  let div1_aria_label_value;
  let div1_aria_labelledby_value;
  let div1_transition;
  let div2_class_value;
  let div3_class_value;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1].closeButton && create_if_block_1(ctx);
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {
        class: true,
        role: true,
        "aria-modal": true,
        "aria-label": true,
        "aria-labelledby": true,
        style: true
      });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      var div0_nodes = children(div0);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = null_to_empty(ctx[1].classContent) + " svelte-7x8jg");
      attr_dev(div0, "style", ctx[9]);
      toggle_class(div0, "content", !ctx[0]);
      add_location(div0, file, 500, 8, 13630);
      attr_dev(div1, "class", div1_class_value = null_to_empty(ctx[1].classWindow) + " svelte-7x8jg");
      attr_dev(div1, "role", "dialog");
      attr_dev(div1, "aria-modal", "true");
      attr_dev(div1, "aria-label", div1_aria_label_value = ctx[1].ariaLabelledBy ? null : ctx[1].ariaLabel || null);
      attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = ctx[1].ariaLabelledBy || null);
      attr_dev(div1, "style", ctx[8]);
      toggle_class(div1, "window", !ctx[0]);
      add_location(div1, file, 471, 6, 12655);
      attr_dev(div2, "class", div2_class_value = null_to_empty(ctx[1].classWindowWrap) + " svelte-7x8jg");
      attr_dev(div2, "style", ctx[7]);
      toggle_class(div2, "wrap", !ctx[0]);
      add_location(div2, file, 465, 4, 12522);
      attr_dev(div3, "class", div3_class_value = null_to_empty(ctx[1].classBg) + " svelte-7x8jg");
      attr_dev(div3, "style", ctx[6]);
      toggle_class(div3, "bg", !ctx[0]);
      add_location(div3, file, 456, 2, 12276);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      ctx[49](div1);
      ctx[50](div2);
      ctx[51](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "introstart",
            function() {
              if (is_function(ctx[13]))
                ctx[13].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "outrostart",
            function() {
              if (is_function(ctx[14]))
                ctx[14].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "introend",
            function() {
              if (is_function(ctx[15]))
                ctx[15].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "outroend",
            function() {
              if (is_function(ctx[16]))
                ctx[16].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(div3, "mousedown", ctx[20], false, false, false),
          listen_dev(div3, "mouseup", ctx[21], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[1].closeButton) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (switch_value !== (switch_value = ctx[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty[0] & 2 && div0_class_value !== (div0_class_value = null_to_empty(ctx[1].classContent) + " svelte-7x8jg")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & 512) {
        attr_dev(div0, "style", ctx[9]);
      }
      if (!current || dirty[0] & 3) {
        toggle_class(div0, "content", !ctx[0]);
      }
      if (!current || dirty[0] & 2 && div1_class_value !== (div1_class_value = null_to_empty(ctx[1].classWindow) + " svelte-7x8jg")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & 2 && div1_aria_label_value !== (div1_aria_label_value = ctx[1].ariaLabelledBy ? null : ctx[1].ariaLabel || null)) {
        attr_dev(div1, "aria-label", div1_aria_label_value);
      }
      if (!current || dirty[0] & 2 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = ctx[1].ariaLabelledBy || null)) {
        attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
      }
      if (!current || dirty[0] & 256) {
        attr_dev(div1, "style", ctx[8]);
      }
      if (!current || dirty[0] & 3) {
        toggle_class(div1, "window", !ctx[0]);
      }
      if (!current || dirty[0] & 2 && div2_class_value !== (div2_class_value = null_to_empty(ctx[1].classWindowWrap) + " svelte-7x8jg")) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & 128) {
        attr_dev(div2, "style", ctx[7]);
      }
      if (!current || dirty[0] & 3) {
        toggle_class(div2, "wrap", !ctx[0]);
      }
      if (!current || dirty[0] & 2 && div3_class_value !== (div3_class_value = null_to_empty(ctx[1].classBg) + " svelte-7x8jg")) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & 64) {
        attr_dev(div3, "style", ctx[6]);
      }
      if (!current || dirty[0] & 3) {
        toggle_class(div3, "bg", !ctx[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      add_render_callback(() => {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, ctx[12], ctx[1].transitionWindowProps, true);
        div1_transition.run(1);
      });
      add_render_callback(() => {
        if (!div3_transition)
          div3_transition = create_bidirectional_transition(div3, ctx[11], ctx[1].transitionBgProps, true);
        div3_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, ctx[12], ctx[1].transitionWindowProps, false);
      div1_transition.run(0);
      if (!div3_transition)
        div3_transition = create_bidirectional_transition(div3, ctx[11], ctx[1].transitionBgProps, false);
      div3_transition.run(0);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block)
        if_block.d();
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[49](null);
      if (detaching && div1_transition)
        div1_transition.end();
      ctx[50](null);
      ctx[51](null);
      if (detaching && div3_transition)
        div3_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(456:0) {#if Component}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & 2)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[17](ctx2[1].closeButton);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(487:8) {#if state.closeButton}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let button;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        style: true,
        type: true
      });
      children(button).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = null_to_empty(ctx[1].classCloseButton) + " svelte-7x8jg");
      attr_dev(button, "aria-label", "Close modal");
      attr_dev(button, "style", ctx[10]);
      attr_dev(button, "type", "button");
      toggle_class(button, "close", !ctx[0]);
      add_location(button, file, 490, 12, 13351);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[18], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2 && button_class_value !== (button_class_value = null_to_empty(ctx2[1].classCloseButton) + " svelte-7x8jg")) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & 1024) {
        attr_dev(button, "style", ctx2[10]);
      }
      if (dirty[0] & 3) {
        toggle_class(button, "close", !ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(490:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[1].closeButton;
  function switch_props(ctx2) {
    return {
      props: { onClose: ctx2[18] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[1].closeButton)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(488:10) {#if isFunction(state.closeButton)}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block(ctx);
  const default_slot_template = ctx[48].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[47], null);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(window_1, "keydown", ctx[19], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[47],
            !current ? get_all_dirty_from_scope(ctx2[47]) : get_slot_changes(default_slot_template, ctx2[47], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function bind2(Component, props = {}) {
  return function ModalComponent(options) {
    return new Component({
      ...options,
      props: { ...props, ...options.props }
    });
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["default"]);
  const dispatch = createEventDispatcher();
  const baseSetContext = setContext;
  const baseIsTabbable = (node) => node.tabIndex >= 0 && !node.hidden && !node.disabled && node.style.display !== "none" && node.type !== "hidden" && Boolean(node.offsetWidth || node.offsetHeight || node.getClientRects().length);
  let { isTabbable = baseIsTabbable } = $$props;
  let { show = null } = $$props;
  let { key = "simple-modal" } = $$props;
  let { ariaLabel = null } = $$props;
  let { ariaLabelledBy = null } = $$props;
  let { closeButton = true } = $$props;
  let { closeOnEsc = true } = $$props;
  let { closeOnOuterClick = true } = $$props;
  let { styleBg = {} } = $$props;
  let { styleWindowWrap = {} } = $$props;
  let { styleWindow = {} } = $$props;
  let { styleContent = {} } = $$props;
  let { styleCloseButton = {} } = $$props;
  let { classBg = null } = $$props;
  let { classWindowWrap = null } = $$props;
  let { classWindow = null } = $$props;
  let { classContent = null } = $$props;
  let { classCloseButton = null } = $$props;
  let { unstyled = false } = $$props;
  let { setContext: setContext2 = baseSetContext } = $$props;
  let { transitionBg = fade } = $$props;
  let { transitionBgProps = { duration: 250 } } = $$props;
  let { transitionWindow = transitionBg } = $$props;
  let { transitionWindowProps = transitionBgProps } = $$props;
  let { disableFocusTrap = false } = $$props;
  const defaultState = {
    ariaLabel,
    ariaLabelledBy,
    closeButton,
    closeOnEsc,
    closeOnOuterClick,
    styleBg,
    styleWindowWrap,
    styleWindow,
    styleContent,
    styleCloseButton,
    classBg,
    classWindowWrap,
    classWindow,
    classContent,
    classCloseButton,
    transitionBg,
    transitionBgProps,
    transitionWindow,
    transitionWindowProps,
    disableFocusTrap,
    isTabbable,
    unstyled
  };
  let state = { ...defaultState };
  let Component = null;
  let background;
  let wrap;
  let modalWindow;
  let scrollY;
  let cssBg;
  let cssWindowWrap;
  let cssWindow;
  let cssContent;
  let cssCloseButton;
  let currentTransitionBg;
  let currentTransitionWindow;
  let prevBodyPosition;
  let prevBodyOverflow;
  let prevBodyWidth;
  let outerClickTarget;
  const camelCaseToDash = (str) => str.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
  const toCssString = (props) => props ? Object.keys(props).reduce((str, key2) => `${str}; ${camelCaseToDash(key2)}: ${props[key2]}`, "") : "";
  const isFunction = (f) => !!(f && f.constructor && f.call && f.apply);
  const updateStyleTransition = () => {
    $$invalidate(6, cssBg = toCssString(Object.assign(
      {},
      {
        width: window.innerWidth,
        height: window.innerHeight
      },
      state.styleBg
    )));
    $$invalidate(7, cssWindowWrap = toCssString(state.styleWindowWrap));
    $$invalidate(8, cssWindow = toCssString(state.styleWindow));
    $$invalidate(9, cssContent = toCssString(state.styleContent));
    $$invalidate(10, cssCloseButton = toCssString(state.styleCloseButton));
    $$invalidate(11, currentTransitionBg = state.transitionBg);
    $$invalidate(12, currentTransitionWindow = state.transitionWindow);
  };
  const toVoid = () => {
  };
  let onOpen = toVoid;
  let onClose = toVoid;
  let onOpened = toVoid;
  let onClosed = toVoid;
  const open = (NewComponent, newProps = {}, options = {}, callbacks = {}) => {
    $$invalidate(2, Component = bind2(NewComponent, newProps));
    $$invalidate(1, state = { ...defaultState, ...options });
    updateStyleTransition();
    disableScroll();
    $$invalidate(13, onOpen = (event) => {
      if (callbacks.onOpen)
        callbacks.onOpen(event);
      dispatch("open");
      dispatch("opening");
    });
    $$invalidate(14, onClose = (event) => {
      if (callbacks.onClose)
        callbacks.onClose(event);
      dispatch("close");
      dispatch("closing");
    });
    $$invalidate(15, onOpened = (event) => {
      if (callbacks.onOpened)
        callbacks.onOpened(event);
      dispatch("opened");
    });
    $$invalidate(16, onClosed = (event) => {
      if (callbacks.onClosed)
        callbacks.onClosed(event);
      dispatch("closed");
    });
  };
  const close = (callbacks = {}) => {
    if (!Component)
      return;
    $$invalidate(14, onClose = callbacks.onClose || onClose);
    $$invalidate(16, onClosed = callbacks.onClosed || onClosed);
    $$invalidate(2, Component = null);
    enableScroll();
  };
  const handleKeydown = (event) => {
    if (state.closeOnEsc && Component && event.key === "Escape") {
      event.preventDefault();
      close();
    }
    if (Component && event.key === "Tab" && !state.disableFocusTrap) {
      const nodes = modalWindow.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter(state.isTabbable).sort((a, b) => a.tabIndex - b.tabIndex);
      let index = tabbable.indexOf(document.activeElement);
      if (index === -1 && event.shiftKey)
        index = 0;
      index += tabbable.length + (event.shiftKey ? -1 : 1);
      index %= tabbable.length;
      tabbable[index].focus();
      event.preventDefault();
    }
  };
  const handleOuterMousedown = (event) => {
    if (state.closeOnOuterClick && (event.target === background || event.target === wrap))
      outerClickTarget = event.target;
  };
  const handleOuterMouseup = (event) => {
    if (state.closeOnOuterClick && event.target === outerClickTarget) {
      event.preventDefault();
      close();
    }
  };
  const disableScroll = () => {
    scrollY = window.scrollY;
    prevBodyPosition = document.body.style.position;
    prevBodyOverflow = document.body.style.overflow;
    prevBodyWidth = document.body.style.width;
    document.body.style.position = "fixed";
    document.body.style.top = `-${scrollY}px`;
    document.body.style.overflow = "hidden";
    document.body.style.width = "100%";
  };
  const enableScroll = () => {
    document.body.style.position = prevBodyPosition || "";
    document.body.style.top = "";
    document.body.style.overflow = prevBodyOverflow || "";
    document.body.style.width = prevBodyWidth || "";
    window.scrollTo(0, scrollY);
  };
  const context = { open, close };
  setContext2(key, context);
  let isMounted = false;
  onDestroy(() => {
    if (isMounted)
      close();
  });
  onMount(() => {
    $$invalidate(46, isMounted = true);
  });
  const writable_props = [
    "isTabbable",
    "show",
    "key",
    "ariaLabel",
    "ariaLabelledBy",
    "closeButton",
    "closeOnEsc",
    "closeOnOuterClick",
    "styleBg",
    "styleWindowWrap",
    "styleWindow",
    "styleContent",
    "styleCloseButton",
    "classBg",
    "classWindowWrap",
    "classWindow",
    "classContent",
    "classCloseButton",
    "unstyled",
    "setContext",
    "transitionBg",
    "transitionBgProps",
    "transitionWindow",
    "transitionWindowProps",
    "disableFocusTrap"
  ];
  Object_1.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Modal> was created with unknown prop '${key2}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalWindow = $$value;
      $$invalidate(5, modalWindow);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrap = $$value;
      $$invalidate(4, wrap);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      background = $$value;
      $$invalidate(3, background);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("isTabbable" in $$props2)
      $$invalidate(22, isTabbable = $$props2.isTabbable);
    if ("show" in $$props2)
      $$invalidate(23, show = $$props2.show);
    if ("key" in $$props2)
      $$invalidate(24, key = $$props2.key);
    if ("ariaLabel" in $$props2)
      $$invalidate(25, ariaLabel = $$props2.ariaLabel);
    if ("ariaLabelledBy" in $$props2)
      $$invalidate(26, ariaLabelledBy = $$props2.ariaLabelledBy);
    if ("closeButton" in $$props2)
      $$invalidate(27, closeButton = $$props2.closeButton);
    if ("closeOnEsc" in $$props2)
      $$invalidate(28, closeOnEsc = $$props2.closeOnEsc);
    if ("closeOnOuterClick" in $$props2)
      $$invalidate(29, closeOnOuterClick = $$props2.closeOnOuterClick);
    if ("styleBg" in $$props2)
      $$invalidate(30, styleBg = $$props2.styleBg);
    if ("styleWindowWrap" in $$props2)
      $$invalidate(31, styleWindowWrap = $$props2.styleWindowWrap);
    if ("styleWindow" in $$props2)
      $$invalidate(32, styleWindow = $$props2.styleWindow);
    if ("styleContent" in $$props2)
      $$invalidate(33, styleContent = $$props2.styleContent);
    if ("styleCloseButton" in $$props2)
      $$invalidate(34, styleCloseButton = $$props2.styleCloseButton);
    if ("classBg" in $$props2)
      $$invalidate(35, classBg = $$props2.classBg);
    if ("classWindowWrap" in $$props2)
      $$invalidate(36, classWindowWrap = $$props2.classWindowWrap);
    if ("classWindow" in $$props2)
      $$invalidate(37, classWindow = $$props2.classWindow);
    if ("classContent" in $$props2)
      $$invalidate(38, classContent = $$props2.classContent);
    if ("classCloseButton" in $$props2)
      $$invalidate(39, classCloseButton = $$props2.classCloseButton);
    if ("unstyled" in $$props2)
      $$invalidate(0, unstyled = $$props2.unstyled);
    if ("setContext" in $$props2)
      $$invalidate(40, setContext2 = $$props2.setContext);
    if ("transitionBg" in $$props2)
      $$invalidate(41, transitionBg = $$props2.transitionBg);
    if ("transitionBgProps" in $$props2)
      $$invalidate(42, transitionBgProps = $$props2.transitionBgProps);
    if ("transitionWindow" in $$props2)
      $$invalidate(43, transitionWindow = $$props2.transitionWindow);
    if ("transitionWindowProps" in $$props2)
      $$invalidate(44, transitionWindowProps = $$props2.transitionWindowProps);
    if ("disableFocusTrap" in $$props2)
      $$invalidate(45, disableFocusTrap = $$props2.disableFocusTrap);
    if ("$$scope" in $$props2)
      $$invalidate(47, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    bind: bind2,
    svelte: svelte_exports,
    fade,
    createEventDispatcher,
    dispatch,
    baseSetContext,
    baseIsTabbable,
    isTabbable,
    show,
    key,
    ariaLabel,
    ariaLabelledBy,
    closeButton,
    closeOnEsc,
    closeOnOuterClick,
    styleBg,
    styleWindowWrap,
    styleWindow,
    styleContent,
    styleCloseButton,
    classBg,
    classWindowWrap,
    classWindow,
    classContent,
    classCloseButton,
    unstyled,
    setContext: setContext2,
    transitionBg,
    transitionBgProps,
    transitionWindow,
    transitionWindowProps,
    disableFocusTrap,
    defaultState,
    state,
    Component,
    background,
    wrap,
    modalWindow,
    scrollY,
    cssBg,
    cssWindowWrap,
    cssWindow,
    cssContent,
    cssCloseButton,
    currentTransitionBg,
    currentTransitionWindow,
    prevBodyPosition,
    prevBodyOverflow,
    prevBodyWidth,
    outerClickTarget,
    camelCaseToDash,
    toCssString,
    isFunction,
    updateStyleTransition,
    toVoid,
    onOpen,
    onClose,
    onOpened,
    onClosed,
    open,
    close,
    handleKeydown,
    handleOuterMousedown,
    handleOuterMouseup,
    disableScroll,
    enableScroll,
    context,
    isMounted
  });
  $$self.$inject_state = ($$props2) => {
    if ("isTabbable" in $$props2)
      $$invalidate(22, isTabbable = $$props2.isTabbable);
    if ("show" in $$props2)
      $$invalidate(23, show = $$props2.show);
    if ("key" in $$props2)
      $$invalidate(24, key = $$props2.key);
    if ("ariaLabel" in $$props2)
      $$invalidate(25, ariaLabel = $$props2.ariaLabel);
    if ("ariaLabelledBy" in $$props2)
      $$invalidate(26, ariaLabelledBy = $$props2.ariaLabelledBy);
    if ("closeButton" in $$props2)
      $$invalidate(27, closeButton = $$props2.closeButton);
    if ("closeOnEsc" in $$props2)
      $$invalidate(28, closeOnEsc = $$props2.closeOnEsc);
    if ("closeOnOuterClick" in $$props2)
      $$invalidate(29, closeOnOuterClick = $$props2.closeOnOuterClick);
    if ("styleBg" in $$props2)
      $$invalidate(30, styleBg = $$props2.styleBg);
    if ("styleWindowWrap" in $$props2)
      $$invalidate(31, styleWindowWrap = $$props2.styleWindowWrap);
    if ("styleWindow" in $$props2)
      $$invalidate(32, styleWindow = $$props2.styleWindow);
    if ("styleContent" in $$props2)
      $$invalidate(33, styleContent = $$props2.styleContent);
    if ("styleCloseButton" in $$props2)
      $$invalidate(34, styleCloseButton = $$props2.styleCloseButton);
    if ("classBg" in $$props2)
      $$invalidate(35, classBg = $$props2.classBg);
    if ("classWindowWrap" in $$props2)
      $$invalidate(36, classWindowWrap = $$props2.classWindowWrap);
    if ("classWindow" in $$props2)
      $$invalidate(37, classWindow = $$props2.classWindow);
    if ("classContent" in $$props2)
      $$invalidate(38, classContent = $$props2.classContent);
    if ("classCloseButton" in $$props2)
      $$invalidate(39, classCloseButton = $$props2.classCloseButton);
    if ("unstyled" in $$props2)
      $$invalidate(0, unstyled = $$props2.unstyled);
    if ("setContext" in $$props2)
      $$invalidate(40, setContext2 = $$props2.setContext);
    if ("transitionBg" in $$props2)
      $$invalidate(41, transitionBg = $$props2.transitionBg);
    if ("transitionBgProps" in $$props2)
      $$invalidate(42, transitionBgProps = $$props2.transitionBgProps);
    if ("transitionWindow" in $$props2)
      $$invalidate(43, transitionWindow = $$props2.transitionWindow);
    if ("transitionWindowProps" in $$props2)
      $$invalidate(44, transitionWindowProps = $$props2.transitionWindowProps);
    if ("disableFocusTrap" in $$props2)
      $$invalidate(45, disableFocusTrap = $$props2.disableFocusTrap);
    if ("state" in $$props2)
      $$invalidate(1, state = $$props2.state);
    if ("Component" in $$props2)
      $$invalidate(2, Component = $$props2.Component);
    if ("background" in $$props2)
      $$invalidate(3, background = $$props2.background);
    if ("wrap" in $$props2)
      $$invalidate(4, wrap = $$props2.wrap);
    if ("modalWindow" in $$props2)
      $$invalidate(5, modalWindow = $$props2.modalWindow);
    if ("scrollY" in $$props2)
      scrollY = $$props2.scrollY;
    if ("cssBg" in $$props2)
      $$invalidate(6, cssBg = $$props2.cssBg);
    if ("cssWindowWrap" in $$props2)
      $$invalidate(7, cssWindowWrap = $$props2.cssWindowWrap);
    if ("cssWindow" in $$props2)
      $$invalidate(8, cssWindow = $$props2.cssWindow);
    if ("cssContent" in $$props2)
      $$invalidate(9, cssContent = $$props2.cssContent);
    if ("cssCloseButton" in $$props2)
      $$invalidate(10, cssCloseButton = $$props2.cssCloseButton);
    if ("currentTransitionBg" in $$props2)
      $$invalidate(11, currentTransitionBg = $$props2.currentTransitionBg);
    if ("currentTransitionWindow" in $$props2)
      $$invalidate(12, currentTransitionWindow = $$props2.currentTransitionWindow);
    if ("prevBodyPosition" in $$props2)
      prevBodyPosition = $$props2.prevBodyPosition;
    if ("prevBodyOverflow" in $$props2)
      prevBodyOverflow = $$props2.prevBodyOverflow;
    if ("prevBodyWidth" in $$props2)
      prevBodyWidth = $$props2.prevBodyWidth;
    if ("outerClickTarget" in $$props2)
      outerClickTarget = $$props2.outerClickTarget;
    if ("onOpen" in $$props2)
      $$invalidate(13, onOpen = $$props2.onOpen);
    if ("onClose" in $$props2)
      $$invalidate(14, onClose = $$props2.onClose);
    if ("onOpened" in $$props2)
      $$invalidate(15, onOpened = $$props2.onOpened);
    if ("onClosed" in $$props2)
      $$invalidate(16, onClosed = $$props2.onClosed);
    if ("isMounted" in $$props2)
      $$invalidate(46, isMounted = $$props2.isMounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8388608 | $$self.$$.dirty[1] & 32768) {
      $: {
        if (isMounted) {
          if (isFunction(show)) {
            open(show);
          } else {
            close();
          }
        }
      }
    }
  };
  return [
    unstyled,
    state,
    Component,
    background,
    wrap,
    modalWindow,
    cssBg,
    cssWindowWrap,
    cssWindow,
    cssContent,
    cssCloseButton,
    currentTransitionBg,
    currentTransitionWindow,
    onOpen,
    onClose,
    onOpened,
    onClosed,
    isFunction,
    close,
    handleKeydown,
    handleOuterMousedown,
    handleOuterMouseup,
    isTabbable,
    show,
    key,
    ariaLabel,
    ariaLabelledBy,
    closeButton,
    closeOnEsc,
    closeOnOuterClick,
    styleBg,
    styleWindowWrap,
    styleWindow,
    styleContent,
    styleCloseButton,
    classBg,
    classWindowWrap,
    classWindow,
    classContent,
    classCloseButton,
    setContext2,
    transitionBg,
    transitionBgProps,
    transitionWindow,
    transitionWindowProps,
    disableFocusTrap,
    isMounted,
    $$scope,
    slots,
    div1_binding,
    div2_binding,
    div3_binding
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        isTabbable: 22,
        show: 23,
        key: 24,
        ariaLabel: 25,
        ariaLabelledBy: 26,
        closeButton: 27,
        closeOnEsc: 28,
        closeOnOuterClick: 29,
        styleBg: 30,
        styleWindowWrap: 31,
        styleWindow: 32,
        styleContent: 33,
        styleCloseButton: 34,
        classBg: 35,
        classWindowWrap: 36,
        classWindow: 37,
        classContent: 38,
        classCloseButton: 39,
        unstyled: 0,
        setContext: 40,
        transitionBg: 41,
        transitionBgProps: 42,
        transitionWindow: 43,
        transitionWindowProps: 44,
        disableFocusTrap: 45
      },
      add_css,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment.name
    });
  }
  get isTabbable() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isTabbable(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get show() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabelledBy() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabelledBy(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButton() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButton(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEsc() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEsc(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOuterClick() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOuterClick(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleBg() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleBg(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleWindowWrap() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleWindowWrap(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleWindow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleWindow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleContent() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleContent(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleCloseButton() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleCloseButton(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classBg() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classBg(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classWindowWrap() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classWindowWrap(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classWindow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classWindow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classContent() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classContent(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classCloseButton() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classCloseButton(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unstyled() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unstyled(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setContext() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set setContext(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionBg() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionBg(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionBgProps() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionBgProps(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionWindow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionWindow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionWindowProps() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionWindowProps(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableFocusTrap() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableFocusTrap(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// ../node_modules/svelte-simple-modal/src/index.js
var src_default = Modal_default;

// ../node_modules/svelte-jsoneditor/constants.js
var SCROLL_DURATION = 300;
var DEBOUNCE_DELAY = 300;
var TEXT_MODE_ONCHANGE_DELAY = 300;
var SEARCH_UPDATE_THROTTLE = 300;
var AUTO_SCROLL_INTERVAL = 50;
var AUTO_SCROLL_SPEED_SLOW = 200;
var AUTO_SCROLL_SPEED_NORMAL = 400;
var AUTO_SCROLL_SPEED_FAST = 1200;
var MAX_SEARCH_RESULTS = 1e3;
var ARRAY_SECTION_SIZE = 100;
var MAX_VALIDATION_ERRORS = 100;
var MAX_CHARACTERS_TEXT_PREVIEW = 2e4;
var DEFAULT_VISIBLE_SECTIONS = [{ start: 0, end: ARRAY_SECTION_SIZE }];
var MAX_VALIDATABLE_SIZE = 100 * 1024 * 1024;
var MAX_AUTO_REPAIRABLE_SIZE = 1024 * 1024;
var MAX_DOCUMENT_SIZE_TEXT_MODE = 10 * 1024 * 1024;
var MAX_DOCUMENT_SIZE_EXPAND_ALL = 10 * 1024;
var SIMPLE_MODAL_OPTIONS = {
  closeButton: false,
  classBg: "jse-modal-bg",
  classWindow: "jse-modal-window",
  classWindowWrap: "jse-modal-window-wrap",
  classContent: "jse-modal-content"
};
var SORT_MODAL_OPTIONS = {
  ...SIMPLE_MODAL_OPTIONS,
  classWindow: "jse-modal-window jse-modal-window-sort"
};
var TRANSFORM_MODAL_OPTIONS = {
  ...SIMPLE_MODAL_OPTIONS,
  classWindow: "jse-modal-window jse-modal-window-transform"
};
var INSERT_EXPLANATION = "Insert or paste contents, enter [ insert a new array, enter { to insert a new object, or start typing to insert a new value";
var CONTEXT_MENU_EXPLANATION = "Open context menu (Click here, right click on the selection, or use the context menu button or Ctrl+Q)";
var HOVER_INSERT_INSIDE = "hover-insert-inside";
var HOVER_INSERT_AFTER = "hover-insert-after";
var HOVER_COLLECTION = "hover-collection";
var JSON_STATUS_VALID = "valid";
var JSON_STATUS_REPAIRABLE = "repairable";
var JSON_STATUS_INVALID = "invalid";
var CONTEXT_MENU_HEIGHT = (40 + 2) * 8;
var CONTEXT_MENU_WIDTH = 260;
var UPDATE_SELECTION = {
  NO: "NO",
  SELF: "SELF",
  NEXT_INSIDE: "NEXT_INSIDE"
};

// ../node_modules/svelte-jsoneditor/utils/uniqueId.js
var id = 0;
function uniqueId() {
  id++;
  return id;
}

// ../node_modules/svelte-jsoneditor/utils/jsonUtils.js
var import_json_source_map = __toESM(require_json_source_map(), 1);

// ../node_modules/svelte-jsoneditor/utils/numberUtils.js
function int(value) {
  return parseInt(value, 10);
}
function isNumber(value) {
  return NUMBER_REGEX.test(value);
}
var NUMBER_REGEX = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;

// ../node_modules/svelte-jsoneditor/utils/typeUtils.js
function isObject(value) {
  return typeof value === "object" && value !== null && value.constructor === Object;
}
function isObjectOrArray(value) {
  return typeof value === "object" && value !== null && (value.constructor === Object || value.constructor === Array);
}
function isBoolean(value) {
  return value === true || value === false;
}
function isTimestamp(value) {
  const YEAR_2000 = 9466848e5;
  if (typeof value === "number") {
    return value > YEAR_2000 && isFinite(value) && Math.floor(value) === value && !isNaN(new Date(value).valueOf());
  }
  if (typeof value === "bigint") {
    return isTimestamp(Number(value));
  }
  try {
    const valueOf = value.valueOf();
    if (valueOf !== value) {
      return isTimestamp(valueOf);
    }
  } catch (err) {
    return false;
  }
}
function getColorCSS(color) {
  const colorStyleElement = window.document.createElement("div");
  colorStyleElement.style.color = color;
  return colorStyleElement.style.color.split(/\s+/).join("").toLowerCase() || null;
}
function isColor(value) {
  return typeof value === "string" && !!getColorCSS(value);
}
function valueType(value, parser) {
  if (typeof value === "number" || typeof value === "string" || typeof value === "boolean" || typeof value === "undefined") {
    return typeof value;
  }
  if (typeof value === "bigint") {
    return "number";
  }
  if (value === null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "array";
  }
  if (isObject(value)) {
    return "object";
  }
  const valueStr = parser.stringify(value);
  if (valueStr && isNumber(valueStr)) {
    return "number";
  }
  if (valueStr === "true" || valueStr === "false") {
    return "boolean";
  }
  if (valueStr === "null") {
    return "null";
  }
  return "unknown";
}
var isUrlRegex = /^https?:\/\/\S+$/;
function isUrl(text2) {
  return typeof text2 === "string" && isUrlRegex.test(text2);
}
function stringConvert(str, parser) {
  if (str === "") {
    return "";
  }
  const strTrim = str.trim();
  if (strTrim === "null") {
    return null;
  }
  if (strTrim === "true") {
    return true;
  }
  if (strTrim === "false") {
    return false;
  }
  if (isNumber(strTrim)) {
    return parser.parse(strTrim);
  }
  return str;
}
function isStringContainingPrimitiveValue(str, parser) {
  return typeof str === "string" && typeof stringConvert(str, parser) !== "string";
}
function isInteger(value) {
  return INTEGER_REGEX.test(value);
}
var INTEGER_REGEX = /^-?[0-9]+$/;

// ../node_modules/svelte-jsoneditor/utils/arrayUtils.js
var MAX_ITEM_PATHS_COLLECTION = 1e4;
var EMPTY_ARRAY = [];
function getNestedPaths(array, includeObjects = false) {
  const pointersMap = {};
  if (!Array.isArray(array)) {
    throw new TypeError("Array expected");
  }
  function recurseNestedPaths(obj, path) {
    const isValue = !Array.isArray(obj) && !isObject(obj);
    if (isValue || includeObjects && path.length > 0) {
      pointersMap[compileJSONPointer(path)] = true;
    }
    if (isObject(obj)) {
      Object.keys(obj).forEach((key) => {
        recurseNestedPaths(obj[key], path.concat(key));
      });
    }
  }
  const max = Math.min(array.length, MAX_ITEM_PATHS_COLLECTION);
  for (let i = 0; i < max; i++) {
    const item = array[i];
    recurseNestedPaths(item, EMPTY_ARRAY);
  }
  const pathsArray = Object.keys(pointersMap).sort();
  return pathsArray.map(parseJSONPointer);
}
function forEachIndex(start, end, iteratee) {
  if (end <= start) {
    return;
  }
  for (let index = start; index < end; index++) {
    iteratee(index);
  }
}
function limit(array, max) {
  return array.length > max ? array.slice(0, max) : array;
}
function arrayToObject(array) {
  return {
    ...array
  };
}
function objectToArray(object) {
  return Object.values(object);
}
function moveItems(array, index, count, offset) {
  const copy = array.slice(0);
  const moving = copy.splice(index, count);
  copy.splice.apply(copy, [index + offset, 0, ...moving]);
  return copy;
}

// ../node_modules/svelte-jsoneditor/utils/jsonUtils.js
function parseAndRepair(jsonText, parser) {
  try {
    return parser.parse(jsonText);
  } catch (err) {
    return parser.parse(jsonrepair(jsonText));
  }
}
function parseAndRepairOrUndefined(partialJson, parser) {
  try {
    return parseAndRepair(partialJson, parser);
  } catch (err) {
    return void 0;
  }
}
function parsePartialJson(partialJson, parse) {
  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, "");
  try {
    return parse(partialJson);
  } catch (err) {
  }
  try {
    return parse("[" + partialJson + "]");
  } catch (err) {
  }
  try {
    return parse("{" + partialJson + "}");
  } catch (err) {
  }
  throw new Error("Failed to parse partial JSON");
}
function repairPartialJson(partialJson) {
  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, "");
  try {
    return jsonrepair(partialJson);
  } catch (err) {
  }
  try {
    const repaired = jsonrepair("[" + partialJson + "]");
    return repaired.substring(1, repaired.length - 1);
  } catch (err) {
  }
  try {
    const repaired = jsonrepair("{" + partialJson + "}");
    return repaired.substring(1, repaired.length - 1);
  } catch (err) {
  }
  throw new Error("Failed to repair partial JSON");
}
var END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX = /,\s*$/;
function normalizeJsonParseError(jsonText, parseErrorMessage) {
  const positionMatch = POSITION_REGEX.exec(parseErrorMessage);
  if (positionMatch) {
    const position = int(positionMatch[2]);
    const line = countCharacterOccurrences(jsonText, "\n", 0, position);
    const lastIndex = jsonText.lastIndexOf("\n", position);
    const column = position - lastIndex - 1;
    return {
      position,
      line,
      column,
      message: parseErrorMessage.replace(POSITION_REGEX, () => {
        return `line ${line + 1} column ${column + 1}`;
      })
    };
  } else {
    const lineMatch = LINE_REGEX.exec(parseErrorMessage);
    const lineOneBased = lineMatch ? int(lineMatch[1]) : null;
    const line = lineOneBased !== null ? lineOneBased - 1 : null;
    const columnMatch = COLUMN_REGEX.exec(parseErrorMessage);
    const columnOneBased = columnMatch ? int(columnMatch[1]) : null;
    const column = columnOneBased !== null ? columnOneBased - 1 : null;
    const position = line !== null && column !== null ? calculatePosition(jsonText, line, column) : null;
    return {
      position,
      line,
      column,
      message: parseErrorMessage.replace(/^JSON.parse: /, "").replace(/ of the JSON data$/, "")
    };
  }
}
function calculatePosition(text2, line, column) {
  let index = text2.indexOf("\n");
  let i = 1;
  while (i < line && index !== -1) {
    index = text2.indexOf("\n", index + 1);
    i++;
  }
  return index !== -1 ? index + column + 1 : null;
}
function countCharacterOccurrences(text2, character, start = 0, end = text2.length) {
  let count = 0;
  for (let i = start; i < end; i++) {
    if (text2.charAt(i) === character) {
      count++;
    }
  }
  return count;
}
function findTextLocation(text2, path) {
  try {
    const jsmap = import_json_source_map.default.parse(text2);
    const pointerName = compileJSONPointer(path);
    const pointer = jsmap.pointers[pointerName];
    if (pointer) {
      return {
        path,
        line: pointer.key ? pointer.key.line : pointer.value ? pointer.value.line : 0,
        column: pointer.key ? pointer.key.column : pointer.value ? pointer.value.column : 0,
        from: pointer.key ? pointer.key.pos : pointer.value ? pointer.value.pos : 0,
        to: pointer.keyEnd ? pointer.keyEnd.pos : pointer.valueEnd ? pointer.valueEnd.pos : 0
      };
    }
  } catch (err) {
    console.error(err);
  }
  return null;
}
function convertValue(value, type, parser) {
  if (type === "array") {
    if (Array.isArray(value)) {
      return value;
    }
    if (isObject(value)) {
      return objectToArray(value);
    }
    if (typeof value === "string") {
      try {
        const parsedValue = parser.parse(value);
        if (Array.isArray(parsedValue)) {
          return parsedValue;
        }
        if (isObject(parsedValue)) {
          return objectToArray(parsedValue);
        }
      } catch (e) {
        return [value];
      }
    }
    return [value];
  }
  if (type === "object") {
    if (Array.isArray(value)) {
      return arrayToObject(value);
    }
    if (isObject(value)) {
      return value;
    }
    if (typeof value === "string") {
      try {
        const parsedValue = parser.parse(value);
        if (isObject(parsedValue)) {
          return parsedValue;
        }
        if (Array.isArray(parsedValue)) {
          return arrayToObject(parsedValue);
        }
      } catch (e) {
        return { value };
      }
    }
    return { value };
  }
  if (type === "value") {
    if (isObjectOrArray(value)) {
      return parser.stringify(value);
    }
    return value;
  }
  throw new Error(`Cannot convert ${valueType(value, parser)} to ${type}`);
}
function validateContentType(content) {
  if (!isObject(content)) {
    return "Content must be an object";
  }
  if (content.json !== void 0) {
    if (content.text !== void 0) {
      return 'Content must contain either a property "json" or a property "text" but not both';
    } else {
      return null;
    }
  } else {
    if (content.text === void 0) {
      return 'Content must contain either a property "json" or a property "text"';
    } else if (typeof content.text !== "string") {
      return 'Content "text" property must be a string containing a JSON document. Did you mean to use the "json" property instead?';
    } else {
      return null;
    }
  }
}
function isContent(content) {
  return isObject(content) && (typeof content.json !== "undefined" || typeof content.text === "string");
}
function isTextContent(content) {
  return isObject(content) && typeof content.text === "string";
}
function isJSONContent(content) {
  return isObject(content) && typeof content.json !== "undefined" && !isTextContent(content);
}
function toTextContent(content, indentation = void 0, parser = JSON) {
  return isTextContent(content) ? content : { text: parser.stringify(content.json, null, indentation) };
}
function toJSONContent(content, parser = JSON) {
  return isJSONContent(content) ? content : { json: parser.parse(content.text) };
}
function getText(content, indentation, parser) {
  return toTextContent(content, indentation, parser).text;
}
function isLargeContent(content, maxSize) {
  return estimateSerializedSize(content, maxSize) > maxSize;
}
function estimateSerializedSize(content, maxSize = Infinity) {
  if (isTextContent(content)) {
    return content.text.length;
  }
  const json2 = content.json;
  let estimatedSize = 0;
  function recurse(json3) {
    if (Array.isArray(json3)) {
      estimatedSize += 2 + (json3.length - 1);
      if (estimatedSize > maxSize) {
        return estimatedSize;
      }
      for (let i = 0; i < json3.length; i++) {
        const item = json3[i];
        recurse(item);
        if (estimatedSize > maxSize) {
          return estimatedSize;
        }
      }
    } else if (isObject(json3)) {
      const keys = Object.keys(json3);
      estimatedSize += 2 + keys.length + (keys.length - 1);
      for (let k = 0; k < keys.length; k++) {
        const key = keys[k];
        const value = json3[key];
        estimatedSize += key.length + 2;
        recurse(value);
      }
    } else if (typeof json3 === "string") {
      estimatedSize += json3.length + 2;
    } else {
      estimatedSize += String(json3).length;
    }
  }
  recurse(json2);
  return estimatedSize;
}
var POSITION_REGEX = /(position|char) (\d+)/;
var LINE_REGEX = /line (\d+)/;
var COLUMN_REGEX = /column (\d+)/;
function isEqualParser(a, b) {
  return a.parse === b.parse && a.stringify === b.stringify;
}

// ../node_modules/svelte-jsoneditor/types.js
var Mode;
(function(Mode2) {
  Mode2["text"] = "text";
  Mode2["tree"] = "tree";
})(Mode || (Mode = {}));
var SelectionType;
(function(SelectionType2) {
  SelectionType2["after"] = "after";
  SelectionType2["inside"] = "inside";
  SelectionType2["key"] = "key";
  SelectionType2["value"] = "value";
  SelectionType2["multi"] = "multi";
})(SelectionType || (SelectionType = {}));
var CaretType;
(function(CaretType2) {
  CaretType2["after"] = "after";
  CaretType2["key"] = "key";
  CaretType2["value"] = "value";
  CaretType2["inside"] = "inside";
})(CaretType || (CaretType = {}));
var ValidationSeverity;
(function(ValidationSeverity2) {
  ValidationSeverity2["info"] = "info";
  ValidationSeverity2["warning"] = "warning";
  ValidationSeverity2["error"] = "error";
})(ValidationSeverity || (ValidationSeverity = {}));
var SearchField;
(function(SearchField2) {
  SearchField2["key"] = "key";
  SearchField2["value"] = "value";
})(SearchField || (SearchField = {}));

// ../node_modules/svelte-jsoneditor/utils/domUtils.js
function createNormalizationFunctions({ escapeControlCharacters, escapeUnicodeCharacters }) {
  if (escapeControlCharacters) {
    if (escapeUnicodeCharacters) {
      return normalizeControlAndUnicode;
    } else {
      return normalizeControl;
    }
  } else {
    if (escapeUnicodeCharacters) {
      return normalizeUnicode;
    } else {
      return normalizeNothing;
    }
  }
}
var normalizeControlAndUnicode = {
  escapeValue: (value) => jsonEscapeUnicode(jsonEscapeControl(String(value))),
  unescapeValue: (value) => jsonUnescapeControl(jsonUnescapeUnicode(value))
};
var normalizeControl = {
  escapeValue: (value) => jsonEscapeControl(String(value)),
  unescapeValue: (value) => jsonUnescapeControl(value)
};
var normalizeUnicode = {
  escapeValue: (value) => jsonEscapeUnicode(String(value)),
  unescapeValue: (value) => jsonUnescapeUnicode(value)
};
var normalizeNothing = {
  escapeValue: (value) => String(value),
  unescapeValue: (value) => value
};
function jsonEscapeUnicode(value) {
  return value.replace(/[^\x20-\x7F]/g, (x) => {
    var _a;
    if (x === "\b" || x === "\f" || x === "\n" || x === "\r" || x === "	") {
      return x;
    }
    return "\\u" + ("000" + ((_a = x.codePointAt(0)) == null ? void 0 : _a.toString(16))).slice(-4);
  });
}
function jsonUnescapeUnicode(value) {
  return value.replace(/\\u[a-fA-F0-9]{4}/g, (x) => {
    try {
      const unescaped = JSON.parse('"' + x + '"');
      return controlCharacters[unescaped] || unescaped;
    } catch (err) {
      return x;
    }
  });
}
var controlCharacters = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
var escapedControlCharacters = {
  '\\"': '"',
  "\\\\": "\\",
  "\\/": "/",
  "\\b": "\b",
  "\\f": "\f",
  "\\n": "\n",
  "\\r": "\r",
  "\\t": "	"
};
function jsonEscapeControl(value) {
  return value.replace(/["\b\f\n\r\t\\]/g, (x) => {
    return controlCharacters[x] || x;
  });
}
function jsonUnescapeControl(value) {
  return value.replace(/\\["bfnrt\\]/g, (x) => {
    return escapedControlCharacters[x] || x;
  });
}
function addNewLineSuffix(value) {
  if (typeof value !== "string") {
    return String(value);
  }
  if (value.endsWith("\n")) {
    return value + "\n";
  }
  return value;
}
function removeNewLineSuffix(text2) {
  return text2.replace(/\n$/, "");
}
function isChildOfNodeName(element2, nodeName) {
  return isChildOf(element2, (e) => e.nodeName.toUpperCase() === nodeName.toUpperCase());
}
function isChildOfAttribute(element2, name, value) {
  return isChildOf(element2, (e) => hasAttribute(e, name, value));
}
function isContentEditableDiv(element2) {
  return element2.nodeName === "DIV" && element2.contentEditable === "true";
}
function hasAttribute(element2, name, value) {
  return typeof element2.getAttribute === "function" && element2.getAttribute(name) === value;
}
function isChildOf(element2, predicate) {
  return !!findParent(element2, predicate);
}
function findParent(element2, predicate) {
  let e = element2;
  while (e && !predicate(e)) {
    e = e.parentNode;
  }
  return e || void 0;
}
function setCursorToEnd(element2) {
  if (element2.firstChild == null) {
    element2.focus();
    return;
  }
  const range = document.createRange();
  const selection = window.getSelection();
  range.setStart(element2, 1);
  range.collapse(true);
  selection == null ? void 0 : selection.removeAllRanges();
  selection == null ? void 0 : selection.addRange(range);
}
function getWindow(element2) {
  return element2 && element2.ownerDocument && element2.ownerDocument.defaultView;
}
function activeElementIsChildOf(element2) {
  const window2 = getWindow(element2);
  return isChildOf(window2.document.activeElement, (e) => e === element2);
}
function findParentWithNodeName(element2, nodeName) {
  return findParent(element2, (e) => e.nodeName === nodeName);
}
function getSelectionTypeFromTarget(target) {
  if (isChildOfAttribute(target, "data-type", "selectable-key")) {
    return SelectionType.key;
  }
  if (isChildOfAttribute(target, "data-type", "selectable-value")) {
    return SelectionType.value;
  }
  if (isChildOfAttribute(target, "data-type", "insert-selection-area-inside")) {
    return SelectionType.inside;
  }
  if (isChildOfAttribute(target, "data-type", "insert-selection-area-after")) {
    return SelectionType.after;
  }
  return SelectionType.multi;
}
function encodeDataPath(path) {
  return encodeURIComponent(compileJSONPointer(path));
}
function decodeDataPath(pathStr) {
  return parseJSONPointer(decodeURIComponent(pathStr));
}
function getDataPathFromTarget(target) {
  const parent = findParent(target, (element2) => {
    return element2.hasAttribute("data-path");
  });
  return parent ? decodeDataPath(parent.getAttribute("data-path")) : null;
}
function findNearestElement({ allElements, currentElement, direction, hasPrio = () => true, margin = 10 }) {
  const all = map_default(allElements.filter(isVisible), calculateCenter);
  const current = calculateCenter(currentElement);
  function isVisible(element2) {
    const rect = element2.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0;
  }
  function calculateCenter(element2) {
    const rect = element2.getBoundingClientRect();
    return {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2,
      rect,
      element: element2
    };
  }
  const isOnSameRow = (a, b) => Math.abs(a.y - b.y) < margin;
  const isLeft = (a, b) => a.rect.left + margin < b.rect.left;
  const isRight = (a, b) => a.rect.right > b.rect.right + margin;
  const isAbove = (a, b) => a.y + margin < b.y;
  const isBelow = (a, b) => a.y > b.y + margin;
  function distance(a, b, weightY = 1) {
    const diffX = a.x - b.x;
    const diffY = (a.y - b.y) * weightY;
    return Math.sqrt(diffX * diffX + diffY * diffY);
  }
  const distanceToCurrent = (candidate) => distance(candidate, current);
  const distanceToCurrentWeighted = (candidate) => distance(candidate, current, 10);
  if (direction === "Left" || direction === "Right") {
    const candidatesLeft = direction === "Left" ? all.filter((button) => isLeft(button, current)) : all.filter((button) => isRight(button, current));
    const candidatesLeftOnRow = candidatesLeft.filter((button) => isOnSameRow(button, current));
    const nearest = minBy_default(candidatesLeftOnRow, distanceToCurrent) || minBy_default(candidatesLeft, distanceToCurrentWeighted);
    return nearest == null ? void 0 : nearest.element;
  }
  if (direction === "Up" || direction === "Down") {
    const candidates = direction === "Up" ? all.filter((button) => isAbove(button, current)) : all.filter((button) => isBelow(button, current));
    const prioCandidates = candidates.filter((button) => hasPrio(button.element));
    const nearest = minBy_default(prioCandidates, distanceToCurrent) || minBy_default(candidates, distanceToCurrent);
    return nearest == null ? void 0 : nearest.element;
  }
  return void 0;
}

// ../node_modules/svelte-jsoneditor/utils/navigatorUtils.js
var IS_MAC = typeof navigator !== "undefined" ? navigator.platform.toUpperCase().indexOf("MAC") >= 0 : false;

// ../node_modules/svelte-jsoneditor/utils/keyBindings.js
function nameFromKeyCode(code) {
  return codes[code] || "";
}
function keyComboFromEvent(event) {
  const combi = [];
  if (event.ctrlKey) {
    combi.push("Ctrl");
  }
  if (event.metaKey) {
    combi.push("Command");
  }
  if (event.altKey) {
    combi.push(IS_MAC ? "Option" : "Alt");
  }
  if (event.shiftKey) {
    combi.push("Shift");
  }
  const keyName = nameFromKeyCode(event.which);
  if (!metaCodes[keyName]) {
    combi.push(keyName);
  }
  return combi.join("+");
}
var metaCodes = {
  Ctrl: true,
  Command: true,
  Alt: true,
  Option: true,
  Shift: true
};
var codes = {
  8: "Backspace",
  9: "Tab",
  13: "Enter",
  16: "Shift",
  17: "Ctrl",
  18: "Alt",
  19: "Pause_Break",
  20: "Caps_Lock",
  27: "Escape",
  33: "Page_Up",
  34: "Page_Down",
  35: "End",
  36: "Home",
  37: "Left",
  38: "Up",
  39: "Right",
  40: "Down",
  45: "Insert",
  46: "Delete",
  48: "0",
  49: "1",
  50: "2",
  51: "3",
  52: "4",
  53: "5",
  54: "6",
  55: "7",
  56: "8",
  57: "9",
  65: "A",
  66: "B",
  67: "C",
  68: "D",
  69: "E",
  70: "F",
  71: "G",
  72: "H",
  73: "I",
  74: "J",
  75: "K",
  76: "L",
  77: "M",
  78: "N",
  79: "O",
  80: "P",
  81: "Q",
  82: "R",
  83: "S",
  84: "T",
  85: "U",
  86: "V",
  87: "W",
  88: "X",
  89: "Y",
  90: "Z",
  91: "Left_Window_Key",
  92: "Right_Window_Key",
  93: "Select_Key",
  96: "Numpad_0",
  97: "Numpad_1",
  98: "Numpad_2",
  99: "Numpad_3",
  100: "Numpad_4",
  101: "Numpad_5",
  102: "Numpad_6",
  103: "Numpad_7",
  104: "Numpad_8",
  105: "Numpad_9",
  106: "Numpad_*",
  107: "Numpad_+",
  109: "Numpad_-",
  110: "Numpad_.",
  111: "Numpad_/",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "Num_Lock",
  145: "Scroll_Lock",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};

// ../node_modules/svelte-jsoneditor/components/modals/popup/AbsolutePopupEntry.svelte
var { Error: Error_1, window: window_12 } = globals;
var file2 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/popup/AbsolutePopupEntry.svelte";
function add_css2(target) {
  append_styles(target, "svelte-wershu", ".jse-absolute-popup.svelte-wershu.svelte-wershu{position:relative;left:0;top:0;width:0;height:0;z-index:1001}.jse-absolute-popup.svelte-wershu .jse-hidden-input.svelte-wershu{position:fixed;left:0;top:0;width:0;height:0;padding:0;margin:0;border:none;outline:none;overflow:hidden}.jse-absolute-popup.svelte-wershu .jse-absolute-popup-content.svelte-wershu{position:absolute}.svelte-wershu.svelte-wershu{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzb2x1dGVQb3B1cEVudHJ5LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzR3NDLG1CQUFBLDRCQUFBLENBQUEsb1dBc0JyQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJBYnNvbHV0ZVBvcHVwRW50cnkuc3ZlbHRlIl19 */");
}
function create_if_block2(ctx) {
  let div;
  let input;
  let t;
  let switch_instance;
  let div_style_value;
  let current;
  const switch_instance_spread_levels = [ctx[0].props];
  var switch_value = ctx[0].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, tabindex: true, class: true });
      t = claim_space(div_nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      input.readOnly = "readonly";
      attr_dev(input, "tabindex", "-1");
      attr_dev(input, "class", "jse-hidden-input svelte-wershu");
      add_location(input, file2, 90, 6, 3223);
      attr_dev(div, "class", "jse-absolute-popup-content svelte-wershu");
      attr_dev(div, "style", div_style_value = calculateStyle(ctx[1], ctx[0].options));
      add_location(div, file2, 89, 4, 3124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx[7](input);
      append_hydration_dev(div, t);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[0].props)]) : {};
      if (switch_value !== (switch_value = ctx2[0].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty & 3 && div_style_value !== (div_style_value = calculateStyle(ctx2[1], ctx2[0].options))) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[7](null);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(89:2) {#if refRootPopup}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-absolute-popup svelte-wershu");
      add_location(div, file2, 82, 0, 2968);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      ctx[8](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window_12, "mousedown", ctx[3], true, false, false),
          listen_dev(window_12, "keydown", ctx[4], true, false, false),
          listen_dev(window_12, "wheel", ctx[5], true, false, false),
          listen_dev(div, "mousedown", handleMouseDownInside, false, false, false),
          listen_dev(div, "keydown", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function handleMouseDownInside(event) {
  event.stopPropagation();
}
function calculateStyle(refRootPopup, options) {
  function calculatePosition2() {
    if (options.anchor) {
      const { anchor, width = 0, height = 0, offsetTop = 0, offsetLeft = 0, position } = options;
      const { left: left2, top: top2, bottom, right } = anchor.getBoundingClientRect();
      const positionAbove2 = position === "top" || top2 + height > window.innerHeight && top2 > height;
      const positionLeft2 = position === "left" || left2 + width > window.innerWidth && left2 > width;
      return {
        left: positionLeft2 ? right - offsetLeft : left2 + offsetLeft,
        top: positionAbove2 ? top2 - offsetTop : bottom + offsetTop,
        positionAbove: positionAbove2,
        positionLeft: positionLeft2
      };
    } else if (typeof options.left === "number" && typeof options.top === "number") {
      const { left: left2, top: top2, width = 0, height = 0 } = options;
      const positionAbove2 = top2 + height > window.innerHeight && top2 > height;
      const positionLeft2 = left2 + width > window.innerWidth && left2 > width;
      return { left: left2, top: top2, positionAbove: positionAbove2, positionLeft: positionLeft2 };
    } else {
      throw new Error('Invalid config: pass either "left" and "top", or pass "anchor"');
    }
  }
  const rootRect = refRootPopup.getBoundingClientRect();
  const { left, top, positionAbove, positionLeft } = calculatePosition2();
  const verticalStyling = positionAbove ? `bottom: ${rootRect.top - top}px;` : `top: ${top - rootRect.top}px;`;
  const horizontalStyling = positionLeft ? `right: ${rootRect.left - left}px;` : `left: ${left - rootRect.left}px;`;
  return verticalStyling + horizontalStyling;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AbsolutePopupEntry", slots, []);
  let { popup } = $$props;
  let { closeAbsolutePopup } = $$props;
  let refRootPopup;
  let refHiddenInput;
  onMount(focus3);
  function closeWhenOutside(event) {
    if (popup.options && popup.options.closeOnOuterClick && !isChildOf(event.target, (e) => e === refRootPopup)) {
      closeAbsolutePopup(popup.id);
    }
  }
  function handleWindowMouseDown(event) {
    closeWhenOutside(event);
  }
  function handleKeyDown(event) {
    const combo = keyComboFromEvent(event);
    if (combo === "Escape") {
      closeAbsolutePopup(popup.id);
    }
  }
  function handleScrollWheel(event) {
    closeWhenOutside(event);
  }
  function focus3() {
    if (refHiddenInput) {
      refHiddenInput.focus();
    }
  }
  $$self.$$.on_mount.push(function() {
    if (popup === void 0 && !("popup" in $$props || $$self.$$.bound[$$self.$$.props["popup"]])) {
      console.warn("<AbsolutePopupEntry> was created without expected prop 'popup'");
    }
    if (closeAbsolutePopup === void 0 && !("closeAbsolutePopup" in $$props || $$self.$$.bound[$$self.$$.props["closeAbsolutePopup"]])) {
      console.warn("<AbsolutePopupEntry> was created without expected prop 'closeAbsolutePopup'");
    }
  });
  const writable_props = ["popup", "closeAbsolutePopup"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AbsolutePopupEntry> was created with unknown prop '${key}'`);
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refHiddenInput = $$value;
      $$invalidate(2, refHiddenInput);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refRootPopup = $$value;
      $$invalidate(1, refRootPopup);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("popup" in $$props2)
      $$invalidate(0, popup = $$props2.popup);
    if ("closeAbsolutePopup" in $$props2)
      $$invalidate(6, closeAbsolutePopup = $$props2.closeAbsolutePopup);
  };
  $$self.$capture_state = () => ({
    onMount,
    isChildOf,
    keyComboFromEvent,
    popup,
    closeAbsolutePopup,
    refRootPopup,
    refHiddenInput,
    closeWhenOutside,
    handleWindowMouseDown,
    handleMouseDownInside,
    handleKeyDown,
    handleScrollWheel,
    calculateStyle,
    focus: focus3
  });
  $$self.$inject_state = ($$props2) => {
    if ("popup" in $$props2)
      $$invalidate(0, popup = $$props2.popup);
    if ("closeAbsolutePopup" in $$props2)
      $$invalidate(6, closeAbsolutePopup = $$props2.closeAbsolutePopup);
    if ("refRootPopup" in $$props2)
      $$invalidate(1, refRootPopup = $$props2.refRootPopup);
    if ("refHiddenInput" in $$props2)
      $$invalidate(2, refHiddenInput = $$props2.refHiddenInput);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    popup,
    refRootPopup,
    refHiddenInput,
    handleWindowMouseDown,
    handleKeyDown,
    handleScrollWheel,
    closeAbsolutePopup,
    input_binding,
    div_binding
  ];
}
var AbsolutePopupEntry = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { popup: 0, closeAbsolutePopup: 6 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AbsolutePopupEntry",
      options,
      id: create_fragment2.name
    });
  }
  get popup() {
    throw new Error_1("<AbsolutePopupEntry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set popup(value) {
    throw new Error_1("<AbsolutePopupEntry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAbsolutePopup() {
    throw new Error_1("<AbsolutePopupEntry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAbsolutePopup(value) {
    throw new Error_1("<AbsolutePopupEntry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AbsolutePopupEntry_default = AbsolutePopupEntry;

// ../node_modules/svelte-jsoneditor/components/modals/popup/AbsolutePopup.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let absolutepopupentry;
  let current;
  absolutepopupentry = new AbsolutePopupEntry_default({
    props: {
      popup: ctx[6],
      closeAbsolutePopup: ctx[1]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(absolutepopupentry.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(absolutepopupentry.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(absolutepopupentry, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const absolutepopupentry_changes = {};
      if (dirty & 1)
        absolutepopupentry_changes.popup = ctx2[6];
      absolutepopupentry.$set(absolutepopupentry_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(absolutepopupentry.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(absolutepopupentry.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(absolutepopupentry, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(34:0) {#each popups as popup}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t;
  let current;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(t.parentNode, t);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AbsolutePopup", slots, ["default"]);
  const debug5 = createDebug("jsoneditor:AbsolutePopup");
  let popups = [];
  function openAbsolutePopup(component, props, options) {
    debug5("open...", props, options);
    const popup = {
      id: uniqueId(),
      component,
      props: props || {},
      options: options || {}
    };
    $$invalidate(0, popups = [...popups, popup]);
    return popup.id;
  }
  function closeAbsolutePopup(popupId) {
    const popupIndex = popups.findIndex((popup) => popup.id === popupId);
    if (popupIndex !== -1) {
      const popup = popups[popupIndex];
      if (popup.options.onClose) {
        popup.options.onClose();
      }
      $$invalidate(0, popups = popups.filter((popup2) => popup2.id !== popupId));
    }
  }
  setContext("absolute-popup", { openAbsolutePopup, closeAbsolutePopup });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AbsolutePopup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createDebug,
    setContext,
    uniqueId,
    AbsolutePopupEntry: AbsolutePopupEntry_default,
    debug: debug5,
    popups,
    openAbsolutePopup,
    closeAbsolutePopup
  });
  $$self.$inject_state = ($$props2) => {
    if ("popups" in $$props2)
      $$invalidate(0, popups = $$props2.popups);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        debug5("popups", popups);
    }
  };
  return [popups, closeAbsolutePopup, $$scope, slots];
}
var AbsolutePopup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AbsolutePopup",
      options,
      id: create_fragment3.name
    });
  }
};
var AbsolutePopup_default = AbsolutePopup;

// ../node_modules/svelte-jsoneditor/utils/fileUtils.js
function formatSize(size, kilo = 1e3) {
  if (size < 0.9 * kilo) {
    return size.toFixed() + " B";
  }
  const KB = size / kilo;
  if (KB < 0.9 * kilo) {
    return KB.toFixed(1) + " KB";
  }
  const MB = KB / kilo;
  if (MB < 0.9 * kilo) {
    return MB.toFixed(1) + " MB";
  }
  const GB = MB / kilo;
  if (GB < 0.9 * kilo) {
    return GB.toFixed(1) + " GB";
  }
  const TB = GB / kilo;
  return TB.toFixed(1) + " TB";
}

// ../node_modules/svelte-jsoneditor/components/controls/createFocusTracker.js
var debug = createDebug("jsoneditor:FocusTracker");
function createFocusTracker({ onMount: onMount2, onDestroy: onDestroy2, getWindow: getWindow2, hasFocus, onFocus, onBlur }) {
  let blurTimeoutHandle;
  let focus3 = false;
  function handleFocusIn() {
    const newFocus = hasFocus();
    if (newFocus) {
      clearTimeout(blurTimeoutHandle);
      if (!focus3) {
        debug("focus");
        onFocus();
        focus3 = newFocus;
      }
    }
  }
  function handleFocusOut() {
    if (focus3) {
      clearTimeout(blurTimeoutHandle);
      blurTimeoutHandle = setTimeout(() => {
        debug("blur");
        focus3 = false;
        onBlur();
      });
    }
  }
  onMount2(() => {
    debug("mount FocusTracker");
    const window2 = getWindow2();
    if (window2) {
      window2.addEventListener("focusin", handleFocusIn, true);
      window2.addEventListener("focusout", handleFocusOut, true);
    }
  });
  onDestroy2(() => {
    debug("destroy FocusTracker");
    const window2 = getWindow2();
    if (window2) {
      window2.removeEventListener("focusin", handleFocusIn, true);
      window2.removeEventListener("focusout", handleFocusOut, true);
    }
  });
}

// ../node_modules/svelte-awesome/components/svg/Path.svelte
var file3 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-awesome/components/svg/Path.svelte";
function create_fragment4(ctx) {
  let path;
  let path_id_value;
  let path_levels = [
    {
      id: path_id_value = "path-" + ctx[0]
    },
    ctx[1]
  ];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { id: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(path, path_data);
      add_location(path, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [
        dirty & 1 && path_id_value !== (path_id_value = "path-" + ctx2[0]) && { id: path_id_value },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Path", slots, []);
  let { id: id2 } = $$props;
  let { data = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Path> was created without expected prop 'id'");
    }
  });
  const writable_props = ["id", "data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Path> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ id: id2, data });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id2, data];
}
var Path = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { id: 0, data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Path",
      options,
      id: create_fragment4.name
    });
  }
  get id() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Path_default = Path;

// ../node_modules/svelte-awesome/components/svg/Polygon.svelte
var file4 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-awesome/components/svg/Polygon.svelte";
function create_fragment5(ctx) {
  let polygon;
  let polygon_id_value;
  let polygon_levels = [
    {
      id: polygon_id_value = "polygon-" + ctx[0]
    },
    ctx[1]
  ];
  let polygon_data = {};
  for (let i = 0; i < polygon_levels.length; i += 1) {
    polygon_data = assign(polygon_data, polygon_levels[i]);
  }
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", { id: true });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(polygon, polygon_data);
      add_location(polygon, file4, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(polygon, polygon_data = get_spread_update(polygon_levels, [
        dirty & 1 && polygon_id_value !== (polygon_id_value = "polygon-" + ctx2[0]) && { id: polygon_id_value },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Polygon", slots, []);
  let { id: id2 } = $$props;
  let { data = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Polygon> was created without expected prop 'id'");
    }
  });
  const writable_props = ["id", "data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Polygon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ id: id2, data });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id2, data];
}
var Polygon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { id: 0, data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Polygon",
      options,
      id: create_fragment5.name
    });
  }
  get id() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Polygon_default = Polygon;

// ../node_modules/svelte-awesome/components/svg/Raw.svelte
var file5 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-awesome/components/svg/Raw.svelte";
function create_fragment6(ctx) {
  let g;
  const block = {
    c: function create() {
      g = svg_element("g");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", {});
      var g_nodes = children(g);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(g, file5, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      g.innerHTML = ctx[0];
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1)
        g.innerHTML = ctx2[0];
      ;
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(g);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Raw", slots, []);
  let cursor = 870711;
  function getId() {
    cursor += 1;
    return `fa-${cursor.toString(16)}`;
  }
  let raw;
  let { data } = $$props;
  function getRaw(data2) {
    if (!data2 || !data2.raw) {
      return null;
    }
    let rawData = data2.raw;
    const ids = {};
    rawData = rawData.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (match, id2) => {
      const uniqueId2 = getId();
      ids[id2] = uniqueId2;
      return ` id="${uniqueId2}"`;
    });
    rawData = rawData.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (match, rawId, _, pointerId) => {
      const id2 = rawId || pointerId;
      if (!id2 || !ids[id2]) {
        return match;
      }
      return `#${ids[id2]}`;
    });
    return rawData;
  }
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Raw> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Raw> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ cursor, getId, raw, data, getRaw });
  $$self.$inject_state = ($$props2) => {
    if ("cursor" in $$props2)
      cursor = $$props2.cursor;
    if ("raw" in $$props2)
      $$invalidate(0, raw = $$props2.raw);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(0, raw = getRaw(data));
    }
  };
  return [raw, data];
}
var Raw = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Raw",
      options,
      id: create_fragment6.name
    });
  }
  get data() {
    throw new Error("<Raw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Raw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Raw_default = Raw;

// ../node_modules/svelte-awesome/components/svg/Svg.svelte
var file6 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-awesome/components/svg/Svg.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1f5e0x1", ".fa-icon.svelte-1f5e0x1{display:inline-block;fill:currentColor}.fa-flip-horizontal.svelte-1f5e0x1{transform:scale(-1, 1)}.fa-flip-vertical.svelte-1f5e0x1{transform:scale(1, -1)}.fa-spin.svelte-1f5e0x1{animation:svelte-1f5e0x1-fa-spin 1s 0s infinite linear}.fa-inverse.svelte-1f5e0x1{color:#fff}.fa-pulse.svelte-1f5e0x1{animation:svelte-1f5e0x1-fa-spin 1s infinite steps(8)}@keyframes svelte-1f5e0x1-fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.svelte-1f5e0x1{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZnLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZQSxRQUFRLGVBQUMsQ0FBQSxBQUNQLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLElBQUksQ0FBRSxZQUFZLEFBQ3BCLENBQUEsQUFDQSxtQkFBbUIsZUFBQyxDQUFBLEFBQ2xCLFNBQVMsQ0FBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUN6QixDQUFBLEFBQ0EsaUJBQWlCLGVBQUMsQ0FBQSxBQUNoQixTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQUFDekIsQ0FBQSxBQUNBLFFBQVEsZUFBQyxDQUFBLEFBQ1AsU0FBUyxDQUFFLHNCQUFPLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxBQUMxQyxDQUFBLEFBQ0EsV0FBVyxlQUFDLENBQUEsQUFDVixLQUFLLENBQUUsSUFBSSxBQUNiLENBQUEsQUFDQSxTQUFTLGVBQUMsQ0FBQSxBQUNSLFNBQVMsQ0FBRSxzQkFBTyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQUFDekMsQ0FBQSxBQUNBLFdBQVcsc0JBQVEsQ0FBQSxBQUNqQixFQUFFLEFBQUMsQ0FBQSxBQUNELFNBQVMsQ0FBRSxPQUFPLElBQUksQ0FBQyxBQUN6QixDQUFBLEFBQ0EsSUFBSSxBQUFDLENBQUEsQUFDSCxTQUFTLENBQUUsT0FBTyxNQUFNLENBQUMsQUFDM0IsQ0FBQSxBQUNGLENBQUEsaUJBQ0EiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU3ZnLnN2ZWx0ZSJdfQ== */");
}
function create_fragment7(ctx) {
  let svg;
  let svg_class_value;
  let svg_role_value;
  let current;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        version: true,
        class: true,
        x: true,
        y: true,
        width: true,
        height: true,
        "aria-label": true,
        role: true,
        viewBox: true,
        style: true
      });
      var svg_nodes = children(svg);
      if (default_slot)
        default_slot.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "version", "1.1");
      attr_dev(svg, "class", svg_class_value = "fa-icon " + ctx[0] + " svelte-1f5e0x1");
      attr_dev(svg, "x", ctx[8]);
      attr_dev(svg, "y", ctx[9]);
      attr_dev(svg, "width", ctx[1]);
      attr_dev(svg, "height", ctx[2]);
      attr_dev(svg, "aria-label", ctx[11]);
      attr_dev(svg, "role", svg_role_value = ctx[11] ? "img" : "presentation");
      attr_dev(svg, "viewBox", ctx[3]);
      attr_dev(svg, "style", ctx[10]);
      toggle_class(svg, "fa-spin", ctx[4]);
      toggle_class(svg, "fa-pulse", ctx[6]);
      toggle_class(svg, "fa-inverse", ctx[5]);
      toggle_class(svg, "fa-flip-horizontal", ctx[7] === "horizontal");
      toggle_class(svg, "fa-flip-vertical", ctx[7] === "vertical");
      add_location(svg, file6, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && svg_class_value !== (svg_class_value = "fa-icon " + ctx2[0] + " svelte-1f5e0x1")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (!current || dirty & 256) {
        attr_dev(svg, "x", ctx2[8]);
      }
      if (!current || dirty & 512) {
        attr_dev(svg, "y", ctx2[9]);
      }
      if (!current || dirty & 2) {
        attr_dev(svg, "width", ctx2[1]);
      }
      if (!current || dirty & 4) {
        attr_dev(svg, "height", ctx2[2]);
      }
      if (!current || dirty & 2048) {
        attr_dev(svg, "aria-label", ctx2[11]);
      }
      if (!current || dirty & 2048 && svg_role_value !== (svg_role_value = ctx2[11] ? "img" : "presentation")) {
        attr_dev(svg, "role", svg_role_value);
      }
      if (!current || dirty & 8) {
        attr_dev(svg, "viewBox", ctx2[3]);
      }
      if (!current || dirty & 1024) {
        attr_dev(svg, "style", ctx2[10]);
      }
      if (!current || dirty & 17) {
        toggle_class(svg, "fa-spin", ctx2[4]);
      }
      if (!current || dirty & 65) {
        toggle_class(svg, "fa-pulse", ctx2[6]);
      }
      if (!current || dirty & 33) {
        toggle_class(svg, "fa-inverse", ctx2[5]);
      }
      if (!current || dirty & 129) {
        toggle_class(svg, "fa-flip-horizontal", ctx2[7] === "horizontal");
      }
      if (!current || dirty & 129) {
        toggle_class(svg, "fa-flip-vertical", ctx2[7] === "vertical");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(svg);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Svg", slots, ["default"]);
  let { class: className } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { box } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip = null } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { label = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (className === void 0 && !("class" in $$props || $$self.$$.bound[$$self.$$.props["class"]])) {
      console.warn("<Svg> was created without expected prop 'class'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<Svg> was created without expected prop 'width'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<Svg> was created without expected prop 'height'");
    }
    if (box === void 0 && !("box" in $$props || $$self.$$.bound[$$self.$$.props["box"]])) {
      console.warn("<Svg> was created without expected prop 'box'");
    }
  });
  const writable_props = [
    "class",
    "width",
    "height",
    "box",
    "spin",
    "inverse",
    "pulse",
    "flip",
    "x",
    "y",
    "style",
    "label"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Svg> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, className = $$props2.class);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("box" in $$props2)
      $$invalidate(3, box = $$props2.box);
    if ("spin" in $$props2)
      $$invalidate(4, spin = $$props2.spin);
    if ("inverse" in $$props2)
      $$invalidate(5, inverse = $$props2.inverse);
    if ("pulse" in $$props2)
      $$invalidate(6, pulse = $$props2.pulse);
    if ("flip" in $$props2)
      $$invalidate(7, flip = $$props2.flip);
    if ("x" in $$props2)
      $$invalidate(8, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(9, y = $$props2.y);
    if ("style" in $$props2)
      $$invalidate(10, style = $$props2.style);
    if ("label" in $$props2)
      $$invalidate(11, label = $$props2.label);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    className,
    width,
    height,
    box,
    spin,
    inverse,
    pulse,
    flip,
    x,
    y,
    style,
    label
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("box" in $$props2)
      $$invalidate(3, box = $$props2.box);
    if ("spin" in $$props2)
      $$invalidate(4, spin = $$props2.spin);
    if ("inverse" in $$props2)
      $$invalidate(5, inverse = $$props2.inverse);
    if ("pulse" in $$props2)
      $$invalidate(6, pulse = $$props2.pulse);
    if ("flip" in $$props2)
      $$invalidate(7, flip = $$props2.flip);
    if ("x" in $$props2)
      $$invalidate(8, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(9, y = $$props2.y);
    if ("style" in $$props2)
      $$invalidate(10, style = $$props2.style);
    if ("label" in $$props2)
      $$invalidate(11, label = $$props2.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    width,
    height,
    box,
    spin,
    inverse,
    pulse,
    flip,
    x,
    y,
    style,
    label,
    $$scope,
    slots
  ];
}
var Svg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        class: 0,
        width: 1,
        height: 2,
        box: 3,
        spin: 4,
        inverse: 5,
        pulse: 6,
        flip: 7,
        x: 8,
        y: 9,
        style: 10,
        label: 11
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svg",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get box() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set box(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svg_default = Svg;

// ../node_modules/svelte-awesome/components/Icon.svelte
var { Object: Object_12, console: console_1 } = globals;
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function create_if_block3(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[6].paths && create_if_block_3(ctx);
  let if_block1 = ctx[6].polygons && create_if_block_22(ctx);
  let if_block2 = ctx[6].raw && create_if_block_12(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[6].paths) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6].polygons) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[6].raw) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_12(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy2(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(4:4) {#if self}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[6].paths;
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64) {
        each_value_1 = ctx2[6].paths;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(5:6) {#if self.paths}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let path;
  let current;
  path = new Path_default({
    props: {
      id: ctx[31],
      data: ctx[32]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(path.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(path.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(path, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const path_changes = {};
      if (dirty[0] & 64)
        path_changes.data = ctx2[32];
      path.$set(path_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(path.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(path.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(path, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(6:8) {#each self.paths as path, i}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[6].polygons;
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64) {
        each_value = ctx2[6].polygons;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(10:6) {#if self.polygons}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let polygon;
  let current;
  polygon = new Polygon_default({
    props: {
      id: ctx[31],
      data: ctx[29]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(polygon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(polygon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(polygon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const polygon_changes = {};
      if (dirty[0] & 64)
        polygon_changes.data = ctx2[29];
      polygon.$set(polygon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(polygon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(polygon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(polygon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(11:8) {#each self.polygons as polygon, i}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let raw;
  let updating_data;
  let current;
  function raw_data_binding(value) {
    ctx[15](value);
  }
  let raw_props = {};
  if (ctx[6] !== void 0) {
    raw_props.data = ctx[6];
  }
  raw = new Raw_default({ props: raw_props, $$inline: true });
  binding_callbacks.push(() => bind(raw, "data", raw_data_binding));
  const block = {
    c: function create() {
      create_component(raw.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(raw.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(raw, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const raw_changes = {};
      if (!updating_data && dirty[0] & 64) {
        updating_data = true;
        raw_changes.data = ctx2[6];
        add_flush_callback(() => updating_data = false);
      }
      raw.$set(raw_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(raw.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(raw.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(raw, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(15:6) {#if self.raw}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[6] && create_if_block3(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(3:8)      ",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(default_slot_template, ctx2[16], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 64)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <Svg label={label} width={width} height={height} box={box} style={combinedStyle}   spin={spin} flip={flip} inverse={inverse} pulse={pulse} class={className}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let svg;
  let current;
  svg = new Svg_default({
    props: {
      label: ctx[5],
      width: ctx[7],
      height: ctx[8],
      box: ctx[10],
      style: ctx[9],
      spin: ctx[1],
      flip: ctx[4],
      inverse: ctx[2],
      pulse: ctx[3],
      class: ctx[0],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty[0] & 32)
        svg_changes.label = ctx2[5];
      if (dirty[0] & 128)
        svg_changes.width = ctx2[7];
      if (dirty[0] & 256)
        svg_changes.height = ctx2[8];
      if (dirty[0] & 1024)
        svg_changes.box = ctx2[10];
      if (dirty[0] & 512)
        svg_changes.style = ctx2[9];
      if (dirty[0] & 2)
        svg_changes.spin = ctx2[1];
      if (dirty[0] & 16)
        svg_changes.flip = ctx2[4];
      if (dirty[0] & 4)
        svg_changes.inverse = ctx2[2];
      if (dirty[0] & 8)
        svg_changes.pulse = ctx2[3];
      if (dirty[0] & 1)
        svg_changes.class = ctx2[0];
      if (dirty[0] & 65600) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function normaliseData(data) {
  if ("iconName" in data && "icon" in data) {
    let normalisedData = {};
    let faIcon = data.icon;
    let name = data.iconName;
    let width = faIcon[0];
    let height = faIcon[1];
    let paths = faIcon[4];
    let iconData = { width, height, paths: [{ d: paths }] };
    normalisedData[name] = iconData;
    return normalisedData;
  }
  return data;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { data } = $$props;
  let { scale = 1 } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip = null } = $$props;
  let { label = null } = $$props;
  let self = null;
  let { style = null } = $$props;
  let x = 0;
  let y = 0;
  let childrenHeight = 0;
  let childrenWidth = 0;
  let outerScale = 1;
  let width;
  let height;
  let combinedStyle;
  let box;
  function init2() {
    if (typeof data === "undefined") {
      return;
    }
    const normalisedData = normaliseData(data);
    const [name] = Object.keys(normalisedData);
    const icon = normalisedData[name];
    if (!icon.paths) {
      icon.paths = [];
    }
    if (icon.d) {
      icon.paths.push({ d: icon.d });
    }
    if (!icon.polygons) {
      icon.polygons = [];
    }
    if (icon.points) {
      icon.polygons.push({ points: icon.points });
    }
    $$invalidate(6, self = icon);
  }
  function normalisedScale() {
    let numScale = 1;
    if (typeof scale !== "undefined") {
      numScale = Number(scale);
    }
    if (isNaN(numScale) || numScale <= 0) {
      console.warn('Invalid prop: prop "scale" should be a number over 0.');
      return outerScale;
    }
    return numScale * outerScale;
  }
  function calculateBox() {
    if (self) {
      return `0 0 ${self.width} ${self.height}`;
    }
    return `0 0 ${width} ${height}`;
  }
  function calculateRatio() {
    if (!self) {
      return 1;
    }
    return Math.max(self.width, self.height) / 16;
  }
  function calculateWidth() {
    if (childrenWidth) {
      return childrenWidth;
    }
    if (self) {
      return self.width / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateHeight() {
    if (childrenHeight) {
      return childrenHeight;
    }
    if (self) {
      return self.height / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateStyle2() {
    let combined = "";
    if (style !== null) {
      combined += style;
    }
    let size = normalisedScale();
    if (size === 1) {
      if (combined.length === 0) {
        return void 0;
      }
      return combined;
    }
    if (combined !== "" && !combined.endsWith(";")) {
      combined += "; ";
    }
    return `${combined}font-size: ${size}em`;
  }
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console_1.warn("<Icon> was created without expected prop 'data'");
    }
  });
  const writable_props = ["class", "data", "scale", "spin", "inverse", "pulse", "flip", "label", "style"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Icon> was created with unknown prop '${key}'`);
  });
  function raw_data_binding(value) {
    self = value;
    $$invalidate(6, self);
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, className = $$props2.class);
    if ("data" in $$props2)
      $$invalidate(11, data = $$props2.data);
    if ("scale" in $$props2)
      $$invalidate(12, scale = $$props2.scale);
    if ("spin" in $$props2)
      $$invalidate(1, spin = $$props2.spin);
    if ("inverse" in $$props2)
      $$invalidate(2, inverse = $$props2.inverse);
    if ("pulse" in $$props2)
      $$invalidate(3, pulse = $$props2.pulse);
    if ("flip" in $$props2)
      $$invalidate(4, flip = $$props2.flip);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("style" in $$props2)
      $$invalidate(13, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Path: Path_default,
    Polygon: Polygon_default,
    Raw: Raw_default,
    Svg: Svg_default,
    className,
    data,
    scale,
    spin,
    inverse,
    pulse,
    flip,
    label,
    self,
    style,
    x,
    y,
    childrenHeight,
    childrenWidth,
    outerScale,
    width,
    height,
    combinedStyle,
    box,
    init: init2,
    normaliseData,
    normalisedScale,
    calculateBox,
    calculateRatio,
    calculateWidth,
    calculateHeight,
    calculateStyle: calculateStyle2
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("data" in $$props2)
      $$invalidate(11, data = $$props2.data);
    if ("scale" in $$props2)
      $$invalidate(12, scale = $$props2.scale);
    if ("spin" in $$props2)
      $$invalidate(1, spin = $$props2.spin);
    if ("inverse" in $$props2)
      $$invalidate(2, inverse = $$props2.inverse);
    if ("pulse" in $$props2)
      $$invalidate(3, pulse = $$props2.pulse);
    if ("flip" in $$props2)
      $$invalidate(4, flip = $$props2.flip);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("self" in $$props2)
      $$invalidate(6, self = $$props2.self);
    if ("style" in $$props2)
      $$invalidate(13, style = $$props2.style);
    if ("x" in $$props2)
      x = $$props2.x;
    if ("y" in $$props2)
      y = $$props2.y;
    if ("childrenHeight" in $$props2)
      childrenHeight = $$props2.childrenHeight;
    if ("childrenWidth" in $$props2)
      childrenWidth = $$props2.childrenWidth;
    if ("outerScale" in $$props2)
      outerScale = $$props2.outerScale;
    if ("width" in $$props2)
      $$invalidate(7, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(8, height = $$props2.height);
    if ("combinedStyle" in $$props2)
      $$invalidate(9, combinedStyle = $$props2.combinedStyle);
    if ("box" in $$props2)
      $$invalidate(10, box = $$props2.box);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 14336) {
      $: {
        data;
        style;
        scale;
        init2();
        $$invalidate(7, width = calculateWidth());
        $$invalidate(8, height = calculateHeight());
        $$invalidate(9, combinedStyle = calculateStyle2());
        $$invalidate(10, box = calculateBox());
      }
    }
  };
  return [
    className,
    spin,
    inverse,
    pulse,
    flip,
    label,
    self,
    width,
    height,
    combinedStyle,
    box,
    data,
    scale,
    style,
    slots,
    raw_data_binding,
    $$scope
  ];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        class: 0,
        data: 11,
        scale: 12,
        spin: 1,
        inverse: 2,
        pulse: 3,
        flip: 4,
        label: 5,
        style: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment8.name
    });
  }
  get class() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// ../node_modules/svelte-jsoneditor/components/controls/Message.svelte
var file7 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/Message.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1d1eyqm", ".jse-message.svelte-1d1eyqm.svelte-1d1eyqm{font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);padding:var(--jse-padding);display:flex;gap:var(--jse-padding);flex-wrap:wrap;align-items:center}.jse-message.jse-success.svelte-1d1eyqm.svelte-1d1eyqm{background:var(--jse-message-success-background);color:var(--jse-message-success-color)}.jse-message.svelte-1d1eyqm .jse-text.svelte-1d1eyqm{flex:1;min-width:60%}.jse-message.svelte-1d1eyqm .jse-text.jse-clickable.svelte-1d1eyqm{cursor:pointer}.jse-message.svelte-1d1eyqm .jse-text.jse-clickable.svelte-1d1eyqm:hover{background-color:rgba(255, 255, 255, 0.1)}.jse-message.jse-error.svelte-1d1eyqm.svelte-1d1eyqm{background:var(--jse-message-error-background);color:var(--jse-message-error-color)}.jse-message.jse-warning.svelte-1d1eyqm.svelte-1d1eyqm{background:var(--jse-message-warning-background);color:var(--jse-message-warning-color)}.jse-message.jse-info.svelte-1d1eyqm.svelte-1d1eyqm{background:var(--jse-message-info-background);color:var(--jse-message-info-color)}.jse-message.svelte-1d1eyqm .jse-actions.svelte-1d1eyqm{display:flex;gap:var(--jse-padding)}.jse-message.svelte-1d1eyqm .jse-actions button.jse-action.svelte-1d1eyqm{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;background:var(--jse-message-action-background);color:inherit;padding:calc(0.5 * var(--jse-padding)) var(--jse-padding)}.jse-message.svelte-1d1eyqm .jse-actions button.jse-action.svelte-1d1eyqm:hover{background:var(--jse-message-action-background-highlight)}.svelte-1d1eyqm.svelte-1d1eyqm{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0QyQixZQUFBLDhCQUFBLENBQUEsd2tEQXNEMUIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVzc2FnZS5zdmVsdGUiXX0= */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block_13(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({
    props: { data: ctx[1] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & 2)
        icon_1_changes.data = ctx2[1];
      icon_1.$set(icon_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(19:4) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({
    props: { data: ctx[8].icon },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & 8)
        icon_1_changes.data = ctx2[8].icon;
      icon_1.$set(icon_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(42:8) {#if action.icon}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let button;
  let t0;
  let t1_value = ctx[8].text + "";
  let t1;
  let t2;
  let button_title_value;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[8].icon && create_if_block4(ctx);
  function click_handler() {
    return ctx[6](ctx[8]);
  }
  function mousedown_handler() {
    return ctx[7](ctx[8]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (if_block)
        if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t0 = claim_space(button_nodes);
      t1 = claim_text(button_nodes, t1_value);
      t2 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-button jse-action jse-primary svelte-1d1eyqm");
      attr_dev(button, "title", button_title_value = ctx[8].title);
      button.disabled = button_disabled_value = ctx[8].disabled;
      add_location(button, file7, 25, 6, 666);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", click_handler, false, false, false),
          listen_dev(button, "mousedown", mousedown_handler, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[8].icon) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & 8) && t1_value !== (t1_value = ctx[8].text + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty & 8 && button_title_value !== (button_title_value = ctx[8].title)) {
        attr_dev(button, "title", button_title_value);
      }
      if (!current || dirty & 8 && button_disabled_value !== (button_disabled_value = ctx[8].disabled)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(25:4) {#each actions as action}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let t2;
  let div1;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block_13(ctx);
  let each_value = ctx[3];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      t1 = text(ctx[2]);
      t2 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block)
        if_block.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      t1 = claim_text(div0_nodes, ctx[2]);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-text svelte-1d1eyqm");
      toggle_class(div0, "jse-clickable", ctx[4] !== null);
      add_location(div0, file7, 17, 2, 442);
      attr_dev(div1, "class", "jse-actions svelte-1d1eyqm");
      add_location(div1, file7, 23, 2, 604);
      attr_dev(div2, "class", div2_class_value = "jse-message jse-" + ctx[0] + " svelte-1d1eyqm");
      add_location(div2, file7, 15, 0, 344);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      if (if_block)
        if_block.m(div0, null);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(div0, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 4)
        set_data_dev(t1, ctx2[2]);
      if (!current || dirty & 16) {
        toggle_class(div0, "jse-clickable", ctx2[4] !== null);
      }
      if (dirty & 8) {
        each_value = ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 1 && div2_class_value !== (div2_class_value = "jse-message jse-" + ctx2[0] + " svelte-1d1eyqm")) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Message", slots, []);
  let { type = "success" } = $$props;
  let { icon = void 0 } = $$props;
  let { message = void 0 } = $$props;
  let { actions = [] } = $$props;
  let { onClick = void 0 } = $$props;
  function handleClick() {
    if (onClick) {
      onClick();
    }
  }
  const writable_props = ["type", "icon", "message", "actions", "onClick"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Message> was created with unknown prop '${key}'`);
  });
  const click_handler = (action) => {
    if (action.onClick) {
      action.onClick();
    }
  };
  const mousedown_handler = (action) => {
    if (action.onMouseDown) {
      action.onMouseDown();
    }
  };
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("message" in $$props2)
      $$invalidate(2, message = $$props2.message);
    if ("actions" in $$props2)
      $$invalidate(3, actions = $$props2.actions);
    if ("onClick" in $$props2)
      $$invalidate(4, onClick = $$props2.onClick);
  };
  $$self.$capture_state = () => ({
    Icon: Icon_default,
    type,
    icon,
    message,
    actions,
    onClick,
    handleClick
  });
  $$self.$inject_state = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("message" in $$props2)
      $$invalidate(2, message = $$props2.message);
    if ("actions" in $$props2)
      $$invalidate(3, actions = $$props2.actions);
    if ("onClick" in $$props2)
      $$invalidate(4, onClick = $$props2.onClick);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    type,
    icon,
    message,
    actions,
    onClick,
    handleClick,
    click_handler,
    mousedown_handler
  ];
}
var Message = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      not_equal,
      {
        type: 0,
        icon: 1,
        message: 2,
        actions: 3,
        onClick: 4
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Message",
      options,
      id: create_fragment9.name
    });
  }
  get type() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actions() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actions(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Message_default = Message;

// ../node_modules/svelte-jsoneditor/utils/pathUtils.js
function stringifyJSONPath(path) {
  return "$" + path.map(stringifyJSONPathProp).join("");
}
function stringifyJSONPathProp(prop) {
  if (integerNumberRegex.test(prop)) {
    return "[" + prop + "]";
  } else if (javaScriptPropertyRegex.test(prop)) {
    return "." + prop;
  } else {
    const propStr = JSON.stringify(prop);
    const jsonPathStr = propStr.substring(1, propStr.length - 1).replace(/\\"/g, '"');
    return "['" + jsonPathStr + "']";
  }
}
function stripRootObject(path) {
  return path.replace(/^\$/, "").replace(/^\./, "");
}
function prependRootObject(path) {
  if (path.startsWith("$")) {
    return path;
  }
  return !path.startsWith("[") && !path.startsWith(".") ? "$." + path : "$" + path;
}
function parseJSONPath(path) {
  let remainder = prependRootObject(path.trim()).substring(1);
  const jsonPath = [];
  while (remainder.length > 0) {
    const match = remainder.match(regexJsonPathProp);
    if (!match) {
      throw new SyntaxError(`Cannot parse path: unexpected part "${remainder}" at position ${path.length - remainder.length}`);
    }
    jsonPath.push(match[1] || match[2] || match[3]);
    remainder = remainder.substring(match[0].length);
  }
  return jsonPath;
}
var regexJsonPathDotProp = "^\\.([A-zA-Z$_][a-zA-Z$_0-9]*)";
var regexJsonPathArrayIndex = "^\\[([0-9]+)]";
var regexJsonPathArrayProp = "^\\['(.*)']";
var regexJsonPathProp = new RegExp([regexJsonPathDotProp, regexJsonPathArrayIndex, regexJsonPathArrayProp].join("|"));
function pathToOption(path) {
  return {
    value: path,
    label: isEmpty_default(path) ? "(whole item)" : stripRootObject(stringifyJSONPath(path))
  };
}
function createLodashPropertySelector(path) {
  return path.every((prop) => integerNumberRegex.test(prop) || javaScriptPropertyRegex.test(prop)) ? "'" + path.map(stringifyJSONPathProp).join("").replace(/^\./, "") + "'" : JSON.stringify(path);
}
function createPropertySelector(path) {
  return path.map((prop) => {
    if (integerNumberRegex.test(prop)) {
      return `?.[${prop}]`;
    } else if (javaScriptPropertyRegex.test(prop)) {
      return `?.${prop}`;
    } else {
      return `?.[${JSON.stringify(prop)}]`;
    }
  }).join("");
}
var javaScriptPropertyRegex = /^[a-zA-Z$_][a-zA-Z$_\d]*$/;
var integerNumberRegex = /^\d+$/;
function createMemoizePath() {
  return memoize_default((path) => path, stringifyJSONPath);
}

// ../node_modules/svelte-jsoneditor/components/controls/ValidationErrorsOverview.svelte
var file8 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/ValidationErrorsOverview.svelte";
function add_css5(target) {
  append_styles(target, "svelte-7gzep", ".jse-validation-errors-overview.svelte-7gzep.svelte-7gzep{font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);background:var(--jse-message-warning-background);color:var(--jse-message-warning-color);overflow:auto;max-height:25%}.jse-validation-errors-overview.svelte-7gzep table.svelte-7gzep{border-collapse:collapse;width:100%}.jse-validation-errors-overview.svelte-7gzep table tr.svelte-7gzep{cursor:pointer}.jse-validation-errors-overview.svelte-7gzep table tr.svelte-7gzep:hover{background-color:rgba(255, 255, 255, 0.1)}.jse-validation-errors-overview.svelte-7gzep table tr td.svelte-7gzep{padding:4px var(--jse-padding);vertical-align:middle}.jse-validation-errors-overview.svelte-7gzep table tr td.jse-validation-error-icon.svelte-7gzep{width:36px;box-sizing:border-box}.jse-validation-errors-overview.svelte-7gzep table tr td.jse-validation-error-action.svelte-7gzep{width:36px;box-sizing:border-box;padding:0}.jse-validation-errors-overview.svelte-7gzep table tr td.jse-validation-error-action button.jse-validation-errors-collapse.svelte-7gzep{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;width:36px;height:26px;cursor:pointer}.jse-validation-errors-overview.svelte-7gzep table tr td.jse-validation-error-action button.jse-validation-errors-collapse.svelte-7gzep:hover{background-color:rgba(255, 255, 255, 0.2)}.jse-validation-errors-overview.svelte-7gzep table tr td div.jse-validation-errors-expand.svelte-7gzep{display:inline-block;position:relative;top:3px}.svelte-7gzep.svelte-7gzep{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmFsaWRhdGlvbkVycm9yc092ZXJ2aWV3LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF3RjRDLCtCQUFBLDBCQUFBLENBQUEsa2lEQW1EM0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmFsaWRhdGlvbkVycm9yc092ZXJ2aWV3LnN2ZWx0ZSJdfQ== */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_if_block5(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] || ctx2[3] === 1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-validation-errors-overview svelte-7gzep");
      add_location(div, file8, 22, 2, 708);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(22:0) {#if !isEmpty(validationErrors)}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let table;
  let tbody;
  let tr;
  let td0;
  let icon0;
  let t0;
  let td1;
  let t1;
  let t2;
  let div;
  let icon1;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({
    props: { data: faExclamationTriangle },
    $$inline: true
  });
  icon1 = new Icon_default({
    props: { data: faAngleRight },
    $$inline: true
  });
  const block = {
    c: function create() {
      table = element("table");
      tbody = element("tbody");
      tr = element("tr");
      td0 = element("td");
      create_component(icon0.$$.fragment);
      t0 = space();
      td1 = element("td");
      t1 = text(ctx[3]);
      t2 = text(" validation errors\n              ");
      div = element("div");
      create_component(icon1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      tr = claim_element(tbody_nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      td0 = claim_element(tr_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      claim_component(icon0.$$.fragment, td0_nodes);
      td0_nodes.forEach(detach_dev);
      t0 = claim_space(tr_nodes);
      td1 = claim_element(tr_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      t1 = claim_text(td1_nodes, ctx[3]);
      t2 = claim_text(td1_nodes, " validation errors\n              ");
      div = claim_element(td1_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(icon1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      td1_nodes.forEach(detach_dev);
      tr_nodes.forEach(detach_dev);
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td0, "class", "jse-validation-error-icon svelte-7gzep");
      add_location(td0, file8, 72, 12, 2434);
      attr_dev(div, "class", "jse-validation-errors-expand svelte-7gzep");
      add_location(div, file8, 77, 14, 2614);
      attr_dev(td1, "class", "svelte-7gzep");
      add_location(td1, file8, 75, 12, 2555);
      attr_dev(tr, "class", "jse-validation-error svelte-7gzep");
      add_location(tr, file8, 71, 10, 2370);
      attr_dev(tbody, "class", "svelte-7gzep");
      add_location(tbody, file8, 70, 8, 2352);
      attr_dev(table, "class", "svelte-7gzep");
      add_location(table, file8, 69, 6, 2336);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, tbody);
      append_hydration_dev(tbody, tr);
      append_hydration_dev(tr, td0);
      mount_component(icon0, td0, null);
      append_hydration_dev(tr, t0);
      append_hydration_dev(tr, td1);
      append_hydration_dev(td1, t1);
      append_hydration_dev(td1, t2);
      append_hydration_dev(td1, div);
      mount_component(icon1, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(tr, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 8)
        set_data_dev(t1, ctx2[3]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_component(icon0);
      destroy_component(icon1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(69:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let table;
  let tbody;
  let t;
  let current;
  let each_value = limit(ctx[0], MAX_VALIDATION_ERRORS);
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = ctx[3] > MAX_VALIDATION_ERRORS && create_if_block_23(ctx);
  const block = {
    c: function create() {
      table = element("table");
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      t = claim_space(tbody_nodes);
      if (if_block)
        if_block.l(tbody_nodes);
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tbody, "class", "svelte-7gzep");
      add_location(tbody, file8, 25, 8, 809);
      attr_dev(table, "class", "svelte-7gzep");
      add_location(table, file8, 24, 6, 793);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
      append_hydration_dev(tbody, t);
      if (if_block)
        if_block.m(tbody, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 19) {
        each_value = limit(ctx2[0], MAX_VALIDATION_ERRORS);
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tbody, t);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[3] > MAX_VALIDATION_ERRORS) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          if_block.m(tbody, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(24:4) {#if expanded || count === 1}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { data: faAngleDown },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-validation-errors-collapse svelte-7gzep");
      attr_dev(button, "title", "Collapse validation errors");
      add_location(button, file8, 45, 18, 1637);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", stop_propagation(ctx[4]), false, false, true);
        mounted = true;
      }
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(45:16) {#if index === 0 && validationErrors.length > 1}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let tr;
  let td0;
  let icon;
  let t0;
  let td1;
  let t1_value = stripRootObject(stringifyJSONPath(ctx[7].path)) + "";
  let t1;
  let t2;
  let td2;
  let t3_value = ctx[7].message + "";
  let t3;
  let t4;
  let td3;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { data: faExclamationTriangle },
    $$inline: true
  });
  let if_block = ctx[9] === 0 && ctx[0].length > 1 && create_if_block_32(ctx);
  function click_handler() {
    return ctx[6](ctx[7]);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      td0 = element("td");
      create_component(icon.$$.fragment);
      t0 = space();
      td1 = element("td");
      t1 = text(t1_value);
      t2 = space();
      td2 = element("td");
      t3 = text(t3_value);
      t4 = space();
      td3 = element("td");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      td0 = claim_element(tr_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      claim_component(icon.$$.fragment, td0_nodes);
      td0_nodes.forEach(detach_dev);
      t0 = claim_space(tr_nodes);
      td1 = claim_element(tr_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      t1 = claim_text(td1_nodes, t1_value);
      td1_nodes.forEach(detach_dev);
      t2 = claim_space(tr_nodes);
      td2 = claim_element(tr_nodes, "TD", { class: true });
      var td2_nodes = children(td2);
      t3 = claim_text(td2_nodes, t3_value);
      td2_nodes.forEach(detach_dev);
      t4 = claim_space(tr_nodes);
      td3 = claim_element(tr_nodes, "TD", { class: true });
      var td3_nodes = children(td3);
      if (if_block)
        if_block.l(td3_nodes);
      td3_nodes.forEach(detach_dev);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td0, "class", "jse-validation-error-icon svelte-7gzep");
      add_location(td0, file8, 34, 14, 1191);
      attr_dev(td1, "class", "svelte-7gzep");
      add_location(td1, file8, 37, 14, 1318);
      attr_dev(td2, "class", "svelte-7gzep");
      add_location(td2, file8, 40, 14, 1432);
      attr_dev(td3, "class", "jse-validation-error-action svelte-7gzep");
      add_location(td3, file8, 43, 14, 1513);
      attr_dev(tr, "class", "jse-validation-error svelte-7gzep");
      add_location(tr, file8, 27, 12, 920);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td0);
      mount_component(icon, td0, null);
      append_hydration_dev(tr, t0);
      append_hydration_dev(tr, td1);
      append_hydration_dev(td1, t1);
      append_hydration_dev(tr, t2);
      append_hydration_dev(tr, td2);
      append_hydration_dev(td2, t3);
      append_hydration_dev(tr, t4);
      append_hydration_dev(tr, td3);
      if (if_block)
        if_block.m(td3, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(tr, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t1_value !== (t1_value = stripRootObject(stringifyJSONPath(ctx[7].path)) + ""))
        set_data_dev(t1, t1_value);
      if ((!current || dirty & 1) && t3_value !== (t3_value = ctx[7].message + ""))
        set_data_dev(t3, t3_value);
      if (ctx[9] === 0 && ctx[0].length > 1) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_32(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(td3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_component(icon);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(27:10) {#each limit(validationErrors, MAX_VALIDATION_ERRORS) as validationError, index}",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let tr;
  let td0;
  let t0;
  let td1;
  let t1;
  let td2;
  let t2;
  let t3_value = ctx[3] - MAX_VALIDATION_ERRORS + "";
  let t3;
  let t4;
  let t5;
  let td3;
  const block = {
    c: function create() {
      tr = element("tr");
      td0 = element("td");
      t0 = space();
      td1 = element("td");
      t1 = space();
      td2 = element("td");
      t2 = text("(and ");
      t3 = text(t3_value);
      t4 = text(" more errors)");
      t5 = space();
      td3 = element("td");
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      td0 = claim_element(tr_nodes, "TD", { class: true });
      children(td0).forEach(detach_dev);
      t0 = claim_space(tr_nodes);
      td1 = claim_element(tr_nodes, "TD", { class: true });
      children(td1).forEach(detach_dev);
      t1 = claim_space(tr_nodes);
      td2 = claim_element(tr_nodes, "TD", { class: true });
      var td2_nodes = children(td2);
      t2 = claim_text(td2_nodes, "(and ");
      t3 = claim_text(td2_nodes, t3_value);
      t4 = claim_text(td2_nodes, " more errors)");
      td2_nodes.forEach(detach_dev);
      t5 = claim_space(tr_nodes);
      td3 = claim_element(tr_nodes, "TD", { class: true });
      children(td3).forEach(detach_dev);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td0, "class", "svelte-7gzep");
      add_location(td0, file8, 60, 14, 2130);
      attr_dev(td1, "class", "svelte-7gzep");
      add_location(td1, file8, 61, 14, 2151);
      attr_dev(td2, "class", "svelte-7gzep");
      add_location(td2, file8, 62, 14, 2172);
      attr_dev(td3, "class", "svelte-7gzep");
      add_location(td3, file8, 63, 14, 2245);
      attr_dev(tr, "class", "jse-validation-error svelte-7gzep");
      add_location(tr, file8, 59, 12, 2082);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td0);
      append_hydration_dev(tr, t0);
      append_hydration_dev(tr, td1);
      append_hydration_dev(tr, t1);
      append_hydration_dev(tr, td2);
      append_hydration_dev(td2, t2);
      append_hydration_dev(td2, t3);
      append_hydration_dev(td2, t4);
      append_hydration_dev(tr, t5);
      append_hydration_dev(tr, td3);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8 && t3_value !== (t3_value = ctx2[3] - MAX_VALIDATION_ERRORS + ""))
        set_data_dev(t3, t3_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(tr);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(59:10) {#if count > MAX_VALIDATION_ERRORS}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let show_if = !isEmpty_default(ctx[0]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1)
        show_if = !isEmpty_default(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let count;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ValidationErrorsOverview", slots, []);
  let { validationErrors } = $$props;
  let { selectError } = $$props;
  let expanded = true;
  function collapse() {
    $$invalidate(2, expanded = false);
  }
  function expand() {
    $$invalidate(2, expanded = true);
  }
  $$self.$$.on_mount.push(function() {
    if (validationErrors === void 0 && !("validationErrors" in $$props || $$self.$$.bound[$$self.$$.props["validationErrors"]])) {
      console.warn("<ValidationErrorsOverview> was created without expected prop 'validationErrors'");
    }
    if (selectError === void 0 && !("selectError" in $$props || $$self.$$.bound[$$self.$$.props["selectError"]])) {
      console.warn("<ValidationErrorsOverview> was created without expected prop 'selectError'");
    }
  });
  const writable_props = ["validationErrors", "selectError"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ValidationErrorsOverview> was created with unknown prop '${key}'`);
  });
  const click_handler = (validationError) => {
    setTimeout(() => selectError(validationError));
  };
  $$self.$$set = ($$props2) => {
    if ("validationErrors" in $$props2)
      $$invalidate(0, validationErrors = $$props2.validationErrors);
    if ("selectError" in $$props2)
      $$invalidate(1, selectError = $$props2.selectError);
  };
  $$self.$capture_state = () => ({
    faAngleDown,
    faAngleRight,
    faExclamationTriangle,
    isEmpty: isEmpty_default,
    Icon: Icon_default,
    stringifyJSONPath,
    stripRootObject,
    MAX_VALIDATION_ERRORS,
    limit,
    validationErrors,
    selectError,
    expanded,
    collapse,
    expand,
    count
  });
  $$self.$inject_state = ($$props2) => {
    if ("validationErrors" in $$props2)
      $$invalidate(0, validationErrors = $$props2.validationErrors);
    if ("selectError" in $$props2)
      $$invalidate(1, selectError = $$props2.selectError);
    if ("expanded" in $$props2)
      $$invalidate(2, expanded = $$props2.expanded);
    if ("count" in $$props2)
      $$invalidate(3, count = $$props2.count);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(3, count = validationErrors.length);
    }
  };
  return [
    validationErrors,
    selectError,
    expanded,
    count,
    collapse,
    expand,
    click_handler
  ];
}
var ValidationErrorsOverview = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, not_equal, { validationErrors: 0, selectError: 1 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ValidationErrorsOverview",
      options,
      id: create_fragment10.name
    });
  }
  get validationErrors() {
    throw new Error("<ValidationErrorsOverview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationErrors(value) {
    throw new Error("<ValidationErrorsOverview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectError() {
    throw new Error("<ValidationErrorsOverview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectError(value) {
    throw new Error("<ValidationErrorsOverview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ValidationErrorsOverview_default = ValidationErrorsOverview;

// ../node_modules/svelte-jsoneditor/img/customFontawesomeIcons.js
var faJSONEditorExpand = {
  prefix: "fas",
  iconName: "jsoneditor-expand",
  icon: [
    512,
    512,
    [],
    null,
    "M 0,448 V 512 h 512 v -64 z M 0,0 V 64 H 512 V 0 Z M 256,96 128,224 h 256 z M 256,416 384,288 H 128 Z"
  ]
};
var faJSONEditorCollapse = {
  prefix: "fas",
  iconName: "jsoneditor-collapse",
  icon: [
    512,
    512,
    [],
    null,
    "m 0,224 v 64 h 512 v -64 z M 256,192 384,64 H 128 Z M 256,320 128,448 h 256 z"
  ]
};
var faJSONEditorFormat = {
  prefix: "fas",
  iconName: "jsoneditor-format",
  icon: [
    512,
    512,
    [],
    null,
    "M 0,32 v 64 h 416 v -64 z M 160,160 v 64 h 352 v -64 z M 160,288 v 64 h 288 v -64 z M 0,416 v 64 h 320 v -64 z"
  ]
};
var faJSONEditorCompact = {
  prefix: "fas",
  iconName: "jsoneditor-compact",
  icon: [
    512,
    512,
    [],
    null,
    "M 0,32 v 64 h 512 v -64 z M 0,160 v 64 h 512 v -64 z M 0,288 v 64 h 352 v -64 z"
  ]
};

// ../node_modules/svelte-jsoneditor/components/controls/Menu.svelte
var file9 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/Menu.svelte";
function add_css6(target) {
  append_styles(target, "svelte-urexng", ".jse-menu.svelte-urexng.svelte-urexng{background:var(--jse-theme-color);border-bottom:1px solid var(--jse-theme-color);color:var(--jse-menu-color);display:flex;flex-wrap:wrap;align-items:center;position:relative}.jse-menu.svelte-urexng .jse-button.svelte-urexng{width:var(--jse-menu-button-size);height:var(--jse-menu-button-size);border:none;background:transparent;color:inherit;cursor:pointer;padding:calc(0.5 * var(--jse-padding));margin:0;border-radius:0}.jse-menu.svelte-urexng .jse-button.svelte-urexng:hover,.jse-menu.svelte-urexng .jse-button.svelte-urexng:focus{background:var(--jse-theme-color-highlight)}.jse-menu.svelte-urexng .jse-button.svelte-urexng:disabled{color:var(--jse-menu-color);opacity:0.5;background:transparent}.jse-menu.svelte-urexng .jse-button.jse-group-button.svelte-urexng{border:1px solid var(--jse-menu-color);padding:0;margin:calc(0.5 * var(--jse-padding)) 0;height:calc(var(--jse-menu-button-size) - var(--jse-padding));width:40px}.jse-menu.svelte-urexng .jse-button.jse-group-button.svelte-urexng:not(.jse-last){border-right:none}.jse-menu.svelte-urexng .jse-button.jse-group-button.jse-first.svelte-urexng{margin-left:calc(0.5 * var(--jse-padding))}.jse-menu.svelte-urexng .jse-button.jse-group-button.jse-last.svelte-urexng{margin-right:calc(0.5 * var(--jse-padding))}.jse-menu.svelte-urexng .jse-button.jse-group-button.svelte-urexng:hover,.jse-menu.svelte-urexng .jse-button.jse-group-button.svelte-urexng:focus{background:var(--jse-theme-color-highlight)}.jse-menu.svelte-urexng .jse-button.jse-group-button.jse-selected.svelte-urexng{background:var(--jse-menu-color);color:var(--jse-theme-color)}.jse-menu.svelte-urexng .jse-space.svelte-urexng{flex:1}.jse-menu.svelte-urexng .jse-separator.svelte-urexng{background:var(--jse-menu-color);opacity:0.3;box-sizing:border-box;width:1px;height:calc(var(--jse-menu-button-size) - 6px);margin:3px}.svelte-urexng.svelte-urexng{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUN3QixTQUFBLDRCQUFBLENBQUEsazFEQTZEdkIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVudS5zdmVsdGUiXX0= */");
}
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function create_else_block3(ctx) {
  let button;
  let t;
  let button_class_value;
  let button_title_value;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3].icon && create_if_block_33(ctx);
  let if_block1 = ctx[3].text && create_if_block_24(ctx);
  const block = {
    c: function create() {
      button = element("button");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      if (if_block0)
        if_block0.l(button_nodes);
      t = claim_space(button_nodes);
      if (if_block1)
        if_block1.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = "jse-button " + ctx[3].className + " svelte-urexng");
      attr_dev(button, "title", button_title_value = ctx[3].title);
      button.disabled = button_disabled_value = ctx[3].disabled || false;
      add_location(button, file9, 15, 6, 342);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block0)
        if_block0.m(button, null);
      append_hydration_dev(button, t);
      if (if_block1)
        if_block1.m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(ctx[3].onClick))
              ctx[3].onClick.apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[3].icon) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_33(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(button, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx[3].text) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_24(ctx);
          if_block1.c();
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 1 && button_class_value !== (button_class_value = "jse-button " + ctx[3].className + " svelte-urexng")) {
        attr_dev(button, "class", button_class_value);
      }
      if (!current || dirty & 1 && button_title_value !== (button_title_value = ctx[3].title)) {
        attr_dev(button, "title", button_title_value);
      }
      if (!current || dirty & 1 && button_disabled_value !== (button_disabled_value = ctx[3].disabled || false)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(15:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-space svelte-urexng");
      add_location(div, file9, 13, 6, 298);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(13:34) ",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-separator svelte-urexng");
      add_location(div, file9, 11, 6, 227);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(11:4) {#if item.separator === true}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: ctx[3].icon },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & 1)
        icon_changes.data = ctx2[3].icon;
      icon.$set(icon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(23:8) {#if item.icon}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let t_value = ctx[3].text + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[3].text + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(26:8) {#if item.text}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_if_block_15, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3].separator === true)
      return 0;
    if (ctx2[3].space === true)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(10:2) {#each items as item}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const left_slot_template = ctx[2].left;
  const left_slot = create_slot(left_slot_template, ctx, ctx[1], get_left_slot_context);
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const right_slot_template = ctx[2].right;
  const right_slot = create_slot(right_slot_template, ctx, ctx[1], get_right_slot_context);
  const block = {
    c: function create() {
      div = element("div");
      if (left_slot)
        left_slot.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (right_slot)
        right_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (left_slot)
        left_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t1 = claim_space(div_nodes);
      if (right_slot)
        right_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-menu svelte-urexng");
      add_location(div, file9, 6, 0, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (left_slot) {
        left_slot.m(div, null);
      }
      append_hydration_dev(div, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append_hydration_dev(div, t1);
      if (right_slot) {
        right_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(left_slot_template, ctx2[1], dirty, get_left_slot_changes),
            get_left_slot_context
          );
        }
      }
      if (dirty & 1) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t1);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(right_slot_template, ctx2[1], dirty, get_right_slot_changes),
            get_right_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(left_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(right_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(left_slot, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(right_slot, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (left_slot)
        left_slot.d(detaching);
      destroy_each(each_blocks, detaching);
      if (right_slot)
        right_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, ["left", "right"]);
  let { items = [] } = $$props;
  const writable_props = ["items"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Menu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ Icon: Icon_default, items });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [items, $$scope, slots];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, not_equal, { items: 0 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment11.name
    });
  }
  get items() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// ../node_modules/svelte-jsoneditor/components/modes/textmode/menu/TextMenu.svelte
function create_fragment12(ctx) {
  let menu;
  let current;
  menu = new Menu_default({
    props: { items: ctx[0] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(menu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(menu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 1)
        menu_changes.items = ctx2[0];
      menu.$set(menu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(menu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let defaultItems;
  let items;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextMenu", slots, []);
  let { readOnly = false } = $$props;
  let { onFormat } = $$props;
  let { onCompact } = $$props;
  let { onSort } = $$props;
  let { onTransform } = $$props;
  let { onToggleSearch } = $$props;
  let { onUndo } = $$props;
  let { onRedo } = $$props;
  let { canUndo } = $$props;
  let { canRedo } = $$props;
  let { canFormat } = $$props;
  let { canCompact } = $$props;
  let { canSort } = $$props;
  let { canTransform } = $$props;
  let { onRenderMenu = noop_default } = $$props;
  $$self.$$.on_mount.push(function() {
    if (onFormat === void 0 && !("onFormat" in $$props || $$self.$$.bound[$$self.$$.props["onFormat"]])) {
      console.warn("<TextMenu> was created without expected prop 'onFormat'");
    }
    if (onCompact === void 0 && !("onCompact" in $$props || $$self.$$.bound[$$self.$$.props["onCompact"]])) {
      console.warn("<TextMenu> was created without expected prop 'onCompact'");
    }
    if (onSort === void 0 && !("onSort" in $$props || $$self.$$.bound[$$self.$$.props["onSort"]])) {
      console.warn("<TextMenu> was created without expected prop 'onSort'");
    }
    if (onTransform === void 0 && !("onTransform" in $$props || $$self.$$.bound[$$self.$$.props["onTransform"]])) {
      console.warn("<TextMenu> was created without expected prop 'onTransform'");
    }
    if (onToggleSearch === void 0 && !("onToggleSearch" in $$props || $$self.$$.bound[$$self.$$.props["onToggleSearch"]])) {
      console.warn("<TextMenu> was created without expected prop 'onToggleSearch'");
    }
    if (onUndo === void 0 && !("onUndo" in $$props || $$self.$$.bound[$$self.$$.props["onUndo"]])) {
      console.warn("<TextMenu> was created without expected prop 'onUndo'");
    }
    if (onRedo === void 0 && !("onRedo" in $$props || $$self.$$.bound[$$self.$$.props["onRedo"]])) {
      console.warn("<TextMenu> was created without expected prop 'onRedo'");
    }
    if (canUndo === void 0 && !("canUndo" in $$props || $$self.$$.bound[$$self.$$.props["canUndo"]])) {
      console.warn("<TextMenu> was created without expected prop 'canUndo'");
    }
    if (canRedo === void 0 && !("canRedo" in $$props || $$self.$$.bound[$$self.$$.props["canRedo"]])) {
      console.warn("<TextMenu> was created without expected prop 'canRedo'");
    }
    if (canFormat === void 0 && !("canFormat" in $$props || $$self.$$.bound[$$self.$$.props["canFormat"]])) {
      console.warn("<TextMenu> was created without expected prop 'canFormat'");
    }
    if (canCompact === void 0 && !("canCompact" in $$props || $$self.$$.bound[$$self.$$.props["canCompact"]])) {
      console.warn("<TextMenu> was created without expected prop 'canCompact'");
    }
    if (canSort === void 0 && !("canSort" in $$props || $$self.$$.bound[$$self.$$.props["canSort"]])) {
      console.warn("<TextMenu> was created without expected prop 'canSort'");
    }
    if (canTransform === void 0 && !("canTransform" in $$props || $$self.$$.bound[$$self.$$.props["canTransform"]])) {
      console.warn("<TextMenu> was created without expected prop 'canTransform'");
    }
  });
  const writable_props = [
    "readOnly",
    "onFormat",
    "onCompact",
    "onSort",
    "onTransform",
    "onToggleSearch",
    "onUndo",
    "onRedo",
    "canUndo",
    "canRedo",
    "canFormat",
    "canCompact",
    "canSort",
    "canTransform",
    "onRenderMenu"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TextMenu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onFormat" in $$props2)
      $$invalidate(2, onFormat = $$props2.onFormat);
    if ("onCompact" in $$props2)
      $$invalidate(3, onCompact = $$props2.onCompact);
    if ("onSort" in $$props2)
      $$invalidate(4, onSort = $$props2.onSort);
    if ("onTransform" in $$props2)
      $$invalidate(5, onTransform = $$props2.onTransform);
    if ("onToggleSearch" in $$props2)
      $$invalidate(6, onToggleSearch = $$props2.onToggleSearch);
    if ("onUndo" in $$props2)
      $$invalidate(7, onUndo = $$props2.onUndo);
    if ("onRedo" in $$props2)
      $$invalidate(8, onRedo = $$props2.onRedo);
    if ("canUndo" in $$props2)
      $$invalidate(9, canUndo = $$props2.canUndo);
    if ("canRedo" in $$props2)
      $$invalidate(10, canRedo = $$props2.canRedo);
    if ("canFormat" in $$props2)
      $$invalidate(11, canFormat = $$props2.canFormat);
    if ("canCompact" in $$props2)
      $$invalidate(12, canCompact = $$props2.canCompact);
    if ("canSort" in $$props2)
      $$invalidate(13, canSort = $$props2.canSort);
    if ("canTransform" in $$props2)
      $$invalidate(14, canTransform = $$props2.canTransform);
    if ("onRenderMenu" in $$props2)
      $$invalidate(15, onRenderMenu = $$props2.onRenderMenu);
  };
  $$self.$capture_state = () => ({
    faFilter,
    faRedo,
    faSearch,
    faSortAmountDownAlt,
    faUndo,
    faJSONEditorCompact,
    faJSONEditorFormat,
    Menu: Menu_default,
    noop: noop_default,
    readOnly,
    onFormat,
    onCompact,
    onSort,
    onTransform,
    onToggleSearch,
    onUndo,
    onRedo,
    canUndo,
    canRedo,
    canFormat,
    canCompact,
    canSort,
    canTransform,
    onRenderMenu,
    defaultItems,
    items
  });
  $$self.$inject_state = ($$props2) => {
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onFormat" in $$props2)
      $$invalidate(2, onFormat = $$props2.onFormat);
    if ("onCompact" in $$props2)
      $$invalidate(3, onCompact = $$props2.onCompact);
    if ("onSort" in $$props2)
      $$invalidate(4, onSort = $$props2.onSort);
    if ("onTransform" in $$props2)
      $$invalidate(5, onTransform = $$props2.onTransform);
    if ("onToggleSearch" in $$props2)
      $$invalidate(6, onToggleSearch = $$props2.onToggleSearch);
    if ("onUndo" in $$props2)
      $$invalidate(7, onUndo = $$props2.onUndo);
    if ("onRedo" in $$props2)
      $$invalidate(8, onRedo = $$props2.onRedo);
    if ("canUndo" in $$props2)
      $$invalidate(9, canUndo = $$props2.canUndo);
    if ("canRedo" in $$props2)
      $$invalidate(10, canRedo = $$props2.canRedo);
    if ("canFormat" in $$props2)
      $$invalidate(11, canFormat = $$props2.canFormat);
    if ("canCompact" in $$props2)
      $$invalidate(12, canCompact = $$props2.canCompact);
    if ("canSort" in $$props2)
      $$invalidate(13, canSort = $$props2.canSort);
    if ("canTransform" in $$props2)
      $$invalidate(14, canTransform = $$props2.canTransform);
    if ("onRenderMenu" in $$props2)
      $$invalidate(15, onRenderMenu = $$props2.onRenderMenu);
    if ("defaultItems" in $$props2)
      $$invalidate(16, defaultItems = $$props2.defaultItems);
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32766) {
      $:
        $$invalidate(16, defaultItems = !readOnly ? [
          {
            icon: faJSONEditorFormat,
            title: "Format JSON: add proper indentation and new lines (Ctrl+I)",
            className: "jse-format",
            onClick: onFormat,
            disabled: readOnly || !canFormat
          },
          {
            icon: faJSONEditorCompact,
            title: "Compact JSON: remove all white spacing and new lines (Ctrl+Shift+I)",
            className: "jse-compact",
            onClick: onCompact,
            disabled: readOnly || !canCompact
          },
          { separator: true },
          {
            icon: faSortAmountDownAlt,
            title: "Sort",
            className: "jse-sort",
            onClick: onSort,
            disabled: readOnly || !canSort
          },
          {
            icon: faFilter,
            title: "Transform contents (filter, sort, project)",
            className: "jse-transform",
            onClick: onTransform,
            disabled: readOnly || !canTransform
          },
          {
            icon: faSearch,
            title: "Search (Ctrl+F)",
            className: "jse-search",
            onClick: onToggleSearch
          },
          { separator: true },
          {
            icon: faUndo,
            title: "Undo (Ctrl+Z)",
            className: "jse-undo",
            onClick: onUndo,
            disabled: !canUndo
          },
          {
            icon: faRedo,
            title: "Redo (Ctrl+Shift+Z)",
            className: "jse-redo",
            onClick: onRedo,
            disabled: !canRedo
          },
          { space: true }
        ] : [{ space: true }]);
    }
    if ($$self.$$.dirty & 98304) {
      $:
        $$invalidate(0, items = onRenderMenu("text", defaultItems) || defaultItems);
    }
  };
  return [
    items,
    readOnly,
    onFormat,
    onCompact,
    onSort,
    onTransform,
    onToggleSearch,
    onUndo,
    onRedo,
    canUndo,
    canRedo,
    canFormat,
    canCompact,
    canSort,
    canTransform,
    onRenderMenu,
    defaultItems
  ];
}
var TextMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, not_equal, {
      readOnly: 1,
      onFormat: 2,
      onCompact: 3,
      onSort: 4,
      onTransform: 5,
      onToggleSearch: 6,
      onUndo: 7,
      onRedo: 8,
      canUndo: 9,
      canRedo: 10,
      canFormat: 11,
      canCompact: 12,
      canSort: 13,
      canTransform: 14,
      onRenderMenu: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextMenu",
      options,
      id: create_fragment12.name
    });
  }
  get readOnly() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFormat() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFormat(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCompact() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCompact(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSort() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSort(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTransform() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTransform(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onToggleSearch() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onToggleSearch(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onUndo() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onUndo(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRedo() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRedo(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canUndo() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canUndo(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canRedo() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canRedo(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canFormat() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canFormat(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canCompact() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canCompact(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canSort() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canSort(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canTransform() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canTransform(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderMenu() {
    throw new Error("<TextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderMenu(value) {
    throw new Error("<TextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextMenu_default = TextMenu;

// ../node_modules/svelte-jsoneditor/components/modes/textmode/TextMode.svelte
var import_json_source_map2 = __toESM(require_json_source_map(), 1);

// ../node_modules/svelte-jsoneditor/components/modes/textmode/StatusBar.svelte
var file10 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/textmode/StatusBar.svelte";
function add_css7(target) {
  append_styles(target, "svelte-haet46", ".jse-status-bar.svelte-haet46.svelte-haet46{background:var(--jse-panel-background);color:var(--jse-panel-color-readonly);font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);margin:0;border-top:var(--jse-panel-border);border-left:var(--jse-main-border);border-right:var(--jse-main-border);display:flex;gap:var(--jse-padding)}.jse-status-bar.svelte-haet46.svelte-haet46:last-child{border-bottom:var(--jse-main-border)}.jse-status-bar.svelte-haet46 .jse-status-bar-info.svelte-haet46{padding:2px}.svelte-haet46.svelte-haet46{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhdHVzQmFyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE2QjZCLGVBQUEsNEJBQUEsQ0FBQSx1ZkFpQjVCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlN0YXR1c0Jhci5zdmVsdGUiXX0= */");
}
function create_if_block_25(ctx) {
  let div;
  let t0;
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Line: ");
      t1 = text(ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Line: ");
      t1 = claim_text(div_nodes, ctx[0]);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-status-bar-info svelte-haet46");
      add_location(div, file10, 17, 4, 505);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t1, ctx2[0]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(17:2) {#if lineNumber !== undefined}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let t0;
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Column: ");
      t1 = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Column: ");
      t1 = claim_text(div_nodes, ctx[1]);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-status-bar-info svelte-haet46");
      add_location(div, file10, 21, 4, 611);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t1, ctx2[1]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(21:2) {#if columnNumber !== undefined}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Selection: ");
      t1 = text(ctx[2]);
      t2 = text(" characters");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Selection: ");
      t1 = claim_text(div_nodes, ctx[2]);
      t2 = claim_text(div_nodes, " characters");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-status-bar-info svelte-haet46");
      add_location(div, file10, 25, 4, 735);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t1, ctx2[2]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(25:2) {#if charCount !== undefined && charCount > 0}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div;
  let t0;
  let t1;
  let if_block0 = ctx[0] !== void 0 && create_if_block_25(ctx);
  let if_block1 = ctx[1] !== void 0 && create_if_block_16(ctx);
  let if_block2 = ctx[2] !== void 0 && ctx[2] > 0 && create_if_block7(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-status-bar svelte-haet46");
      add_location(div, file10, 15, 0, 439);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0] !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_25(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1] !== void 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_16(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[2] !== void 0 && ctx2[2] > 0) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block7(ctx2);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StatusBar", slots, []);
  let { editorState } = $$props;
  let pos;
  let line;
  let lineNumber;
  let columnNumber;
  let charCount;
  $$self.$$.on_mount.push(function() {
    if (editorState === void 0 && !("editorState" in $$props || $$self.$$.bound[$$self.$$.props["editorState"]])) {
      console.warn("<StatusBar> was created without expected prop 'editorState'");
    }
  });
  const writable_props = ["editorState"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<StatusBar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("editorState" in $$props2)
      $$invalidate(3, editorState = $$props2.editorState);
  };
  $$self.$capture_state = () => ({
    editorState,
    pos,
    line,
    lineNumber,
    columnNumber,
    charCount
  });
  $$self.$inject_state = ($$props2) => {
    if ("editorState" in $$props2)
      $$invalidate(3, editorState = $$props2.editorState);
    if ("pos" in $$props2)
      $$invalidate(4, pos = $$props2.pos);
    if ("line" in $$props2)
      $$invalidate(5, line = $$props2.line);
    if ("lineNumber" in $$props2)
      $$invalidate(0, lineNumber = $$props2.lineNumber);
    if ("columnNumber" in $$props2)
      $$invalidate(1, columnNumber = $$props2.columnNumber);
    if ("charCount" in $$props2)
      $$invalidate(2, charCount = $$props2.charCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c, _d, _e;
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(4, pos = (_b = (_a = editorState == null ? void 0 : editorState.selection) == null ? void 0 : _a.main) == null ? void 0 : _b.head);
    }
    if ($$self.$$.dirty & 24) {
      $:
        $$invalidate(5, line = (_c = editorState == null ? void 0 : editorState.doc) == null ? void 0 : _c.lineAt(pos));
    }
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(0, lineNumber = line ? line.number : void 0);
    }
    if ($$self.$$.dirty & 48) {
      $:
        $$invalidate(1, columnNumber = line ? pos - line.from + 1 : void 0);
    }
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(2, charCount = (_e = (_d = editorState == null ? void 0 : editorState.selection) == null ? void 0 : _d.ranges) == null ? void 0 : _e.reduce(
          (count, range) => {
            return count + range.to - range.from;
          },
          0
        ));
    }
  };
  return [lineNumber, columnNumber, charCount, editorState, pos, line];
}
var StatusBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { editorState: 3 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StatusBar",
      options,
      id: create_fragment13.name
    });
  }
  get editorState() {
    throw new Error("<StatusBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set editorState(value) {
    throw new Error("<StatusBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StatusBar_default = StatusBar;

// ../node_modules/svelte-jsoneditor/components/modes/textmode/codemirror/codemirror-theme.js
var highlightStyle = HighlightStyle.define([
  { tag: tags.propertyName, color: "var(--jse-key-color)" },
  { tag: tags.number, color: "var(--jse-value-color-number)" },
  { tag: tags.bool, color: "var(--jse-value-color-boolean)" },
  { tag: tags.string, color: "var(--jse-value-color-string)" },
  { tag: tags.keyword, color: "var(--jse-value-color-null)" }
]);
var highlighter = syntaxHighlighting(highlightStyle);
var originalStyle = highlightStyle.style;
highlightStyle.style = (tags2) => originalStyle(tags2 || []);

// ../node_modules/svelte-jsoneditor/typeguards.js
function isMenuSpaceItem(item) {
  return item && item["space"] === true && Object.keys(item).length === 1;
}
function isContentParseError(contentErrors) {
  return typeof contentErrors["parseError"] === "object" && contentErrors["parseError"] !== null;
}
function isContentValidationErrors(contentErrors) {
  return Array.isArray(contentErrors["validationErrors"]);
}

// ../node_modules/svelte-jsoneditor/utils/timeUtils.js
function measure(callback, onDuration) {
  const start = Date.now();
  const result = callback();
  const end = Date.now();
  onDuration(end - start);
  return result;
}

// ../node_modules/svelte-jsoneditor/logic/validation.js
var debug2 = createDebug("validation");
function mapValidationErrors(validationErrors) {
  const map = {};
  validationErrors.forEach((validationError) => {
    map[compileJSONPointer(validationError.path)] = validationError;
  });
  validationErrors.forEach((validationError) => {
    let parentPath = validationError.path;
    while (parentPath.length > 0) {
      parentPath = initial_default(parentPath);
      const parentPointer = compileJSONPointer(parentPath);
      if (!(parentPointer in map)) {
        map[parentPointer] = {
          isChildError: true,
          path: parentPath,
          message: "Contains invalid data"
        };
      }
    }
  });
  return map;
}
function validateJSON(json2, validator, parser, validationParser) {
  debug2("validateJSON");
  if (!validator) {
    return [];
  }
  if (parser !== validationParser) {
    const convertedJSON = validationParser.parse(parser.stringify(json2));
    return validator(convertedJSON);
  } else {
    return validator(json2);
  }
}
function validateText(text2, validator, parser, validationParser) {
  debug2("validateText");
  if (text2.length > MAX_VALIDATABLE_SIZE) {
    const validationError = {
      path: [],
      message: "Validation turned off: the document is too large",
      severity: ValidationSeverity.info
    };
    return {
      validationErrors: [validationError]
    };
  }
  if (text2.length === 0) {
    return {
      validationErrors: []
    };
  }
  try {
    const json2 = measure(() => parser.parse(text2), (duration) => debug2(`validate: parsed json in ${duration} ms`));
    if (!validator) {
      return {
        validationErrors: []
      };
    }
    const convertedJSON = parser === validationParser ? json2 : measure(() => validationParser.parse(text2), (duration) => debug2(`validate: parsed json with the validationParser in ${duration} ms`));
    const validationErrors = measure(() => validator(convertedJSON), (duration) => debug2(`validate: validated json in ${duration} ms`));
    return { validationErrors };
  } catch (err) {
    const isRepairable = measure(() => canAutoRepair(text2, parser), (duration) => debug2(`validate: checked whether repairable in ${duration} ms`));
    const parseError = normalizeJsonParseError(text2, err.message || err.toString());
    return {
      parseError,
      isRepairable
    };
  }
}
function canAutoRepair(text2, parser) {
  if (text2.length > MAX_AUTO_REPAIRABLE_SIZE) {
    return false;
  }
  try {
    parser.parse(jsonrepair(text2));
    return true;
  } catch (err) {
    return false;
  }
}

// ../node_modules/svelte-jsoneditor/components/modes/textmode/TextMode.svelte
var { Object: Object_13, console: console_12 } = globals;
var file11 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/textmode/TextMode.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1lcuxc8", '.jse-text-mode.svelte-1lcuxc8.svelte-1lcuxc8{flex:1;box-sizing:border-box;display:flex;flex-direction:column;background:var(--jse-background-color)}.jse-text-mode.no-main-menu.svelte-1lcuxc8.svelte-1lcuxc8{border-top:var(--jse-main-border)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8{flex:1;display:flex;flex-direction:column;overflow:hidden;min-width:0;min-height:0;border-left:var(--jse-main-border);border-right:var(--jse-main-border)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8:last-child{border-bottom:var(--jse-main-border)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.jse-hidden.svelte-1lcuxc8{visibility:hidden}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor{flex:1;overflow:hidden}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-scroller{font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);line-height:var(--jse-line-height);color:var(--jse-delimiter-color)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-gutters{background:var(--jse-panel-background);color:var(--jse-panel-color-readonly);border-right:var(--jse-panel-border)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-activeLine,.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-activeLineGutter{background:var(--jse-active-line-background-color)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-selectionBackground{background:var(--jse-selection-background-color)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-searchMatch{background-color:var(--jse-search-match-color);outline:var(--jse-search-match-outline)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-searchMatch.cm-searchMatch-selected{background-color:var(--jse-search-match-active-color);outline:var(--jse-search-match-active-outline)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-selectionMatch{background-color:var(--jse-search-match-background-color)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-foldPlaceholder{background:var(--jse-tag-background);color:var(--jse-tag-color);border:none;padding:0 var(--jse-padding)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-tooltip{font-size:var(--jse-font-size);font-family:var(--jse-font-family);color:var(--jse-tooltip-color);background:var(--jse-tooltip-background);border:var(--jse-tooltip-border)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-diagnosticAction{background:var(--jse-tooltip-action-button-color);background:var(--jse-tooltip-action-button-background)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-panels{border-bottom:var(--jse-panel-border)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-search{background:var(--jse-panel-background);color:var(--jse-panel-color);font-family:var(--jse-font-family);font-size:var(--jse-font-size)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-search input{font-family:var(--jse-font-family);font-size:var(--jse-font-size-text-mode-search);color:var(--jse-input-color);border:var(--jse-input-border);background:var(--jse-input-background);margin-right:2px}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-search button{font-family:var(--jse-font-family);font-size:var(--jse-font-size-text-mode-search);color:var(--jse-panel-button-color);background:var(--jse-panel-button-background);border:none;cursor:pointer;text-transform:capitalize;padding:calc(0.5 * var(--jse-padding)) var(--jse-padding);margin:0}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-search button:hover{color:var(--jse-panel-button-color-highlight);background:var(--jse-panel-button-background-highlight)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-search label{font-family:var(--jse-font-family);font-size:var(--jse-font-size-text-mode-search);padding-left:var(--jse-padding)}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-search label input{margin-right:2px}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-search button[name="close"]{width:32px;height:32px;font-size:24px;line-height:24px;padding:0;right:0;top:-4px}.jse-text-mode.svelte-1lcuxc8 .jse-contents.svelte-1lcuxc8 .cm-editor .cm-cursor-primary{border-color:var(--jse-text-color)}.jse-text-mode.svelte-1lcuxc8 .jse-contents .jse-loading-space.svelte-1lcuxc8{flex:1}.jse-text-mode.svelte-1lcuxc8 .jse-contents .jse-loading.svelte-1lcuxc8{flex:2;text-align:center;color:var(--jse-panel-color-readonly);box-sizing:border-box;font-family:var(--jse-font-family);font-size:var(--jse-font-size)}.svelte-1lcuxc8.svelte-1lcuxc8{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dE1vZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRzQjRCLGNBQUEsOEJBQUEsQ0FBQSw2c0pBMEkzQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUZXh0TW9kZS5zdmVsdGUiXX0= */');
}
function create_if_block_5(ctx) {
  let textmenu;
  let current;
  textmenu = new TextMenu_default({
    props: {
      readOnly: ctx[0],
      onFormat: ctx[17],
      onCompact: ctx[18],
      onSort: ctx[19],
      onTransform: ctx[20],
      onToggleSearch: ctx[21],
      onUndo: ctx[22],
      onRedo: ctx[23],
      canFormat: !ctx[15],
      canCompact: !ctx[15],
      canSort: !ctx[15],
      canTransform: !ctx[15],
      canUndo: ctx[11],
      canRedo: ctx[12],
      onRenderMenu: ctx[4]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(textmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textmenu_changes = {};
      if (dirty[0] & 1)
        textmenu_changes.readOnly = ctx2[0];
      if (dirty[0] & 32768)
        textmenu_changes.canFormat = !ctx2[15];
      if (dirty[0] & 32768)
        textmenu_changes.canCompact = !ctx2[15];
      if (dirty[0] & 32768)
        textmenu_changes.canSort = !ctx2[15];
      if (dirty[0] & 32768)
        textmenu_changes.canTransform = !ctx2[15];
      if (dirty[0] & 2048)
        textmenu_changes.canUndo = ctx2[11];
      if (dirty[0] & 4096)
        textmenu_changes.canRedo = ctx2[12];
      if (dirty[0] & 16)
        textmenu_changes.onRenderMenu = ctx2[4];
      textmenu.$set(textmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(textmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(637:2) {#if mainMenuBar}",
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text("loading...");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, "loading...");
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-loading-space svelte-1lcuxc8");
      add_location(div0, file11, 710, 6, 23341);
      attr_dev(div1, "class", "jse-loading svelte-1lcuxc8");
      add_location(div1, file11, 711, 6, 23381);
      attr_dev(div2, "class", "jse-contents svelte-1lcuxc8");
      add_location(div2, file11, 709, 4, 23308);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(709:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[10] && create_if_block_4(ctx);
  let if_block1 = ctx[2] && create_if_block_34(ctx);
  let if_block2 = !ctx[10] && create_if_block_17(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-contents svelte-1lcuxc8");
      toggle_class(div, "jse-hidden", ctx[10]);
      add_location(div, file11, 689, 4, 22735);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      ctx[48](div);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[10]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(div, "jse-hidden", ctx2[10]);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_34(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[10]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_17(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy2(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      ctx[48](null);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(657:2) {#if !isSSR}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let message;
  let current;
  message = new Message_default({
    props: {
      icon: faExclamationTriangle,
      type: "error",
      message: `The JSON document is larger than ${formatSize(MAX_DOCUMENT_SIZE_TEXT_MODE, 1024)}, and may crash your browser when loading it in text mode. Actual size: ${formatSize(ctx[5].length, 1024)}.`,
      actions: [
        {
          text: "Open anyway",
          title: "Open the document in text mode. This may freeze or crash your browser.",
          onClick: ctx[24]
        },
        {
          text: "Open in tree mode",
          title: "Open the document in tree mode. Tree mode can handle large documents.",
          onClick: ctx[3]
        },
        {
          text: "Cancel",
          title: "Cancel opening this large document.",
          onClick: ctx[25]
        }
      ]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty[0] & 32)
        message_changes.message = `The JSON document is larger than ${formatSize(MAX_DOCUMENT_SIZE_TEXT_MODE, 1024)}, and may crash your browser when loading it in text mode. Actual size: ${formatSize(ctx2[5].length, 1024)}.`;
      if (dirty[0] & 8)
        message_changes.actions = [
          {
            text: "Open anyway",
            title: "Open the document in text mode. This may freeze or crash your browser.",
            onClick: ctx2[24]
          },
          {
            text: "Open in tree mode",
            title: "Open the document in tree mode. Tree mode can handle large documents.",
            onClick: ctx2[3]
          },
          {
            text: "Cancel",
            title: "Cancel opening this large document.",
            onClick: ctx2[25]
          }
        ];
      message.$set(message_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(message, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(658:4) {#if editorDisabled}",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let statusbar;
  let current;
  statusbar = new StatusBar_default({
    props: { editorState: ctx[8] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(statusbar.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(statusbar.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(statusbar, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const statusbar_changes = {};
      if (dirty[0] & 256)
        statusbar_changes.editorState = ctx2[8];
      statusbar.$set(statusbar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(statusbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(statusbar.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(statusbar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(692:4) {#if statusBar}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let t;
  let validationerrorsoverview;
  let current;
  let if_block = ctx[13] && create_if_block_26(ctx);
  validationerrorsoverview = new ValidationErrorsOverview_default({
    props: {
      validationErrors: ctx[9],
      selectError: ctx[26]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(validationerrorsoverview.$$.fragment);
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      claim_component(validationerrorsoverview.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(validationerrorsoverview, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[13]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const validationerrorsoverview_changes = {};
      if (dirty[0] & 512)
        validationerrorsoverview_changes.validationErrors = ctx2[9];
      validationerrorsoverview.$set(validationerrorsoverview_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(validationerrorsoverview.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(validationerrorsoverview.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(validationerrorsoverview, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(696:4) {#if !editorDisabled}",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let message;
  let current;
  message = new Message_default({
    props: {
      type: "error",
      icon: faExclamationTriangle,
      message: ctx[13].message,
      actions: ctx[14],
      onClick: ctx[49]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty[0] & 8192)
        message_changes.message = ctx2[13].message;
      if (dirty[0] & 16384)
        message_changes.actions = ctx2[14];
      if (dirty[0] & 8192)
        message_changes.onClick = ctx2[49];
      message.$set(message_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(message, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(697:6) {#if jsonParseError}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = ctx[1] && create_if_block_5(ctx);
  const if_block_creators = [create_if_block8, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[16])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-text-mode svelte-1lcuxc8");
      toggle_class(div, "no-main-menu", !ctx[1]);
      add_location(div, file11, 635, 0, 21183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t);
      if_blocks[current_block_type_index].m(div, null);
      ctx[50](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if_block1.p(ctx2, dirty);
      if (!current || dirty[0] & 2) {
        toggle_class(div, "no-main-menu", !ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[50](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function toDiagnostic(error) {
  return {
    from: error.from,
    to: error.to,
    message: error.message,
    actions: error.actions,
    severity: error.severity,
    source: void 0
  };
}
function instance14($$self, $$props, $$invalidate) {
  let isNewDocument;
  let normalization;
  let repairActions;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextMode", slots, []);
  let { readOnly } = $$props;
  let { mainMenuBar } = $$props;
  let { statusBar } = $$props;
  let { externalContent } = $$props;
  let { indentation } = $$props;
  let { tabSize } = $$props;
  let { escapeUnicodeCharacters } = $$props;
  let { parser } = $$props;
  let { validator } = $$props;
  let { validationParser } = $$props;
  let { onChange } = $$props;
  let { onSwitchToTreeMode } = $$props;
  let { onError } = $$props;
  let { onFocus } = $$props;
  let { onBlur } = $$props;
  let { onRenderMenu } = $$props;
  let { onSortModal } = $$props;
  let { onTransformModal } = $$props;
  const debug5 = createDebug("jsoneditor:TextMode");
  const formatCompactKeyBinding = {
    key: "Mod-i",
    run: handleFormat,
    shift: handleCompact,
    preventDefault: true
  };
  const isSSR = typeof window === "undefined";
  debug5("isSSR:", isSSR);
  let codeMirrorRef;
  let codeMirrorView;
  let domTextMode;
  let editorState;
  let onChangeDisabled = false;
  let acceptTooLarge = false;
  let validationErrors = [];
  const linterCompartment = new Compartment();
  const editableCompartment = new Compartment();
  const readOnlyCompartment = new Compartment();
  const indentUnitCompartment = new Compartment();
  const tabSizeCompartment = new Compartment();
  let content = externalContent;
  let text2 = getText(content, indentation, parser);
  let editorDisabled = disableTextEditor(text2, acceptTooLarge);
  let previousEscapeUnicodeCharacters = escapeUnicodeCharacters;
  onMount(async () => {
    if (isSSR) {
      return;
    }
    try {
      codeMirrorView = createCodeMirrorView({
        target: codeMirrorRef,
        initialText: !editorDisabled ? normalization.escapeValue(text2) : "",
        readOnly,
        indentation
      });
      focus3();
    } catch (err) {
      console.error(err);
    }
  });
  onDestroy(() => {
    if (codeMirrorView) {
      debug5("Destroy CodeMirror editor");
      codeMirrorView.destroy();
    }
  });
  let canUndo = false;
  let canRedo = false;
  const sortModalId = uniqueId_default();
  const transformModalId = uniqueId_default();
  function focus3() {
    if (codeMirrorView) {
      debug5("focus");
      codeMirrorView.focus();
    }
  }
  let modalOpen = false;
  createFocusTracker({
    onMount,
    onDestroy,
    getWindow: () => getWindow(domTextMode),
    hasFocus: () => modalOpen && document.hasFocus() || activeElementIsChildOf(domTextMode),
    onFocus,
    onBlur
  });
  function patch(operations) {
    debug5("patch", operations);
    const previousJson = parser.parse(text2);
    const updatedJson = immutableJSONPatch(previousJson, operations);
    const undo2 = revertJSONPatch(previousJson, operations);
    setCodeMirrorContent({
      text: parser.stringify(updatedJson, null, indentation)
    });
    return {
      json: updatedJson,
      previousJson,
      undo: undo2,
      redo: operations
    };
  }
  function handleFormat() {
    debug5("format");
    if (readOnly) {
      return;
    }
    try {
      const json2 = parser.parse(text2);
      setCodeMirrorContent({
        text: parser.stringify(json2, null, indentation)
      });
    } catch (err) {
      onError(err);
    }
  }
  function handleCompact() {
    debug5("compact");
    if (readOnly) {
      return;
    }
    try {
      const json2 = parser.parse(text2);
      setCodeMirrorContent({ text: parser.stringify(json2) });
    } catch (err) {
      onError(err);
    }
  }
  function handleRepair() {
    debug5("repair");
    if (readOnly) {
      return;
    }
    try {
      setCodeMirrorContent({ text: jsonrepair(text2) });
      $$invalidate(47, jsonStatus = JSON_STATUS_VALID);
      $$invalidate(13, jsonParseError = void 0);
    } catch (err) {
      onError(err);
    }
  }
  function handleSort() {
    if (readOnly) {
      return;
    }
    try {
      const json2 = parser.parse(text2);
      modalOpen = true;
      onSortModal({
        id: sortModalId,
        json: json2,
        selectedPath: [],
        onSort: async (operations) => {
          debug5("onSort", operations);
          patch(operations);
        },
        onClose: () => {
          modalOpen = false;
          focus3();
        }
      });
    } catch (err) {
      onError(err);
    }
  }
  function openTransformModal({ id: id2, selectedPath, onTransform, onClose }) {
    try {
      const json2 = parser.parse(text2);
      modalOpen = true;
      onTransformModal({
        id: id2 || transformModalId,
        json: json2,
        selectedPath,
        onTransform: onTransform ? (operations) => {
          onTransform({
            operations,
            json: json2,
            transformedJson: immutableJSONPatch(json2, operations)
          });
        } : (operations) => {
          debug5("onTransform", operations);
          patch(operations);
        },
        onClose: () => {
          modalOpen = false;
          focus3();
          if (onClose) {
            onClose();
          }
        }
      });
    } catch (err) {
      onError(err);
    }
  }
  function handleTransform() {
    if (readOnly) {
      return;
    }
    openTransformModal({ selectedPath: [] });
  }
  function handleToggleSearch() {
    if (codeMirrorView) {
      if (codeMirrorRef && codeMirrorRef.querySelector(".cm-search")) {
        closeSearchPanel(codeMirrorView);
      } else {
        openSearchPanel(codeMirrorView);
      }
    }
  }
  function handleUndo() {
    if (readOnly) {
      return;
    }
    if (codeMirrorView) {
      undo(codeMirrorView);
      focus3();
    }
  }
  function handleRedo() {
    if (readOnly) {
      return;
    }
    if (codeMirrorView) {
      redo(codeMirrorView);
      focus3();
    }
  }
  function handleAcceptTooLarge() {
    acceptTooLarge = true;
    setCodeMirrorContent(externalContent, true);
  }
  function cancelLoadTooLarge() {
    onChangeCodeMirrorValue();
  }
  function handleSelectValidationError(validationError) {
    debug5("select validation error", validationError);
    const richValidationError = toRichValidationError(validationError);
    setSelection(richValidationError.from, richValidationError.to);
    focus3();
  }
  function handleSelectParseError(parseError) {
    debug5("select parse error", parseError);
    const richParseError = toRichParseError(parseError, false);
    setSelection(richParseError.from, richParseError.to);
    focus3();
  }
  function setSelection(anchor, head) {
    debug5("setSelection", { anchor, head });
    if (codeMirrorView) {
      codeMirrorView.dispatch(codeMirrorView.state.update({
        selection: { anchor, head },
        scrollIntoView: true
      }));
    }
  }
  function handleDoubleClick(event, view) {
    if (view.state.selection.ranges.length === 1) {
      const range = view.state.selection.ranges[0];
      const selectedText = text2.slice(range.from, range.to);
      if (selectedText === "{" || selectedText === "[") {
        const jsmap = import_json_source_map2.default.parse(text2);
        const path = Object.keys(jsmap.pointers).find((path2) => {
          var _a;
          const pointer2 = jsmap.pointers[path2];
          return ((_a = pointer2.value) == null ? void 0 : _a.pos) === range.from;
        });
        const pointer = jsmap.pointers[path];
        if (path && pointer && pointer.value && pointer.valueEnd) {
          debug5("pointer found, selecting inner contents of path:", path, pointer);
          const anchor = pointer.value.pos + 1;
          const head = pointer.valueEnd.pos - 1;
          setSelection(anchor, head);
        }
      }
    }
  }
  function createLinter() {
    return linter(linterCallback, { delay: TEXT_MODE_ONCHANGE_DELAY });
  }
  function createCodeMirrorView({ target, initialText, readOnly: readOnly2, indentation: indentation2 }) {
    debug5("Create CodeMirror editor", { readOnly: readOnly2, indentation: indentation2 });
    const state = EditorState.create({
      doc: initialText,
      extensions: [
        keymap.of([indentWithTab, formatCompactKeyBinding]),
        linterCompartment.of(createLinter()),
        lintGutter(),
        basicSetup,
        highlighter,
        EditorView.domEventHandlers({ dblclick: handleDoubleClick }),
        EditorView.updateListener.of((update) => {
          $$invalidate(8, editorState = update.state);
          if (update.docChanged) {
            onChangeCodeMirrorValueDebounced();
          }
        }),
        json(),
        search({ top: true }),
        readOnlyCompartment.of(EditorState.readOnly.of(readOnly2)),
        editableCompartment.of(EditorView.editable.of(!readOnly2)),
        tabSizeCompartment.of(EditorState.tabSize.of(tabSize)),
        indentUnitCompartment.of(createIndentUnit(indentation2)),
        EditorView.lineWrapping
      ]
    });
    codeMirrorView = new EditorView({ state, parent: target });
    return codeMirrorView;
  }
  function getCodeMirrorValue() {
    return codeMirrorView ? normalization.unescapeValue(codeMirrorView.state.doc.toString()) : "";
  }
  function toRichValidationError(validationError) {
    const { path, message } = validationError;
    const { line, column, from, to } = findTextLocation(normalization.escapeValue(text2), path);
    return {
      path,
      line,
      column,
      from,
      to,
      message,
      severity: ValidationSeverity.warning,
      actions: []
    };
  }
  function toRichParseError(parseError, isRepairable) {
    const { line, column, position, message } = parseError;
    return {
      path: null,
      line,
      column,
      from: position || 0,
      to: position || 0,
      severity: ValidationSeverity.error,
      message,
      actions: isRepairable && !readOnly ? [
        {
          name: "Auto repair",
          apply: () => handleRepair()
        }
      ] : null
    };
  }
  function setCodeMirrorContent(newContent, forceUpdate = false) {
    const newText = getText(newContent, indentation, parser);
    $$invalidate(10, editorDisabled = disableTextEditor(newText, acceptTooLarge));
    if (editorDisabled) {
      debug5("externalContent not applying text: editor is disabled");
      return;
    }
    const isChanged = !isEqual_default(newContent, content);
    debug5("setCodeMirrorContent", { isChanged, forceUpdate });
    if (!codeMirrorView || !isChanged && !forceUpdate) {
      return;
    }
    const previousContent = content;
    content = newContent;
    $$invalidate(5, text2 = newText);
    codeMirrorView.dispatch({
      changes: {
        from: 0,
        to: codeMirrorView.state.doc.length,
        insert: normalization.escapeValue(text2)
      }
    });
    updateCanUndoRedo();
    if (isChanged) {
      emitOnChange(content, previousContent);
    }
  }
  function refresh() {
    debug5("refresh");
    const index = codeMirrorView.state.doc.length;
    codeMirrorView.dispatch({
      changes: { from: index, to: index, insert: " " }
    });
    codeMirrorView.dispatch({
      changes: { from: index, to: index + 1, insert: "" }
    });
  }
  function forceUpdateText() {
    debug5("forceUpdateText", { escapeUnicodeCharacters });
    if (codeMirrorView) {
      codeMirrorView.dispatch({
        changes: {
          from: 0,
          to: codeMirrorView.state.doc.length,
          insert: normalization.escapeValue(text2)
        }
      });
    }
  }
  function onChangeCodeMirrorValue() {
    if (onChangeDisabled || !codeMirrorView) {
      return;
    }
    const codeMirrorText = getCodeMirrorValue();
    const isChanged = codeMirrorText !== text2;
    debug5("onChangeCodeMirrorValue", { isChanged });
    if (!isChanged) {
      return;
    }
    const previousContent = content;
    $$invalidate(5, text2 = codeMirrorText);
    content = { text: text2 };
    updateCanUndoRedo();
    emitOnChange(content, previousContent);
  }
  function updateLinter(validator2) {
    debug5("updateLinter", validator2);
    if (!codeMirrorView) {
      return;
    }
    codeMirrorView.dispatch({
      effects: linterCompartment.reconfigure(createLinter())
    });
  }
  function updateIndentation(indentation2) {
    if (codeMirrorView) {
      debug5("updateIndentation", indentation2);
      codeMirrorView.dispatch({
        effects: indentUnitCompartment.reconfigure(createIndentUnit(indentation2))
      });
    }
  }
  function updateTabSize(tabSize2) {
    if (codeMirrorView) {
      debug5("updateTabSize", tabSize2);
      codeMirrorView.dispatch({
        effects: tabSizeCompartment.reconfigure(EditorState.tabSize.of(tabSize2))
      });
    }
  }
  function updateReadOnly(readOnly2) {
    if (codeMirrorView) {
      debug5("updateReadOnly", readOnly2);
      codeMirrorView.dispatch({
        effects: [
          readOnlyCompartment.reconfigure(EditorState.readOnly.of(readOnly2)),
          editableCompartment.reconfigure(EditorView.editable.of(!readOnly2))
        ]
      });
    }
  }
  function createIndentUnit(indentation2) {
    return indentUnit.of(typeof indentation2 === "number" ? " ".repeat(indentation2) : indentation2);
  }
  function updateCanUndoRedo() {
    $$invalidate(11, canUndo = undoDepth(codeMirrorView.state) > 0);
    $$invalidate(12, canRedo = redoDepth(codeMirrorView.state) > 0);
    debug5({ canUndo, canRedo });
  }
  const onChangeCodeMirrorValueDebounced = debounce_default(onChangeCodeMirrorValue, TEXT_MODE_ONCHANGE_DELAY);
  function emitOnChange(content2, previousContent) {
    if (onChange) {
      onChange(content2, previousContent, {
        contentErrors: validate(),
        patchResult: null
      });
    }
  }
  function disableTextEditor(text3, acceptTooLarge2) {
    const tooLarge = text3 && text3.length > MAX_DOCUMENT_SIZE_TEXT_MODE;
    return tooLarge && !acceptTooLarge2;
  }
  let jsonStatus = JSON_STATUS_VALID;
  let jsonParseError = null;
  function linterCallback() {
    if (editorDisabled) {
      return [];
    }
    const contentErrors = validate();
    if (isContentParseError(contentErrors)) {
      const { parseError, isRepairable } = contentErrors;
      return [toDiagnostic(toRichParseError(parseError, isRepairable))];
    }
    if (isContentValidationErrors(contentErrors)) {
      return contentErrors.validationErrors.map(toRichValidationError).map(toDiagnostic);
    }
    return [];
  }
  function validate() {
    debug5("validate:start");
    onChangeCodeMirrorValueDebounced.flush();
    const contentErrors = memoizedValidateText(normalization.escapeValue(text2), validator, parser, validationParser);
    if (isContentParseError(contentErrors)) {
      $$invalidate(47, jsonStatus = contentErrors.isRepairable ? JSON_STATUS_REPAIRABLE : JSON_STATUS_INVALID);
      $$invalidate(13, jsonParseError = contentErrors.parseError);
      $$invalidate(9, validationErrors = []);
    } else {
      $$invalidate(47, jsonStatus = JSON_STATUS_VALID);
      $$invalidate(13, jsonParseError = null);
      $$invalidate(9, validationErrors = contentErrors.validationErrors);
    }
    debug5("validate:end");
    return contentErrors;
  }
  const memoizedValidateText = memoizeOne(validateText);
  $$self.$$.on_mount.push(function() {
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console_12.warn("<TextMode> was created without expected prop 'readOnly'");
    }
    if (mainMenuBar === void 0 && !("mainMenuBar" in $$props || $$self.$$.bound[$$self.$$.props["mainMenuBar"]])) {
      console_12.warn("<TextMode> was created without expected prop 'mainMenuBar'");
    }
    if (statusBar === void 0 && !("statusBar" in $$props || $$self.$$.bound[$$self.$$.props["statusBar"]])) {
      console_12.warn("<TextMode> was created without expected prop 'statusBar'");
    }
    if (externalContent === void 0 && !("externalContent" in $$props || $$self.$$.bound[$$self.$$.props["externalContent"]])) {
      console_12.warn("<TextMode> was created without expected prop 'externalContent'");
    }
    if (indentation === void 0 && !("indentation" in $$props || $$self.$$.bound[$$self.$$.props["indentation"]])) {
      console_12.warn("<TextMode> was created without expected prop 'indentation'");
    }
    if (tabSize === void 0 && !("tabSize" in $$props || $$self.$$.bound[$$self.$$.props["tabSize"]])) {
      console_12.warn("<TextMode> was created without expected prop 'tabSize'");
    }
    if (escapeUnicodeCharacters === void 0 && !("escapeUnicodeCharacters" in $$props || $$self.$$.bound[$$self.$$.props["escapeUnicodeCharacters"]])) {
      console_12.warn("<TextMode> was created without expected prop 'escapeUnicodeCharacters'");
    }
    if (parser === void 0 && !("parser" in $$props || $$self.$$.bound[$$self.$$.props["parser"]])) {
      console_12.warn("<TextMode> was created without expected prop 'parser'");
    }
    if (validator === void 0 && !("validator" in $$props || $$self.$$.bound[$$self.$$.props["validator"]])) {
      console_12.warn("<TextMode> was created without expected prop 'validator'");
    }
    if (validationParser === void 0 && !("validationParser" in $$props || $$self.$$.bound[$$self.$$.props["validationParser"]])) {
      console_12.warn("<TextMode> was created without expected prop 'validationParser'");
    }
    if (onChange === void 0 && !("onChange" in $$props || $$self.$$.bound[$$self.$$.props["onChange"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onChange'");
    }
    if (onSwitchToTreeMode === void 0 && !("onSwitchToTreeMode" in $$props || $$self.$$.bound[$$self.$$.props["onSwitchToTreeMode"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onSwitchToTreeMode'");
    }
    if (onError === void 0 && !("onError" in $$props || $$self.$$.bound[$$self.$$.props["onError"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onError'");
    }
    if (onFocus === void 0 && !("onFocus" in $$props || $$self.$$.bound[$$self.$$.props["onFocus"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onFocus'");
    }
    if (onBlur === void 0 && !("onBlur" in $$props || $$self.$$.bound[$$self.$$.props["onBlur"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onBlur'");
    }
    if (onRenderMenu === void 0 && !("onRenderMenu" in $$props || $$self.$$.bound[$$self.$$.props["onRenderMenu"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onRenderMenu'");
    }
    if (onSortModal === void 0 && !("onSortModal" in $$props || $$self.$$.bound[$$self.$$.props["onSortModal"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onSortModal'");
    }
    if (onTransformModal === void 0 && !("onTransformModal" in $$props || $$self.$$.bound[$$self.$$.props["onTransformModal"]])) {
      console_12.warn("<TextMode> was created without expected prop 'onTransformModal'");
    }
  });
  const writable_props = [
    "readOnly",
    "mainMenuBar",
    "statusBar",
    "externalContent",
    "indentation",
    "tabSize",
    "escapeUnicodeCharacters",
    "parser",
    "validator",
    "validationParser",
    "onChange",
    "onSwitchToTreeMode",
    "onError",
    "onFocus",
    "onBlur",
    "onRenderMenu",
    "onSortModal",
    "onTransformModal"
  ];
  Object_13.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<TextMode> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      codeMirrorRef = $$value;
      $$invalidate(6, codeMirrorRef);
    });
  }
  const func = () => handleSelectParseError(jsonParseError);
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      domTextMode = $$value;
      $$invalidate(7, domTextMode);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("readOnly" in $$props2)
      $$invalidate(0, readOnly = $$props2.readOnly);
    if ("mainMenuBar" in $$props2)
      $$invalidate(1, mainMenuBar = $$props2.mainMenuBar);
    if ("statusBar" in $$props2)
      $$invalidate(2, statusBar = $$props2.statusBar);
    if ("externalContent" in $$props2)
      $$invalidate(28, externalContent = $$props2.externalContent);
    if ("indentation" in $$props2)
      $$invalidate(29, indentation = $$props2.indentation);
    if ("tabSize" in $$props2)
      $$invalidate(30, tabSize = $$props2.tabSize);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(31, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(32, parser = $$props2.parser);
    if ("validator" in $$props2)
      $$invalidate(33, validator = $$props2.validator);
    if ("validationParser" in $$props2)
      $$invalidate(34, validationParser = $$props2.validationParser);
    if ("onChange" in $$props2)
      $$invalidate(35, onChange = $$props2.onChange);
    if ("onSwitchToTreeMode" in $$props2)
      $$invalidate(3, onSwitchToTreeMode = $$props2.onSwitchToTreeMode);
    if ("onError" in $$props2)
      $$invalidate(36, onError = $$props2.onError);
    if ("onFocus" in $$props2)
      $$invalidate(37, onFocus = $$props2.onFocus);
    if ("onBlur" in $$props2)
      $$invalidate(38, onBlur = $$props2.onBlur);
    if ("onRenderMenu" in $$props2)
      $$invalidate(4, onRenderMenu = $$props2.onRenderMenu);
    if ("onSortModal" in $$props2)
      $$invalidate(39, onSortModal = $$props2.onSortModal);
    if ("onTransformModal" in $$props2)
      $$invalidate(40, onTransformModal = $$props2.onTransformModal);
  };
  $$self.$capture_state = () => ({
    faExclamationTriangle,
    faWrench,
    createDebug,
    immutableJSONPatch,
    revertJSONPatch,
    jsonrepair,
    debounce: debounce_default,
    isEqual: isEqual_default,
    uniqueId: uniqueId_default,
    onDestroy,
    onMount,
    JSON_STATUS_INVALID,
    JSON_STATUS_REPAIRABLE,
    JSON_STATUS_VALID,
    MAX_DOCUMENT_SIZE_TEXT_MODE,
    TEXT_MODE_ONCHANGE_DELAY,
    activeElementIsChildOf,
    createNormalizationFunctions,
    getWindow,
    formatSize,
    findTextLocation,
    getText,
    createFocusTracker,
    Message: Message_default,
    ValidationErrorsOverview: ValidationErrorsOverview_default,
    TextMenu: TextMenu_default,
    basicSetup,
    EditorView,
    Compartment,
    EditorState,
    keymap,
    ViewUpdate,
    indentWithTab,
    redo,
    redoDepth,
    undo,
    undoDepth,
    linter,
    lintGutter,
    jsonLang: json,
    indentUnit,
    closeSearchPanel,
    openSearchPanel,
    search,
    jsonSourceMap: import_json_source_map2.default,
    StatusBar: StatusBar_default,
    highlighter,
    ValidationSeverity,
    isContentParseError,
    isContentValidationErrors,
    memoizeOne,
    validateText,
    readOnly,
    mainMenuBar,
    statusBar,
    externalContent,
    indentation,
    tabSize,
    escapeUnicodeCharacters,
    parser,
    validator,
    validationParser,
    onChange,
    onSwitchToTreeMode,
    onError,
    onFocus,
    onBlur,
    onRenderMenu,
    onSortModal,
    onTransformModal,
    debug: debug5,
    formatCompactKeyBinding,
    isSSR,
    codeMirrorRef,
    codeMirrorView,
    domTextMode,
    editorState,
    onChangeDisabled,
    acceptTooLarge,
    validationErrors,
    linterCompartment,
    editableCompartment,
    readOnlyCompartment,
    indentUnitCompartment,
    tabSizeCompartment,
    content,
    text: text2,
    editorDisabled,
    previousEscapeUnicodeCharacters,
    canUndo,
    canRedo,
    sortModalId,
    transformModalId,
    focus: focus3,
    modalOpen,
    patch,
    handleFormat,
    handleCompact,
    handleRepair,
    handleSort,
    openTransformModal,
    handleTransform,
    handleToggleSearch,
    handleUndo,
    handleRedo,
    handleAcceptTooLarge,
    cancelLoadTooLarge,
    handleSelectValidationError,
    handleSelectParseError,
    setSelection,
    handleDoubleClick,
    createLinter,
    createCodeMirrorView,
    getCodeMirrorValue,
    toRichValidationError,
    toRichParseError,
    toDiagnostic,
    setCodeMirrorContent,
    refresh,
    forceUpdateText,
    onChangeCodeMirrorValue,
    updateLinter,
    updateIndentation,
    updateTabSize,
    updateReadOnly,
    createIndentUnit,
    updateCanUndoRedo,
    onChangeCodeMirrorValueDebounced,
    emitOnChange,
    disableTextEditor,
    jsonStatus,
    jsonParseError,
    linterCallback,
    validate,
    memoizedValidateText,
    repairActions,
    normalization,
    isNewDocument
  });
  $$self.$inject_state = ($$props2) => {
    if ("readOnly" in $$props2)
      $$invalidate(0, readOnly = $$props2.readOnly);
    if ("mainMenuBar" in $$props2)
      $$invalidate(1, mainMenuBar = $$props2.mainMenuBar);
    if ("statusBar" in $$props2)
      $$invalidate(2, statusBar = $$props2.statusBar);
    if ("externalContent" in $$props2)
      $$invalidate(28, externalContent = $$props2.externalContent);
    if ("indentation" in $$props2)
      $$invalidate(29, indentation = $$props2.indentation);
    if ("tabSize" in $$props2)
      $$invalidate(30, tabSize = $$props2.tabSize);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(31, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(32, parser = $$props2.parser);
    if ("validator" in $$props2)
      $$invalidate(33, validator = $$props2.validator);
    if ("validationParser" in $$props2)
      $$invalidate(34, validationParser = $$props2.validationParser);
    if ("onChange" in $$props2)
      $$invalidate(35, onChange = $$props2.onChange);
    if ("onSwitchToTreeMode" in $$props2)
      $$invalidate(3, onSwitchToTreeMode = $$props2.onSwitchToTreeMode);
    if ("onError" in $$props2)
      $$invalidate(36, onError = $$props2.onError);
    if ("onFocus" in $$props2)
      $$invalidate(37, onFocus = $$props2.onFocus);
    if ("onBlur" in $$props2)
      $$invalidate(38, onBlur = $$props2.onBlur);
    if ("onRenderMenu" in $$props2)
      $$invalidate(4, onRenderMenu = $$props2.onRenderMenu);
    if ("onSortModal" in $$props2)
      $$invalidate(39, onSortModal = $$props2.onSortModal);
    if ("onTransformModal" in $$props2)
      $$invalidate(40, onTransformModal = $$props2.onTransformModal);
    if ("codeMirrorRef" in $$props2)
      $$invalidate(6, codeMirrorRef = $$props2.codeMirrorRef);
    if ("codeMirrorView" in $$props2)
      codeMirrorView = $$props2.codeMirrorView;
    if ("domTextMode" in $$props2)
      $$invalidate(7, domTextMode = $$props2.domTextMode);
    if ("editorState" in $$props2)
      $$invalidate(8, editorState = $$props2.editorState);
    if ("onChangeDisabled" in $$props2)
      onChangeDisabled = $$props2.onChangeDisabled;
    if ("acceptTooLarge" in $$props2)
      acceptTooLarge = $$props2.acceptTooLarge;
    if ("validationErrors" in $$props2)
      $$invalidate(9, validationErrors = $$props2.validationErrors);
    if ("content" in $$props2)
      content = $$props2.content;
    if ("text" in $$props2)
      $$invalidate(5, text2 = $$props2.text);
    if ("editorDisabled" in $$props2)
      $$invalidate(10, editorDisabled = $$props2.editorDisabled);
    if ("previousEscapeUnicodeCharacters" in $$props2)
      $$invalidate(46, previousEscapeUnicodeCharacters = $$props2.previousEscapeUnicodeCharacters);
    if ("canUndo" in $$props2)
      $$invalidate(11, canUndo = $$props2.canUndo);
    if ("canRedo" in $$props2)
      $$invalidate(12, canRedo = $$props2.canRedo);
    if ("modalOpen" in $$props2)
      modalOpen = $$props2.modalOpen;
    if ("jsonStatus" in $$props2)
      $$invalidate(47, jsonStatus = $$props2.jsonStatus);
    if ("jsonParseError" in $$props2)
      $$invalidate(13, jsonParseError = $$props2.jsonParseError);
    if ("repairActions" in $$props2)
      $$invalidate(14, repairActions = $$props2.repairActions);
    if ("normalization" in $$props2)
      normalization = $$props2.normalization;
    if ("isNewDocument" in $$props2)
      $$invalidate(15, isNewDocument = $$props2.isNewDocument);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 32) {
      $:
        $$invalidate(15, isNewDocument = text2.length === 0);
    }
    if ($$self.$$.dirty[1] & 1) {
      $:
        normalization = createNormalizationFunctions({
          escapeControlCharacters: false,
          escapeUnicodeCharacters
        });
    }
    if ($$self.$$.dirty[0] & 268435456) {
      $:
        setCodeMirrorContent(externalContent);
    }
    if ($$self.$$.dirty[1] & 4) {
      $:
        updateLinter(validator);
    }
    if ($$self.$$.dirty[0] & 536870912) {
      $:
        updateIndentation(indentation);
    }
    if ($$self.$$.dirty[0] & 1073741824) {
      $:
        updateTabSize(tabSize);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        updateReadOnly(readOnly);
    }
    if ($$self.$$.dirty[1] & 32769) {
      $: {
        if (previousEscapeUnicodeCharacters !== escapeUnicodeCharacters) {
          $$invalidate(46, previousEscapeUnicodeCharacters = escapeUnicodeCharacters);
          forceUpdateText();
        }
      }
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 65536) {
      $:
        $$invalidate(14, repairActions = jsonStatus === JSON_STATUS_REPAIRABLE && !readOnly ? [
          {
            icon: faWrench,
            text: "Auto repair",
            title: "Automatically repair JSON",
            onClick: handleRepair
          }
        ] : []);
    }
  };
  return [
    readOnly,
    mainMenuBar,
    statusBar,
    onSwitchToTreeMode,
    onRenderMenu,
    text2,
    codeMirrorRef,
    domTextMode,
    editorState,
    validationErrors,
    editorDisabled,
    canUndo,
    canRedo,
    jsonParseError,
    repairActions,
    isNewDocument,
    isSSR,
    handleFormat,
    handleCompact,
    handleSort,
    handleTransform,
    handleToggleSearch,
    handleUndo,
    handleRedo,
    handleAcceptTooLarge,
    cancelLoadTooLarge,
    handleSelectValidationError,
    handleSelectParseError,
    externalContent,
    indentation,
    tabSize,
    escapeUnicodeCharacters,
    parser,
    validator,
    validationParser,
    onChange,
    onError,
    onFocus,
    onBlur,
    onSortModal,
    onTransformModal,
    focus3,
    patch,
    openTransformModal,
    refresh,
    validate,
    previousEscapeUnicodeCharacters,
    jsonStatus,
    div_binding,
    func,
    div_binding_1
  ];
}
var TextMode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance14,
      create_fragment14,
      not_equal,
      {
        readOnly: 0,
        mainMenuBar: 1,
        statusBar: 2,
        externalContent: 28,
        indentation: 29,
        tabSize: 30,
        escapeUnicodeCharacters: 31,
        parser: 32,
        validator: 33,
        validationParser: 34,
        onChange: 35,
        onSwitchToTreeMode: 3,
        onError: 36,
        onFocus: 37,
        onBlur: 38,
        onRenderMenu: 4,
        onSortModal: 39,
        onTransformModal: 40,
        focus: 41,
        patch: 42,
        openTransformModal: 43,
        refresh: 44,
        validate: 45
      },
      add_css8,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextMode",
      options,
      id: create_fragment14.name
    });
  }
  get readOnly() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mainMenuBar() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mainMenuBar(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get statusBar() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set statusBar(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get externalContent() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set externalContent(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indentation() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indentation(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabSize() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabSize(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeUnicodeCharacters() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeUnicodeCharacters(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validator() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validator(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationParser() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationParser(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSwitchToTreeMode() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSwitchToTreeMode(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onError() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onError(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFocus() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFocus(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBlur() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBlur(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderMenu() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderMenu(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSortModal() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSortModal(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTransformModal() {
    throw new Error("<TextMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTransformModal(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[41];
  }
  set focus(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patch() {
    return this.$$.ctx[42];
  }
  set patch(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openTransformModal() {
    return this.$$.ctx[43];
  }
  set openTransformModal(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refresh() {
    return this.$$.ctx[44];
  }
  set refresh(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validate() {
    return this.$$.ctx[45];
  }
  set validate(value) {
    throw new Error("<TextMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextMode_default = TextMode;

// ../node_modules/svelte-jsoneditor/components/controls/createAutoScrollHandler.js
var debug3 = createDebug("jsoneditor:AutoScrollHandler");
function createAutoScrollHandler(scrollableElement) {
  debug3("createAutoScrollHandler", scrollableElement);
  let autoScrollSpeed;
  let autoScrollTimer;
  function calculateSpeed(diff) {
    return diff < 20 ? AUTO_SCROLL_SPEED_SLOW : diff < 50 ? AUTO_SCROLL_SPEED_NORMAL : AUTO_SCROLL_SPEED_FAST;
  }
  function autoScrollCallback() {
    if (scrollableElement) {
      const diff = autoScrollSpeed * (AUTO_SCROLL_INTERVAL / 1e3);
      scrollableElement.scrollTop += diff;
    }
  }
  function startAutoScroll(speed) {
    if (!autoScrollTimer || speed !== autoScrollSpeed) {
      stopAutoScroll();
      debug3("startAutoScroll", speed);
      autoScrollSpeed = speed;
      autoScrollTimer = setInterval(autoScrollCallback, AUTO_SCROLL_INTERVAL);
    }
  }
  function stopAutoScroll() {
    if (autoScrollTimer) {
      debug3("stopAutoScroll");
      clearInterval(autoScrollTimer);
      autoScrollTimer = void 0;
      autoScrollSpeed = void 0;
    }
  }
  function onDrag(event) {
    if (scrollableElement) {
      const y = event.clientY;
      const { top, bottom } = scrollableElement.getBoundingClientRect();
      if (y < top) {
        const speed = calculateSpeed(top - y);
        startAutoScroll(-speed);
      } else if (y > bottom) {
        const speed = calculateSpeed(y - bottom);
        startAutoScroll(speed);
      } else {
        stopAutoScroll();
      }
    }
  }
  function onDragEnd() {
    stopAutoScroll();
  }
  return {
    onDrag,
    onDragEnd
  };
}

// ../node_modules/svelte-jsoneditor/assets/jump.js/src/easing.js
var easing_default = (t, b, c, d) => {
  t /= d / 2;
  if (t < 1)
    return c / 2 * t * t + b;
  t--;
  return -c / 2 * (t * (t - 2) - 1) + b;
};

// ../node_modules/svelte-jsoneditor/assets/jump.js/src/jump.js
var createJump = () => {
  let container;
  let element2;
  let start;
  let stop;
  let offset;
  let easing;
  let a11y;
  let distance;
  let duration;
  let timeStart;
  let timeElapsed;
  let next;
  let callback;
  let scrolling;
  function location() {
    return container.scrollY || container.pageYOffset || container.scrollTop;
  }
  function top(element3) {
    const elementTop = element3.getBoundingClientRect().top;
    const containerTop = container.getBoundingClientRect ? container.getBoundingClientRect().top : 0;
    return elementTop - containerTop + start;
  }
  function scrollTo(top2) {
    container.scrollTo ? container.scrollTo(0, top2) : container.scrollTop = top2;
  }
  function loop(timeCurrent) {
    if (!timeStart) {
      timeStart = timeCurrent;
    }
    timeElapsed = timeCurrent - timeStart;
    next = easing(timeElapsed, start, distance, duration);
    scrollTo(next);
    scrolling = true;
    timeElapsed < duration ? requestAnimationFrame(loop) : done();
  }
  function done() {
    scrollTo(start + distance);
    if (element2 && a11y) {
      element2.setAttribute("tabindex", "-1");
      element2.focus();
    }
    if (typeof callback === "function") {
      callback();
    }
    timeStart = false;
    scrolling = false;
  }
  function jump(target, options = {}) {
    duration = options.duration || 1e3;
    offset = options.offset || 0;
    callback = options.callback;
    easing = options.easing || easing_default;
    a11y = options.a11y || false;
    switch (typeof options.container) {
      case "object":
        container = options.container;
        break;
      case "string":
        container = document.querySelector(options.container);
        break;
      default:
        container = window;
    }
    start = location();
    switch (typeof target) {
      case "number":
        element2 = void 0;
        a11y = false;
        stop = start + target;
        break;
      case "object":
        element2 = target;
        stop = top(element2);
        break;
      case "string":
        element2 = document.querySelector(target);
        stop = top(element2);
        break;
      default:
    }
    distance = stop - start + offset;
    switch (typeof options.duration) {
      case "number":
        duration = options.duration;
        break;
      case "function":
        duration = options.duration(distance);
        break;
      default:
    }
    if (!scrolling) {
      requestAnimationFrame(loop);
    } else {
      timeStart = false;
    }
  }
  return jump;
};
var singleton = createJump();

// ../node_modules/svelte-jsoneditor/logic/expandItemsSections.js
function getExpandItemsSections(startIndex, endIndex) {
  const section1 = {
    start: startIndex,
    end: Math.min(nextRoundNumber(startIndex), endIndex)
  };
  const start2 = Math.max(currentRoundNumber((startIndex + endIndex) / 2), startIndex);
  const section2 = {
    start: start2,
    end: Math.min(nextRoundNumber(start2), endIndex)
  };
  const currentIndex = currentRoundNumber(endIndex);
  const previousIndex = currentIndex === endIndex ? currentIndex - ARRAY_SECTION_SIZE : currentIndex;
  const section3 = {
    start: Math.max(previousIndex, startIndex),
    end: endIndex
  };
  const sections = [section1];
  const showSection2 = section2.start >= section1.end && section2.end <= section3.start;
  if (showSection2) {
    sections.push(section2);
  }
  const showSection3 = section3.start >= (showSection2 ? section2.end : section1.end);
  if (showSection3) {
    sections.push(section3);
  }
  return sections;
}
function mergeSections(sections) {
  const sortedSections = sortBy_default(sections, (section) => section.start);
  const mergedSections = [sortedSections[0]];
  for (let sortedIndex = 0; sortedIndex < sortedSections.length; sortedIndex++) {
    const mergedIndex = mergedSections.length - 1;
    const previous = mergedSections[mergedIndex];
    const current = sortedSections[sortedIndex];
    if (current.start <= previous.end) {
      mergedSections[mergedIndex] = {
        start: Math.min(previous.start, current.start),
        end: Math.max(previous.end, current.end)
      };
    } else {
      mergedSections.push(current);
    }
  }
  return mergedSections;
}
function inVisibleSection(sections, index) {
  return sections.some((section) => {
    return index >= section.start && index < section.end;
  });
}
function nextRoundNumber(index) {
  return currentRoundNumber(index) + ARRAY_SECTION_SIZE;
}
function currentRoundNumber(index) {
  return Math.floor(index / ARRAY_SECTION_SIZE) * ARRAY_SECTION_SIZE;
}

// ../node_modules/svelte-jsoneditor/logic/documentState.js
function createDocumentState(props) {
  let documentState = {
    expandedMap: {},
    enforceStringMap: {},
    visibleSectionsMap: {},
    selection: void 0
  };
  if (props == null ? void 0 : props.select) {
    documentState = {
      ...documentState,
      selection: props.select(props.json, documentState)
    };
  }
  if (props == null ? void 0 : props.expand) {
    documentState = expandWithCallback(props.json, documentState, [], props.expand);
  }
  return documentState;
}
function getVisibleSections(documentState, pointer) {
  return documentState.visibleSectionsMap[pointer] || DEFAULT_VISIBLE_SECTIONS;
}
function forEachVisibleIndex(jsonArray, visibleSections, callback) {
  visibleSections.forEach(({ start, end }) => {
    forEachIndex(start, Math.min(jsonArray.length, end), callback);
  });
}
function expandPath(json2, documentState, path) {
  const expandedMap = { ...documentState.expandedMap };
  const visibleSectionsMap = { ...documentState.visibleSectionsMap };
  for (let i = 0; i <= path.length; i++) {
    const partialPath = path.slice(0, i);
    const partialPointer = compileJSONPointer(partialPath);
    const value = getIn(json2, partialPath);
    if (isObjectOrArray(value)) {
      expandedMap[partialPointer] = true;
    }
    if (Array.isArray(value) && i < path.length) {
      const sections = visibleSectionsMap[partialPointer] || DEFAULT_VISIBLE_SECTIONS;
      const index = int(path[i]);
      if (!inVisibleSection(sections, index)) {
        const start = currentRoundNumber(index);
        const end = nextRoundNumber(start);
        const newSection = { start, end };
        visibleSectionsMap[partialPointer] = mergeSections(sections.concat(newSection));
      }
    }
  }
  return {
    ...documentState,
    expandedMap,
    visibleSectionsMap
  };
}
function expandWithCallback(json2, documentState, path, expandedCallback) {
  const expandedMap = { ...documentState.expandedMap };
  function recurse(value) {
    const pathIndex = currentPath.length;
    if (Array.isArray(value)) {
      if (expandedCallback(currentPath)) {
        const pointer = compileJSONPointer(currentPath);
        expandedMap[pointer] = true;
        if (value.length > 0) {
          const visibleSections = getVisibleSections(documentState, pointer);
          forEachVisibleIndex(value, visibleSections, (index) => {
            currentPath[pathIndex] = String(index);
            recurse(value[index]);
          });
          currentPath.pop();
        }
      }
    } else if (isObject(value)) {
      if (expandedCallback(currentPath)) {
        expandedMap[compileJSONPointer(currentPath)] = true;
        const keys = Object.keys(value);
        if (keys.length > 0) {
          for (const key of keys) {
            currentPath[pathIndex] = key;
            recurse(value[key]);
          }
          currentPath.pop();
        }
      }
    }
  }
  const currentPath = path.slice();
  recurse(getIn(json2, path));
  return {
    ...documentState,
    expandedMap
  };
}
function expandSingleItem(documentState, path) {
  return {
    ...documentState,
    expandedMap: {
      ...documentState.expandedMap,
      [compileJSONPointer(path)]: true
    }
  };
}
function collapsePath(documentState, path) {
  const expandedMap = deletePath(documentState.expandedMap, path);
  const enforceStringMap = deletePath(documentState.enforceStringMap, path);
  const visibleSectionsMap = deletePath(documentState.visibleSectionsMap, path);
  return {
    ...documentState,
    expandedMap,
    enforceStringMap,
    visibleSectionsMap
  };
}
function setEnforceString(documentState, pointer, enforceString) {
  if (enforceString) {
    const updatedEnforceString = { ...documentState.enforceStringMap };
    updatedEnforceString[pointer] = enforceString;
    return {
      ...documentState,
      enforceStringMap: updatedEnforceString
    };
  } else {
    if (typeof documentState.enforceStringMap[pointer] === "boolean") {
      const updatedEnforceString = { ...documentState.enforceStringMap };
      delete updatedEnforceString[pointer];
      return {
        ...documentState,
        enforceStringMap: updatedEnforceString
      };
    } else {
      return documentState;
    }
  }
}
function expandSection(json2, documentState, pointer, section) {
  return {
    ...documentState,
    visibleSectionsMap: {
      ...documentState.visibleSectionsMap,
      [pointer]: mergeSections(getVisibleSections(documentState, pointer).concat(section))
    }
  };
}
function documentStatePatch(json2, documentState, operations) {
  const updatedJson = immutableJSONPatch(json2, operations);
  const updatedDocumentState = operations.reduce((updatingState, operation) => {
    if (isJSONPatchAdd(operation)) {
      return documentStateAdd(updatedJson, updatingState, operation);
    }
    if (isJSONPatchRemove(operation)) {
      return documentStateRemove(updatedJson, updatingState, operation);
    }
    if (isJSONPatchReplace(operation)) {
      return documentStateReplace(updatedJson, updatingState, operation);
    }
    if (isJSONPatchCopy(operation) || isJSONPatchMove(operation)) {
      return documentStateMoveOrCopy(updatedJson, updatingState, operation);
    }
    return updatingState;
  }, documentState);
  return {
    json: updatedJson,
    documentState: updatedDocumentState
  };
}
function documentStateAdd(json2, documentState, operation) {
  const path = parsePath(json2, operation.path);
  const parentPath = initial_default(path);
  const parentPointer = compileJSONPointer(parentPath);
  const parent = getIn(json2, parentPath);
  if (isJSONArray(parent)) {
    const index = int(last_default(path));
    const expandedMap = shiftPath(documentState.expandedMap, parentPath, index, 1);
    const enforceStringMap = shiftPath(documentState.enforceStringMap, parentPath, index, 1);
    let visibleSectionsMap = shiftPath(documentState.visibleSectionsMap, parentPath, index, 1);
    visibleSectionsMap = updateInPathsMap(visibleSectionsMap, parentPointer, (sections) => shiftVisibleSections(sections, index, 1));
    return {
      ...documentState,
      expandedMap,
      enforceStringMap,
      visibleSectionsMap
    };
  }
  return documentState;
}
function documentStateRemove(updatedJson, documentState, operation) {
  const path = parsePath(updatedJson, operation.path);
  const parentPath = initial_default(path);
  const parentPointer = compileJSONPointer(parentPath);
  const parent = getIn(updatedJson, parentPath);
  let { expandedMap, enforceStringMap, visibleSectionsMap } = documentState;
  expandedMap = deletePath(expandedMap, path);
  enforceStringMap = deletePath(enforceStringMap, path);
  visibleSectionsMap = deletePath(visibleSectionsMap, path);
  if (isJSONArray(parent)) {
    const index = int(last_default(path));
    expandedMap = shiftPath(expandedMap, parentPath, index, -1);
    enforceStringMap = shiftPath(enforceStringMap, parentPath, index, -1);
    visibleSectionsMap = shiftPath(visibleSectionsMap, parentPath, index, -1);
    visibleSectionsMap = updateInPathsMap(visibleSectionsMap, parentPointer, (sections) => shiftVisibleSections(sections, index, -1));
  }
  return {
    ...documentState,
    expandedMap,
    enforceStringMap,
    visibleSectionsMap
  };
}
function documentStateReplace(updatedJson, documentState, operation) {
  const pointer = operation.path;
  const expandedMap = cleanupNonExistingPaths(updatedJson, documentState.expandedMap);
  const enforceStringMap = cleanupNonExistingPaths(updatedJson, documentState.enforceStringMap);
  const visibleSectionsMap = cleanupNonExistingPaths(updatedJson, documentState.visibleSectionsMap);
  if (!isJSONObject(operation.value) && !isJSONArray(operation.value)) {
    delete expandedMap[pointer];
  }
  if (!isJSONArray(operation.value)) {
    delete visibleSectionsMap[pointer];
  }
  if (isJSONObject(operation.value) || isJSONArray(operation.value)) {
    delete enforceStringMap[pointer];
  }
  return {
    ...documentState,
    expandedMap,
    enforceStringMap,
    visibleSectionsMap
  };
}
function documentStateMoveOrCopy(updatedJson, documentState, operation) {
  if (isJSONPatchMove(operation) && operation.from === operation.path) {
    return documentState;
  }
  const renamePointer = (pointer) => operation.path + pointer.substring(operation.from.length);
  const expandedMapCopy = movePath(filterPath(documentState.expandedMap, operation.from), renamePointer);
  const enforceStringMapCopy = movePath(filterPath(documentState.enforceStringMap, operation.from), renamePointer);
  const visibleSectionsMapCopy = movePath(filterPath(documentState.visibleSectionsMap, operation.from), renamePointer);
  let updatedState = documentState;
  if (isJSONPatchMove(operation)) {
    updatedState = documentStateRemove(updatedJson, updatedState, {
      op: "remove",
      path: operation.from
    });
  }
  updatedState = documentStateAdd(updatedJson, updatedState, {
    op: "add",
    path: operation.path,
    value: null
  });
  const expandedMap = mergePaths(updatedState.expandedMap, expandedMapCopy);
  const enforceStringMap = mergePaths(updatedState.enforceStringMap, enforceStringMapCopy);
  const visibleSectionsMap = mergePaths(updatedState.visibleSectionsMap, visibleSectionsMapCopy);
  return {
    ...documentState,
    expandedMap,
    enforceStringMap,
    visibleSectionsMap
  };
}
function deletePath(map, path) {
  const updatedMap = {};
  const pointer = compileJSONPointer(path);
  Object.keys(map).forEach((itemPointer) => {
    if (!startsWithJSONPointer(itemPointer, pointer)) {
      updatedMap[itemPointer] = map[itemPointer];
    }
  });
  return updatedMap;
}
function filterPath(map, pointer) {
  const filteredMap = {};
  Object.keys(map).forEach((itemPointer) => {
    if (startsWithJSONPointer(itemPointer, pointer)) {
      filteredMap[itemPointer] = map[itemPointer];
    }
  });
  return filteredMap;
}
function mergePaths(a, b) {
  return { ...a, ...b };
}
function movePath(map, changePointer) {
  const movedMap = {};
  Object.keys(map).forEach((oldPointer) => {
    const newPointer = changePointer(oldPointer);
    movedMap[newPointer] = map[oldPointer];
  });
  return movedMap;
}
function shiftPath(map, path, index, offset) {
  const indexPathPos = path.length;
  const pointer = compileJSONPointer(path);
  const matches = [];
  for (const itemPointer of Object.keys(map)) {
    if (startsWithJSONPointer(itemPointer, pointer)) {
      const itemPath = parseJSONPointer(itemPointer);
      const pathIndex = int(itemPath[indexPathPos]);
      if (pathIndex >= index) {
        itemPath[indexPathPos] = String(pathIndex + offset);
        matches.push({
          oldPointer: itemPointer,
          newPointer: compileJSONPointer(itemPath),
          value: map[itemPointer]
        });
      }
    }
  }
  if (matches.length === 0) {
    return map;
  }
  const updatedMap = { ...map };
  matches.forEach((match) => {
    delete updatedMap[match.oldPointer];
  });
  matches.forEach((match) => {
    updatedMap[match.newPointer] = match.value;
  });
  return updatedMap;
}
function cleanupNonExistingPaths(json2, map) {
  const updatedMap = {};
  Object.keys(map).filter((pointer) => existsIn(json2, parsePath(json2, pointer))).forEach((pointer) => {
    updatedMap[pointer] = map[pointer];
  });
  return updatedMap;
}
function updateInPathsMap(map, pointer, callback) {
  const value = map[pointer];
  if (pointer in map) {
    const updatedValue = callback(value);
    if (!isEqual_default(value, updatedValue)) {
      const updatedMap = { ...map };
      if (updatedValue === void 0) {
        delete updatedMap[pointer];
      } else {
        updatedMap[pointer] = updatedValue;
      }
      return updatedMap;
    }
  }
  return map;
}
function shiftVisibleSections(visibleSections, index, offset) {
  return visibleSections.map((section) => {
    return {
      start: section.start > index ? section.start + offset : section.start,
      end: section.end >= index ? section.end + offset : section.end
    };
  });
}
function getEnforceString(value, enforceStringMap, pointer, parser) {
  const enforceString = enforceStringMap ? enforceStringMap[pointer] : void 0;
  if (typeof enforceString === "boolean") {
    return enforceString;
  }
  return isStringContainingPrimitiveValue(value, parser);
}
function getNextKeys(keys, key, includeKey = false) {
  const index = keys.indexOf(key);
  if (index !== -1) {
    return includeKey ? keys.slice(index) : keys.slice(index + 1);
  } else {
    return [];
  }
}
function getVisiblePaths(json2, documentState) {
  const paths = [];
  function _recurse(value, path) {
    paths.push(path);
    const pointer = compileJSONPointer(path);
    if (value && documentState.expandedMap[pointer] === true) {
      if (isJSONArray(value)) {
        const visibleSections = getVisibleSections(documentState, pointer);
        forEachVisibleIndex(value, visibleSections, (index) => {
          _recurse(value[index], path.concat(String(index)));
        });
      }
      if (isJSONObject(value)) {
        Object.keys(value).forEach((key) => {
          _recurse(value[key], path.concat(key));
        });
      }
    }
  }
  _recurse(json2, []);
  return paths;
}
function getVisibleCaretPositions(json2, documentState, includeInside = true) {
  const paths = [];
  function _recurse(value, path) {
    paths.push({ path, type: CaretType.value });
    const pointer = compileJSONPointer(path);
    if (value && documentState.expandedMap[pointer] === true) {
      if (includeInside) {
        paths.push({ path, type: CaretType.inside });
      }
      if (isJSONArray(value)) {
        const visibleSections = getVisibleSections(documentState, pointer);
        forEachVisibleIndex(value, visibleSections, (index) => {
          const itemPath = path.concat(String(index));
          _recurse(value[index], itemPath);
          if (includeInside) {
            paths.push({ path: itemPath, type: CaretType.after });
          }
        });
      }
      if (isJSONObject(value)) {
        const keys = Object.keys(value);
        keys.forEach((key) => {
          const propertyPath = path.concat(key);
          paths.push({ path: propertyPath, type: CaretType.key });
          _recurse(value[key], propertyPath);
          if (includeInside) {
            paths.push({ path: propertyPath, type: CaretType.after });
          }
        });
      }
    }
  }
  _recurse(json2, []);
  return paths;
}
function getPreviousVisiblePath(json2, documentState, path) {
  const visiblePaths = getVisiblePaths(json2, documentState);
  const visiblePathPointers = visiblePaths.map(compileJSONPointer);
  const pathPointer = compileJSONPointer(path);
  const index = visiblePathPointers.indexOf(pathPointer);
  if (index !== -1 && index > 0) {
    return visiblePaths[index - 1];
  }
  return null;
}
function getNextVisiblePath(json2, documentState, path) {
  const visiblePaths = getVisiblePaths(json2, documentState);
  const visiblePathPointers = visiblePaths.map(compileJSONPointer);
  const index = visiblePathPointers.indexOf(compileJSONPointer(path));
  if (index !== -1 && index < visiblePaths.length - 1) {
    return visiblePaths[index + 1];
  }
  return null;
}

// ../node_modules/svelte-jsoneditor/logic/history.js
var MAX_HISTORY_ITEMS = 1e3;
var debug4 = createDebug("jsoneditor:History");
function createHistory(options = {}) {
  const maxItems = options.maxItems || MAX_HISTORY_ITEMS;
  let items = [];
  let index = 0;
  function canUndo() {
    return index < items.length;
  }
  function canRedo() {
    return index > 0;
  }
  function getState() {
    return {
      canUndo: canUndo(),
      canRedo: canRedo(),
      length: items.length
    };
  }
  function handleChange() {
    if (options.onChange) {
      options.onChange(getState());
    }
  }
  function add(item) {
    debug4("add", item);
    items = [item].concat(items.slice(index)).slice(0, maxItems);
    index = 0;
    handleChange();
  }
  function clear() {
    debug4("clear");
    items = [];
    index = 0;
    handleChange();
  }
  function undo2() {
    if (canUndo()) {
      const item = items[index];
      index += 1;
      debug4("undo", item);
      handleChange();
      return item;
    }
    return void 0;
  }
  function redo2() {
    if (canRedo()) {
      index -= 1;
      debug4("redo", items[index]);
      handleChange();
      return items[index];
    }
    return void 0;
  }
  return {
    add,
    clear,
    getState,
    undo: undo2,
    redo: redo2
  };
}

// ../node_modules/svelte-jsoneditor/utils/stringUtils.js
function findUniqueName(name, keys) {
  const keysSet = new Set(keys);
  const nameWithoutCopySuffix = name.replace(/ \(copy( \d+)?\)$/, "");
  let validName = name;
  let i = 1;
  while (keysSet.has(validName)) {
    const copy = "copy" + (i > 1 ? " " + i : "");
    validName = `${nameWithoutCopySuffix} (${copy})`;
    i++;
  }
  return validName;
}
function truncate(text2, maxLength) {
  const ellipsis = "...";
  const maxTextLength = maxLength - ellipsis.length;
  return text2.length > maxLength ? text2.substring(0, maxTextLength) + ellipsis : text2;
}
function parseString(str) {
  if (str === "") {
    return "";
  }
  const lower = str.toLowerCase();
  if (lower === "null") {
    return null;
  }
  if (lower === "true") {
    return true;
  }
  if (lower === "false") {
    return false;
  }
  if (lower === "undefined") {
    return void 0;
  }
  const num = Number(str);
  const numFloat = parseFloat(str);
  if (!isNaN(num) && !isNaN(numFloat)) {
    return num;
  }
  return str;
}

// ../node_modules/svelte-jsoneditor/logic/selection.js
function isAfterSelection(selection) {
  return selection && selection.type === SelectionType.after || false;
}
function isInsideSelection(selection) {
  return selection && selection.type === SelectionType.inside || false;
}
function isKeySelection(selection) {
  return selection && selection.type === SelectionType.key || false;
}
function isValueSelection(selection) {
  return selection && selection.type === SelectionType.value || false;
}
function isMultiSelection(selection) {
  return selection && selection.type === SelectionType.multi || false;
}
function expandSelection(json2, anchorPath, focusPath) {
  if (isEqual_default(anchorPath, focusPath)) {
    return [anchorPath];
  } else {
    const sharedPath = findSharedPath(anchorPath, focusPath);
    if (anchorPath.length === sharedPath.length || focusPath.length === sharedPath.length) {
      return [sharedPath];
    }
    const anchorKey = anchorPath[sharedPath.length];
    const focusKey = focusPath[sharedPath.length];
    const value = getIn(json2, sharedPath);
    if (isJSONObject(value)) {
      const keys = Object.keys(value);
      const anchorIndex = keys.indexOf(anchorKey);
      const focusIndex = keys.indexOf(focusKey);
      if (anchorIndex !== -1 && focusIndex !== -1) {
        const startIndex = Math.min(anchorIndex, focusIndex);
        const endIndex = Math.max(anchorIndex, focusIndex);
        const paths = [];
        for (let i = startIndex; i <= endIndex; i++) {
          paths.push(sharedPath.concat(keys[i]));
        }
        return paths;
      }
    }
    if (isJSONArray(value)) {
      const startIndex = Math.min(int(anchorKey), int(focusKey));
      const endIndex = Math.max(int(anchorKey), int(focusKey));
      const paths = [];
      for (let i = startIndex; i <= endIndex; i++) {
        paths.push(sharedPath.concat(String(i)));
      }
      return paths;
    }
  }
  throw new Error("Failed to create selection");
}
function getParentPath(selection) {
  if (isInsideSelection(selection)) {
    return selection.focusPath;
  } else {
    return initial_default(selection.focusPath);
  }
}
function getStartPath(selection) {
  return isMultiSelection(selection) ? head_default(selection.paths) : selection.focusPath;
}
function getEndPath(selection) {
  return isMultiSelection(selection) ? last_default(selection.paths) : selection.focusPath;
}
function isSelectionInsidePath(selection, path) {
  return pathStartsWith(selection.focusPath, path) && (selection.focusPath.length > path.length || isInsideSelection(selection));
}
function isPathInsideSelection(selection, path, anchorType) {
  if (!selection) {
    return false;
  }
  const p = path.slice(0);
  if (isMultiSelection(selection)) {
    while (p.length > 0) {
      if (selection.pointersMap[compileJSONPointer(p)] === true) {
        return true;
      }
      p.pop();
    }
  }
  if (isKeySelection(selection)) {
    return anchorType === SelectionType.key && isEqual_default(selection.focusPath, path);
  }
  if (isValueSelection(selection)) {
    if (anchorType === SelectionType.value && isEqual_default(selection.focusPath, path)) {
      return true;
    }
    if (pathStartsWith(path, selection.focusPath) && path.length > selection.focusPath.length && (anchorType === SelectionType.key || anchorType === SelectionType.value || anchorType === SelectionType.multi)) {
      return true;
    }
  }
  return false;
}
function getSelectionUp(json2, documentState, keepAnchorPath = false, useFocusPath = false) {
  const selection = documentState.selection;
  const path = !useFocusPath && isMultiSelection(selection) ? head_default(selection.paths) : selection.focusPath;
  const previousPath = getPreviousVisiblePath(json2, documentState, path);
  if (previousPath === null) {
    return null;
  }
  const anchorPath = previousPath;
  const focusPath = previousPath;
  if (keepAnchorPath) {
    if (isAfterSelection(selection) || isInsideSelection(selection)) {
      return createMultiSelection(json2, selection.anchorPath, selection.anchorPath);
    }
    return createMultiSelection(json2, selection.anchorPath, focusPath);
  }
  if (isKeySelection(selection)) {
    const parentPath = initial_default(previousPath);
    const parent = getIn(json2, parentPath);
    if (Array.isArray(parent) || isEmpty_default(previousPath)) {
      return createValueSelection(previousPath, false);
    } else {
      return createKeySelection(previousPath, false);
    }
  }
  if (isValueSelection(selection)) {
    return createValueSelection(previousPath, false);
  }
  if (isAfterSelection(selection)) {
    return createMultiSelection(json2, path, path);
  }
  if (isInsideSelection(selection)) {
    return createMultiSelection(json2, path, path);
  }
  return createMultiSelection(json2, anchorPath, focusPath);
}
function getSelectionDown(json2, documentState, keepAnchorPath = false, useFocusPath = false) {
  const selection = documentState.selection;
  const path = !useFocusPath && isMultiSelection(selection) ? last_default(selection.paths) : selection.focusPath;
  const nextPath = getNextVisiblePath(json2, documentState, path);
  const anchorPath = nextPath;
  const focusPath = nextPath;
  if (nextPath === null) {
    return null;
  }
  if (keepAnchorPath) {
    const collapsedState = isObjectOrArray(getIn(json2, path)) ? collapsePath(documentState, path) : documentState;
    const nextPathAfter = getNextVisiblePath(json2, collapsedState, path);
    if (nextPathAfter === null) {
      return null;
    }
    if (isAfterSelection(selection)) {
      return createMultiSelection(json2, nextPathAfter, nextPathAfter);
    }
    if (isInsideSelection(selection)) {
      return createMultiSelection(json2, anchorPath, focusPath);
    }
    return createMultiSelection(json2, selection.anchorPath, nextPathAfter);
  }
  if (isKeySelection(selection)) {
    const parentPath = initial_default(nextPath);
    const parent = getIn(json2, parentPath);
    if (Array.isArray(parent)) {
      return createValueSelection(focusPath, false);
    } else {
      return createKeySelection(focusPath, false);
    }
  }
  if (isValueSelection(selection)) {
    return createValueSelection(focusPath, false);
  }
  if (isInsideSelection(selection)) {
    return createMultiSelection(json2, anchorPath, focusPath);
  }
  return createMultiSelection(json2, nextPath, nextPath);
}
function getSelectionNextInside(json2, documentState, path) {
  const parentPath = initial_default(path);
  const childPath = [last_default(path)];
  const nextPathInside = getNextVisiblePath(getIn(json2, parentPath), documentState, childPath);
  if (nextPathInside) {
    return createValueSelection(parentPath.concat(nextPathInside), false);
  } else {
    return createAfterSelection(path);
  }
}
function findCaretAndSiblings(json2, documentState, includeInside) {
  const selection = documentState.selection;
  const visibleCaretPositions = getVisibleCaretPositions(json2, documentState, includeInside);
  const index = visibleCaretPositions.findIndex((caret) => {
    return isEqual_default(caret.path, selection.focusPath) && String(caret.type) === String(selection.type);
  });
  return {
    caret: index !== -1 ? visibleCaretPositions[index] : null,
    previous: index !== -1 && index > 0 ? visibleCaretPositions[index - 1] : null,
    next: index !== -1 && index < visibleCaretPositions.length - 1 ? visibleCaretPositions[index + 1] : null
  };
}
function getSelectionLeft(json2, documentState, keepAnchorPath = false, includeInside = true) {
  const selection = documentState.selection;
  const { caret, previous } = findCaretAndSiblings(json2, documentState, includeInside);
  if (keepAnchorPath) {
    if (!isMultiSelection(selection)) {
      return createMultiSelection(json2, selection.anchorPath, selection.focusPath);
    }
    return null;
  }
  if (caret && previous) {
    return fromCaretPosition(previous);
  }
  const parentPath = initial_default(selection.focusPath);
  const parent = getIn(json2, parentPath);
  if (isValueSelection(selection) && Array.isArray(parent)) {
    return createMultiSelection(json2, selection.focusPath, selection.focusPath);
  }
  if (isMultiSelection(selection) && !Array.isArray(parent)) {
    return createKeySelection(selection.focusPath, false);
  }
  return null;
}
function getSelectionRight(json2, documentState, keepAnchorPath = false, includeInside = true) {
  const selection = documentState.selection;
  const { caret, next } = findCaretAndSiblings(json2, documentState, includeInside);
  if (keepAnchorPath) {
    if (!isMultiSelection(selection)) {
      return createMultiSelection(json2, selection.anchorPath, selection.focusPath);
    }
    return null;
  }
  if (caret && next) {
    return fromCaretPosition(next);
  }
  if (isMultiSelection(selection)) {
    return createValueSelection(selection.focusPath, false);
  }
  return null;
}
function getInitialSelection(json2, documentState) {
  const visiblePaths = getVisiblePaths(json2, documentState);
  let index = 0;
  while (index < visiblePaths.length - 1 && visiblePaths[index + 1].length > visiblePaths[index].length) {
    index++;
  }
  const path = visiblePaths[index];
  return path.length === 0 || Array.isArray(getIn(json2, initial_default(path))) ? createValueSelection(path, false) : createKeySelection(path, false);
}
function createSelectionFromOperations(json2, operations) {
  if (operations.length === 1) {
    const operation = head_default(operations);
    if (operation.op === "replace" || operation.op === "move") {
      const path = parsePath(json2, operation.path);
      return createValueSelection(path, false);
    }
  }
  if (!isEmpty_default(operations) && operations.every((operation) => operation.op === "move")) {
    const firstOp = head_default(operations);
    const otherOps = operations.slice(1);
    if ((isJSONPatchCopy(firstOp) || isJSONPatchMove(firstOp)) && firstOp.from !== firstOp.path && otherOps.every((op) => (isJSONPatchCopy(op) || isJSONPatchMove(op)) && op.from === op.path)) {
      const path = parsePath(json2, firstOp.path);
      return createKeySelection(path, false);
    }
  }
  const paths = operations.filter((operation) => {
    return operation.op !== "test" && operation.op !== "remove" && (operation.op !== "move" || operation.from !== operation.path) && typeof operation.path === "string";
  }).map((operation) => parsePath(json2, operation.path));
  if (isEmpty_default(paths)) {
    return null;
  }
  return {
    type: SelectionType.multi,
    paths,
    anchorPath: head_default(paths),
    focusPath: last_default(paths),
    pointersMap: createPointersMap(paths)
  };
}
function createPointersMap(paths) {
  const pointersMap = {};
  paths.forEach((path) => {
    pointersMap[compileJSONPointer(path)] = true;
  });
  return pointersMap;
}
function createSinglePointersMap(path) {
  return {
    [compileJSONPointer(path)]: true
  };
}
function findSharedPath(path1, path2) {
  let i = 0;
  while (i < path1.length && i < path2.length && path1[i] === path2[i]) {
    i++;
  }
  return path1.slice(0, i);
}
function singleItemSelected(selection) {
  return selection && (isKeySelection(selection) || isValueSelection(selection) || isMultiSelection(selection) && selection.paths.length === 1);
}
function findRootPath(json2, selection) {
  return singleItemSelected(selection) && isObjectOrArray(getIn(json2, selection.focusPath)) ? selection.focusPath : initial_default(selection.focusPath);
}
function pathStartsWith(path, parentPath) {
  if (path.length < parentPath.length) {
    return false;
  }
  for (let i = 0; i < parentPath.length; i++) {
    if (path[i] !== parentPath[i]) {
      return false;
    }
  }
  return true;
}
function removeEditModeFromSelection(documentState) {
  const selection = documentState.selection;
  if ((isKeySelection(selection) || isValueSelection(selection)) && selection.edit) {
    return {
      ...documentState,
      selection: {
        ...selection,
        edit: false
      }
    };
  }
  return documentState;
}
function createKeySelection(path, edit) {
  return {
    type: SelectionType.key,
    anchorPath: path,
    focusPath: path,
    pointersMap: createSinglePointersMap(path),
    edit
  };
}
function createValueSelection(path, edit) {
  return {
    type: SelectionType.value,
    anchorPath: path,
    focusPath: path,
    pointersMap: createSinglePointersMap(path),
    edit
  };
}
function createInsideSelection(path) {
  return {
    type: SelectionType.inside,
    anchorPath: path,
    focusPath: path,
    pointersMap: createSinglePointersMap(path)
  };
}
function createAfterSelection(path) {
  return {
    type: SelectionType.after,
    anchorPath: path,
    focusPath: path,
    pointersMap: createSinglePointersMap(path)
  };
}
function createMultiSelection(json2, anchorPath, focusPath) {
  const paths = expandSelection(json2, anchorPath, focusPath);
  const focusPathLast = pathStartsWith(focusPath, last_default(paths)) || pathStartsWith(anchorPath, head_default(paths));
  return {
    type: SelectionType.multi,
    anchorPath: focusPathLast ? head_default(paths) : last_default(paths),
    focusPath: focusPathLast ? last_default(paths) : head_default(paths),
    paths,
    pointersMap: createPointersMap(paths)
  };
}
function selectionToPartialJson(json2, selection, indentation, parser) {
  if (isKeySelection(selection)) {
    return String(last_default(selection.focusPath));
  }
  if (isValueSelection(selection)) {
    const value = getIn(json2, selection.focusPath);
    return typeof value === "string" ? value : parser.stringify(value, null, indentation);
  }
  if (isMultiSelection(selection)) {
    if (isEmpty_default(selection.focusPath)) {
      return parser.stringify(json2, null, indentation);
    }
    const parentPath = getParentPath(selection);
    const parent = getIn(json2, parentPath);
    if (Array.isArray(parent)) {
      if (selection.paths.length === 1) {
        const item = getIn(json2, head_default(selection.paths));
        return parser.stringify(item, null, indentation);
      } else {
        return selection.paths.map((path) => {
          const item = getIn(json2, path);
          return `${parser.stringify(item, null, indentation)},`;
        }).join("\n");
      }
    } else {
      return selection.paths.map((path) => {
        const key = last_default(path);
        const value = getIn(json2, path);
        return `${parser.stringify(key)}: ${parser.stringify(value, null, indentation)},`;
      }).join("\n");
    }
  }
  return null;
}
function getSelectionPaths(selection) {
  return isMultiSelection(selection) ? selection.paths : [selection.focusPath];
}
function isEditingSelection(selection) {
  return (isKeySelection(selection) || isValueSelection(selection)) && selection.edit;
}
function updateSelectionInDocumentState(documentState, selection, replaceIfUndefined = true) {
  if (selection === void 0 && !replaceIfUndefined) {
    return documentState;
  }
  return {
    ...documentState,
    selection
  };
}
function selectAll() {
  return createValueSelection([], false);
}
function canConvert(selection) {
  if (!selection) {
    return false;
  }
  if (isKeySelection(selection) || isValueSelection(selection)) {
    return true;
  }
  if (isMultiSelection(selection) && selection.paths.length === 1) {
    return true;
  }
}
function fromCaretPosition(caretPosition) {
  switch (caretPosition.type) {
    case CaretType.key:
      return createKeySelection(caretPosition.path, false);
    case CaretType.value:
      return createValueSelection(caretPosition.path, false);
    case CaretType.after:
      return createAfterSelection(caretPosition.path);
    case CaretType.inside:
      return createInsideSelection(caretPosition.path);
  }
}
function fromSelectionType(json2, selectionType, path) {
  switch (selectionType) {
    case SelectionType.key:
      return createKeySelection(path, false);
    case SelectionType.value:
      return createValueSelection(path, false);
    case SelectionType.after:
      return createAfterSelection(path);
    case SelectionType.inside:
      return createInsideSelection(path);
    case SelectionType.multi:
      return createMultiSelection(json2, path, path);
  }
}
function selectionIfOverlapping(selection, pointer) {
  if (!selection) {
    return void 0;
  }
  return Object.keys(selection.pointersMap).some((p) => startsWithJSONPointer(p, pointer) || startsWithJSONPointer(pointer, p)) ? selection : void 0;
}

// ../node_modules/svelte-jsoneditor/logic/operations.js
function insertBefore(json2, path, values) {
  const parentPath = initial_default(path);
  const parent = getIn(json2, parentPath);
  if (isJSONArray(parent)) {
    const offset = int(last_default(path));
    return values.map((entry, index) => ({
      op: "add",
      path: compileJSONPointer(parentPath.concat(String(offset + index))),
      value: entry.value
    }));
  } else if (isJSONObject(parent)) {
    const afterKey = last_default(path);
    const keys = Object.keys(parent);
    const nextKeys = getNextKeys(keys, afterKey, true);
    return [
      ...values.map((entry) => {
        const newProp = findUniqueName(entry.key, keys);
        return {
          op: "add",
          path: compileJSONPointer(parentPath.concat(newProp)),
          value: entry.value
        };
      }),
      ...nextKeys.map((key) => moveDown(parentPath, key))
    ];
  } else {
    throw new Error("Cannot create insert operations: parent must be an Object or Array");
  }
}
function append(json2, path, values) {
  const parent = getIn(json2, path);
  if (Array.isArray(parent)) {
    const offset = parent.length;
    return values.map((entry, index) => ({
      op: "add",
      path: compileJSONPointer(path.concat(String(offset + index))),
      value: entry.value
    }));
  } else {
    return values.map((entry) => {
      const newProp = findUniqueName(entry.key, Object.keys(parent));
      return {
        op: "add",
        path: compileJSONPointer(path.concat(newProp)),
        value: entry.value
      };
    });
  }
}
function rename(parentPath, keys, oldKey, newKey) {
  const filteredKeys = keys.filter((key) => key !== oldKey);
  const newKeyUnique = findUniqueName(newKey, filteredKeys);
  const nextKeys = getNextKeys(keys, oldKey, false);
  return [
    {
      op: "move",
      from: compileJSONPointer(parentPath.concat(oldKey)),
      path: compileJSONPointer(parentPath.concat(newKeyUnique))
    },
    ...nextKeys.map((key) => moveDown(parentPath, key))
  ];
}
function replace(json2, paths, values) {
  const firstPath = head_default(paths);
  const parentPath = initial_default(firstPath);
  const parent = getIn(json2, parentPath);
  if (isJSONArray(parent)) {
    const firstPath2 = head_default(paths);
    const offset = firstPath2 ? int(last_default(firstPath2)) : 0;
    return [
      ...removeAll(paths),
      ...values.map((entry, index) => {
        const operation = {
          op: "add",
          path: compileJSONPointer(parentPath.concat(String(index + offset))),
          value: entry.value
        };
        return operation;
      })
    ];
  } else if (isJSONObject(parent)) {
    const lastPath = last_default(paths);
    const parentPath2 = initial_default(lastPath);
    const beforeKey = last_default(lastPath);
    const keys = Object.keys(parent);
    const nextKeys = getNextKeys(keys, beforeKey, false);
    const removeKeys = new Set(paths.map((path) => last_default(path)));
    const filteredKeys = keys.filter((key) => !removeKeys.has(key));
    return [
      ...removeAll(paths),
      ...values.map((entry) => {
        const newProp = findUniqueName(entry.key, filteredKeys);
        return {
          op: "add",
          path: compileJSONPointer(parentPath2.concat(newProp)),
          value: entry.value
        };
      }),
      ...nextKeys.map((key) => moveDown(parentPath2, key))
    ];
  } else {
    throw new Error("Cannot create replace operations: parent must be an Object or Array");
  }
}
function duplicate(json2, paths) {
  const lastPath = last_default(paths);
  if (isEmpty_default(lastPath)) {
    throw new Error("Cannot duplicate root object");
  }
  const parentPath = initial_default(lastPath);
  const beforeKey = last_default(lastPath);
  const parent = getIn(json2, parentPath);
  if (isJSONArray(parent)) {
    const lastPath2 = last_default(paths);
    const offset = lastPath2 ? int(last_default(lastPath2)) + 1 : 0;
    return [
      ...paths.map((path, index) => {
        const operation = {
          op: "copy",
          from: compileJSONPointer(path),
          path: compileJSONPointer(parentPath.concat(String(index + offset)))
        };
        return operation;
      })
    ];
  } else if (isJSONObject(parent)) {
    const keys = Object.keys(parent);
    const nextKeys = getNextKeys(keys, beforeKey, false);
    return [
      ...paths.map((path) => {
        const prop = last_default(path);
        const newProp = findUniqueName(prop, keys);
        return {
          op: "copy",
          from: compileJSONPointer(path),
          path: compileJSONPointer(parentPath.concat(newProp))
        };
      }),
      ...nextKeys.map((key) => moveDown(parentPath, key))
    ];
  } else {
    throw new Error("Cannot create duplicate operations: parent must be an Object or Array");
  }
}
function extract(json2, selection) {
  if (isValueSelection(selection)) {
    return [
      {
        op: "move",
        from: compileJSONPointer(selection.focusPath),
        path: ""
      }
    ];
  }
  if (isMultiSelection(selection)) {
    const parentPath = initial_default(selection.focusPath);
    const parent = getIn(json2, parentPath);
    if (isJSONArray(parent)) {
      const value = selection.paths.map((path) => {
        const index = int(last_default(path));
        return parent[index];
      });
      return [
        {
          op: "replace",
          path: "",
          value
        }
      ];
    } else if (isJSONObject(parent)) {
      const value = {};
      selection.paths.forEach((path) => {
        const key = String(last_default(path));
        value[key] = parent[key];
      });
      return [
        {
          op: "replace",
          path: "",
          value
        }
      ];
    }
  } else {
    throw new Error("Cannot create extract operations: parent must be an Object or Array");
  }
  throw new Error("Cannot extract: unsupported type of selection " + JSON.stringify(selection));
}
function insert(json2, selection, clipboardText, parser) {
  if (isKeySelection(selection)) {
    const clipboard = parseAndRepairOrUndefined(clipboardText, parser);
    const parentPath = initial_default(selection.focusPath);
    const parent = getIn(json2, parentPath);
    const keys = Object.keys(parent);
    const oldKey = last_default(selection.focusPath);
    const newKey = typeof clipboard === "string" ? clipboard : clipboardText;
    return rename(parentPath, keys, oldKey, newKey);
  }
  if (isValueSelection(selection) || isMultiSelection(selection) && isEmpty_default(selection.focusPath)) {
    try {
      return [
        {
          op: "replace",
          path: compileJSONPointer(selection.focusPath),
          value: parsePartialJson(clipboardText, (text2) => parseAndRepair(text2, parser))
        }
      ];
    } catch (err) {
      return [
        {
          op: "replace",
          path: compileJSONPointer(selection.focusPath),
          value: clipboardText
        }
      ];
    }
  }
  if (isMultiSelection(selection)) {
    const newValues = clipboardToValues(clipboardText, parser);
    return replace(json2, selection.paths, newValues);
  }
  if (isAfterSelection(selection)) {
    const newValues = clipboardToValues(clipboardText, parser);
    const path = selection.focusPath;
    const parentPath = initial_default(path);
    const parent = getIn(json2, parentPath);
    if (isJSONArray(parent)) {
      const index = int(last_default(path));
      const nextItemPath = parentPath.concat(String(index + 1));
      return insertBefore(json2, nextItemPath, newValues);
    } else if (isJSONObject(parent)) {
      const key = String(last_default(path));
      const keys = Object.keys(parent);
      if (isEmpty_default(keys) || last_default(keys) === key) {
        return append(json2, parentPath, newValues);
      } else {
        const index = keys.indexOf(key);
        const nextKey = keys[index + 1];
        const nextKeyPath = parentPath.concat(nextKey);
        return insertBefore(json2, nextKeyPath, newValues);
      }
    } else {
      throw new Error("Cannot create insert operations: parent must be an Object or Array");
    }
  }
  if (isInsideSelection(selection)) {
    const newValues = clipboardToValues(clipboardText, parser);
    const path = selection.focusPath;
    const value = getIn(json2, path);
    if (isJSONArray(value)) {
      const firstItemPath = path.concat("0");
      return insertBefore(json2, firstItemPath, newValues);
    } else if (isJSONObject(value)) {
      const keys = Object.keys(value);
      if (isEmpty_default(keys)) {
        return append(json2, path, newValues);
      } else {
        const firstKey = head_default(keys);
        const firstKeyPath = path.concat(firstKey);
        return insertBefore(json2, firstKeyPath, newValues);
      }
    } else {
      throw new Error("Cannot create insert operations: parent must be an Object or Array");
    }
  }
  throw new Error("Cannot insert: unsupported type of selection " + JSON.stringify(selection));
}
function moveInsideParent(json2, selection, dragInsideAction) {
  const beforePath = dragInsideAction["beforePath"];
  const append2 = dragInsideAction["append"];
  const parentPath = initial_default(selection.focusPath);
  const parent = getIn(json2, parentPath);
  if (!append2 && !(beforePath && pathStartsWith(beforePath, parentPath) && beforePath.length > parentPath.length)) {
    return [];
  }
  const startPath = getStartPath(selection);
  const endPath = getEndPath(selection);
  const startKey = last_default(startPath);
  const endKey = last_default(endPath);
  const toKey = beforePath ? beforePath[parentPath.length] : void 0;
  if (isJSONObject(parent)) {
    const keys = Object.keys(parent);
    const startIndex = keys.indexOf(startKey);
    const endIndex = keys.indexOf(endKey);
    const toIndex = append2 ? keys.length : keys.indexOf(toKey);
    if (startIndex !== -1 && endIndex !== -1 && toIndex !== -1) {
      if (toIndex > startIndex) {
        return [...keys.slice(startIndex, endIndex + 1), ...keys.slice(toIndex, keys.length)].map((key) => moveDown(parentPath, key));
      } else {
        return [...keys.slice(toIndex, startIndex), ...keys.slice(endIndex + 1, keys.length)].map((key) => moveDown(parentPath, key));
      }
    }
  } else if (isJSONArray(parent)) {
    const startIndex = int(startKey);
    const endIndex = int(endKey);
    const toIndex = toKey !== void 0 ? int(toKey) : parent.length;
    const count = endIndex - startIndex + 1;
    if (toIndex < startIndex) {
      return times_default(count, (offset) => {
        return {
          op: "move",
          from: compileJSONPointer(parentPath.concat(String(startIndex + offset))),
          path: compileJSONPointer(parentPath.concat(String(toIndex + offset)))
        };
      });
    } else {
      return times_default(count, () => {
        return {
          op: "move",
          from: compileJSONPointer(parentPath.concat(String(startIndex))),
          path: compileJSONPointer(parentPath.concat(String(toIndex)))
        };
      });
    }
  } else {
    throw new Error("Cannot create move operations: parent must be an Object or Array");
  }
}
function createNewValue(json2, selection, valueType2) {
  if (valueType2 === "object") {
    return {};
  }
  if (valueType2 === "array") {
    return [];
  }
  if (valueType2 === "structure") {
    const parentPath = getParentPath(selection);
    const parent = getIn(json2, parentPath);
    if (Array.isArray(parent) && !isEmpty_default(parent)) {
      const jsonExample = head_default(parent);
      if (isObjectOrArray(jsonExample)) {
        return cloneDeepWith_default(jsonExample, (value) => {
          return Array.isArray(value) ? [] : isObject(value) ? void 0 : "";
        });
      } else {
        return "";
      }
    }
  }
  return "";
}
function removeAll(paths) {
  return paths.map((path) => {
    const operation = {
      op: "remove",
      path: compileJSONPointer(path)
    };
    return operation;
  }).reverse();
}
function moveDown(parentPath, key) {
  return {
    op: "move",
    from: compileJSONPointer(parentPath.concat(key)),
    path: compileJSONPointer(parentPath.concat(key))
  };
}
function clipboardToValues(clipboardText, parser) {
  const textIsObject = /^\s*{/.test(clipboardText);
  const textIsArray = /^\s*\[/.test(clipboardText);
  const clipboardOriginal = parseAndRepairOrUndefined(clipboardText, parser);
  const clipboardRepaired = clipboardOriginal !== void 0 ? clipboardOriginal : parsePartialJson(clipboardText, (text2) => parseAndRepair(text2, parser));
  if (textIsObject && isObject(clipboardRepaired) || textIsArray && Array.isArray(clipboardRepaired)) {
    return [{ key: "New item", value: clipboardRepaired }];
  }
  if (Array.isArray(clipboardRepaired)) {
    return clipboardRepaired.map((value, index) => {
      return { key: "New item " + index, value };
    });
  }
  if (isObject(clipboardRepaired)) {
    return Object.keys(clipboardRepaired).map((key) => {
      return { key, value: clipboardRepaired[key] };
    });
  }
  return [{ key: "New item", value: clipboardRepaired }];
}
function createRemoveOperations(json2, selection) {
  if (isKeySelection(selection)) {
    const parentPath = initial_default(selection.focusPath);
    const parent = getIn(json2, parentPath);
    const keys = Object.keys(parent);
    const oldKey = last_default(selection.focusPath);
    const newKey = "";
    const operations = rename(parentPath, keys, oldKey, newKey);
    const newSelection = createSelectionFromOperations(json2, operations);
    return { operations, newSelection };
  }
  if (isValueSelection(selection)) {
    const operations = [
      {
        op: "replace",
        path: compileJSONPointer(selection.focusPath),
        value: ""
      }
    ];
    return { operations, newSelection: selection };
  }
  if (isMultiSelection(selection)) {
    const operations = removeAll(selection.paths);
    const lastPath = last_default(selection.paths);
    if (isEmpty_default(lastPath)) {
      const operations2 = [{ op: "replace", path: "", value: "" }];
      const newSelection = createValueSelection([], false);
      return { operations: operations2, newSelection };
    }
    const parentPath = initial_default(lastPath);
    const parent = getIn(json2, parentPath);
    if (isJSONArray(parent)) {
      const firstPath = head_default(selection.paths);
      const index = int(last_default(firstPath));
      const newSelection = index === 0 ? createInsideSelection(parentPath) : createAfterSelection(parentPath.concat(String(index - 1)));
      return { operations, newSelection };
    } else if (isJSONObject(parent)) {
      const keys = Object.keys(parent);
      const firstPath = head_default(selection.paths);
      const key = last_default(firstPath);
      const index = keys.indexOf(key);
      const previousKey = keys[index - 1];
      const newSelection = index === 0 ? createInsideSelection(parentPath) : createAfterSelection(parentPath.concat(previousKey));
      return { operations, newSelection };
    } else {
      throw new Error("Cannot create remove operations: parent must be an Object or Array");
    }
  }
  throw new Error("Cannot remove: unsupported type of selection " + JSON.stringify(selection));
}
function revertJSONPatchWithMoveOperations(json2, operations) {
  return revertJSONPatch(json2, operations, {
    before: (json3, operation, revertOperations) => {
      if (isJSONPatchRemove(operation)) {
        const path = parseJSONPointer(operation.path);
        return {
          revertOperations: [...revertOperations, ...createRevertMoveOperations(json3, path)]
        };
      }
      if (isJSONPatchMove(operation)) {
        const from = parseJSONPointer(operation.from);
        return {
          revertOperations: [...revertOperations, ...createRevertMoveOperations(json3, from)]
        };
      }
      return { revertOperations };
    }
  });
}
function createRevertMoveOperations(json2, path) {
  const parentPath = initial_default(path);
  const afterKey = last_default(path);
  const parent = getIn(json2, parentPath);
  if (isJSONObject(parent)) {
    const keys = Object.keys(parent);
    const nextKeys = getNextKeys(keys, afterKey, false);
    return nextKeys.map((key) => moveDown(parentPath, key));
  }
  return [];
}

// ../node_modules/svelte-jsoneditor/logic/search.js
function updateSearchResult(json2, newResultItems, previousResult) {
  const activePath = (previousResult == null ? void 0 : previousResult.activeItem) ? getSearchResultPath(previousResult.activeItem) : void 0;
  const matchingActiveIndex = newResultItems.findIndex((item) => {
    return isEqual_default(activePath, getSearchResultPath(item));
  });
  const activeIndex = matchingActiveIndex !== -1 ? matchingActiveIndex : (previousResult == null ? void 0 : previousResult.activeIndex) < newResultItems.length ? previousResult == null ? void 0 : previousResult.activeIndex : newResultItems.length > 0 ? 0 : -1;
  const items = newResultItems.map((item, index) => {
    return { ...item, active: index === activeIndex };
  });
  const activeItem = items[activeIndex];
  return {
    items,
    itemsMap: groupBy_default(items, (item) => compileJSONPointer(item.path)),
    activeItem,
    activeIndex
  };
}
function searchNext(searchResult) {
  const nextActiveIndex = searchResult.activeIndex < searchResult.items.length - 1 ? searchResult.activeIndex + 1 : searchResult.items.length > 0 ? 0 : -1;
  const nextActiveItem = searchResult.items[nextActiveIndex];
  const items = searchResult.items.map((item, index) => {
    return { ...item, active: index === nextActiveIndex };
  });
  return {
    ...searchResult,
    items,
    itemsMap: groupBy_default(items, (item) => compileJSONPointer(item.path)),
    activeItem: nextActiveItem,
    activeIndex: nextActiveIndex
  };
}
function searchPrevious(searchResult) {
  const previousActiveIndex = searchResult.activeIndex > 0 ? searchResult.activeIndex - 1 : searchResult.items.length - 1;
  const previousActiveItem = searchResult.items[previousActiveIndex];
  const items = searchResult.items.map((item, index) => {
    return { ...item, active: index === previousActiveIndex };
  });
  return {
    ...searchResult,
    items,
    itemsMap: groupBy_default(items, (item) => compileJSONPointer(item.path)),
    activeItem: previousActiveItem,
    activeIndex: previousActiveIndex
  };
}
function search2(searchText, json2, documentState, maxResults = Infinity) {
  const results = [];
  const path = [];
  function onMatch(match) {
    if (results.length < maxResults) {
      results.push(match);
    }
  }
  function searchRecursive(searchTextLowerCase, value) {
    if (isJSONArray(value)) {
      const level = path.length;
      path.push("0");
      for (let i = 0; i < value.length; i++) {
        path[level] = String(i);
        searchRecursive(searchTextLowerCase, value[i]);
        if (results.length >= maxResults) {
          return;
        }
      }
      path.pop();
    } else if (isJSONObject(value)) {
      const keys = Object.keys(value);
      const level = path.length;
      path.push("");
      for (const key of keys) {
        path[level] = key;
        findCaseInsensitiveMatches(key, searchTextLowerCase, path, SearchField.key, onMatch);
        searchRecursive(searchTextLowerCase, value[key]);
        if (results.length >= maxResults) {
          return;
        }
      }
      path.pop();
    } else {
      findCaseInsensitiveMatches(String(value), searchTextLowerCase, path, SearchField.value, onMatch);
    }
  }
  if (typeof searchText === "string" && searchText !== "") {
    const searchTextLowerCase = searchText.toLowerCase();
    searchRecursive(searchTextLowerCase, json2);
  }
  return results;
}
function findCaseInsensitiveMatches(text2, searchTextLowerCase, path, field, onMatch) {
  const textLower = text2.toLowerCase();
  let fieldIndex = 0;
  let position = -1;
  let index = -1;
  do {
    index = textLower.indexOf(searchTextLowerCase, position);
    if (index !== -1) {
      position = index + searchTextLowerCase.length;
      onMatch({
        path: path.slice(0),
        field,
        fieldIndex,
        start: index,
        end: position
      });
      fieldIndex++;
    }
  } while (index !== -1);
}
function replaceText(text2, replacementText, start, end) {
  return text2.substring(0, start) + replacementText + text2.substring(end);
}
function replaceAllText(text2, replacementText, occurrences) {
  let updatedText = text2;
  forEachRight_default(occurrences, (occurrence) => {
    updatedText = replaceText(updatedText, replacementText, occurrence.start, occurrence.end);
  });
  return updatedText;
}
function createSearchAndReplaceOperations(json2, documentState, replacementText, searchResultItem, parser) {
  const { field, path, start, end } = searchResultItem;
  if (field === SearchField.key) {
    const parentPath = initial_default(path);
    const parent = getIn(json2, parentPath);
    const oldKey = last_default(path);
    const keys = Object.keys(parent);
    const newKey = replaceText(oldKey, replacementText, start, end);
    const operations = rename(parentPath, keys, oldKey, newKey);
    const newSelection = createSelectionFromOperations(json2, operations);
    return {
      newSelection,
      operations
    };
  } else if (field === SearchField.value) {
    const currentValue = getIn(json2, path);
    if (currentValue === void 0) {
      throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`);
    }
    const currentValueText = typeof currentValue === "string" ? currentValue : String(currentValue);
    const pointer = compileJSONPointer(path);
    const enforceString = getEnforceString(currentValue, documentState.enforceStringMap, pointer, parser);
    const value = replaceText(currentValueText, replacementText, start, end);
    const operations = [
      {
        op: "replace",
        path: compileJSONPointer(path),
        value: enforceString ? value : stringConvert(value, parser)
      }
    ];
    const newSelection = createSelectionFromOperations(json2, operations);
    return {
      newSelection,
      operations
    };
  } else {
    throw new Error(`Cannot replace: unknown type of search result field ${field}`);
  }
}
function createSearchAndReplaceAllOperations(json2, documentState, searchText, replacementText, parser) {
  const searchResultItems = search2(searchText, json2, documentState, Infinity);
  const deduplicatedMatches = [];
  for (let i = 0; i < searchResultItems.length; i++) {
    const previousItem = searchResultItems[i - 1];
    const item = searchResultItems[i];
    if (i === 0 || item.field !== previousItem.field || !isEqual_default(item.path, previousItem.path)) {
      deduplicatedMatches.push({
        path: item.path,
        field: item.field,
        items: [item]
      });
    } else {
      last_default(deduplicatedMatches).items.push(item);
    }
  }
  deduplicatedMatches.sort((a, b) => {
    if (a.field !== b.field) {
      if (a.field === SearchField.key) {
        return 1;
      } else {
        return -1;
      }
    }
    return b.path.length - a.path.length;
  });
  let allOperations = [];
  let lastNewSelection = void 0;
  deduplicatedMatches.forEach((match) => {
    const { field, path, items } = match;
    if (field === SearchField.key) {
      const parentPath = initial_default(path);
      const parent = getIn(json2, parentPath);
      const oldKey = last_default(path);
      const keys = Object.keys(parent);
      const newKey = replaceAllText(oldKey, replacementText, items);
      const operations = rename(parentPath, keys, oldKey, newKey);
      allOperations = allOperations.concat(operations);
      lastNewSelection = createSelectionFromOperations(json2, operations);
    } else if (field === SearchField.value) {
      const currentValue = getIn(json2, path);
      if (currentValue === void 0) {
        throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`);
      }
      const currentValueText = typeof currentValue === "string" ? currentValue : String(currentValue);
      const pointer = compileJSONPointer(path);
      const enforceString = getEnforceString(currentValue, documentState.enforceStringMap, pointer, parser);
      const value = replaceAllText(currentValueText, replacementText, items);
      const operations = [
        {
          op: "replace",
          path: compileJSONPointer(path),
          value: enforceString ? value : stringConvert(value, parser)
        }
      ];
      allOperations = allOperations.concat(operations);
      lastNewSelection = createSelectionFromOperations(json2, operations);
    } else {
      throw new Error(`Cannot replace: unknown type of search result field ${field}`);
    }
  });
  return {
    operations: allOperations,
    newSelection: lastNewSelection
  };
}
function splitValue(text2, matches) {
  const parts = [];
  let previousEnd = 0;
  for (const match of matches) {
    const precedingText = text2.slice(previousEnd, match.start);
    if (precedingText !== "") {
      parts.push({
        type: "normal",
        text: precedingText,
        active: false
      });
    }
    const matchingText = text2.slice(match.start, match.end);
    parts.push({
      type: "highlight",
      text: matchingText,
      active: match.active
    });
    previousEnd = match.end;
  }
  const lastMatch = last_default(matches);
  if (lastMatch.end < text2.length) {
    parts.push({
      type: "normal",
      text: text2.slice(lastMatch.end),
      active: false
    });
  }
  return parts;
}
function getSearchResultPath(searchResultItem) {
  return searchResultItem.path.concat(searchResultItem.field, String(searchResultItem.fieldIndex));
}
function filterKeySearchResults(map, pointer) {
  var _a;
  const items = (_a = map == null ? void 0 : map[pointer]) == null ? void 0 : _a.filter((item) => item.field === SearchField.key);
  if (!items || items.length === 0) {
    return void 0;
  }
  return items;
}
function filterValueSearchResults(map, pointer) {
  var _a;
  const items = (_a = map == null ? void 0 : map[pointer]) == null ? void 0 : _a.filter((item) => item.field === SearchField.value);
  if (!items || items.length === 0) {
    return void 0;
  }
  return items;
}

// ../node_modules/svelte-jsoneditor/utils/copyToClipboard.js
function copyToClipBoard(text2) {
  var _a;
  if (navigator.clipboard) {
    return navigator.clipboard.writeText(text2);
  } else if ((_a = document.queryCommandSupported) == null ? void 0 : _a.call(document, "copy")) {
    const textarea = document.createElement("textarea");
    textarea.value = text2;
    textarea.style.position = "fixed";
    textarea.style.opacity = "0";
    document.body.appendChild(textarea);
    textarea.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      console.error(e);
    } finally {
      document.body.removeChild(textarea);
    }
  } else {
    console.error("Copy failed.");
  }
}

// ../node_modules/svelte-jsoneditor/components/modals/Header.svelte
var file12 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/Header.svelte";
function add_css9(target) {
  append_styles(target, "svelte-hwcgwi", ".jse-header.svelte-hwcgwi.svelte-hwcgwi{display:flex;background:var(--jse-theme-color);color:var(--jse-menu-color)}.jse-header.svelte-hwcgwi .jse-title.svelte-hwcgwi{flex:1;padding:5px;vertical-align:middle}.jse-header.svelte-hwcgwi button.svelte-hwcgwi{border:none;background:transparent;min-width:32px;color:inherit;cursor:pointer}.jse-header.svelte-hwcgwi button.svelte-hwcgwi:hover{background:rgba(255, 255, 255, 0.1)}.svelte-hwcgwi.svelte-hwcgwi{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrQjBCLFdBQUEsNEJBQUEsQ0FBQSw0WkFtQnpCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkhlYWRlci5zdmVsdGUiXX0= */");
}
function create_fragment15(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faTimes }, $$inline: true });
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, ctx[0]);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-title svelte-hwcgwi");
      add_location(div0, file12, 10, 2, 295);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-close svelte-hwcgwi");
      add_location(button, file12, 13, 2, 342);
      attr_dev(div1, "class", "jse-header svelte-hwcgwi");
      add_location(div1, file12, 9, 0, 268);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, button);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[1], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data_dev(t0, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, []);
  let { title = "Modal" } = $$props;
  const { close } = getContext("simple-modal");
  const writable_props = ["title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Header> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
  };
  $$self.$capture_state = () => ({ getContext, Icon: Icon_default, faTimes, title, close });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, close];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, not_equal, { title: 0 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment15.name
    });
  }
  get title() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// ../node_modules/svelte-jsoneditor/components/modals/CopyPasteModal.svelte
var file13 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/CopyPasteModal.svelte";
function add_css10(target) {
  append_styles(target, "svelte-htys7e", ".jse-modal.svelte-htys7e.svelte-htys7e{--height:36px;--multiItemHeight:28px;--multiItemMargin:2px;--multiItemPadding:2px 8px;--multiClearTop:5px;--multiItemBorderRadius:6px;--clearSelectTop:2px;--clearSelectBottom:2px;--indicatorTop:8px;flex:1;display:flex;flex-direction:column;font-family:var(--jse-font-family);font-size:var(--jse-font-size);line-height:normal;background:var(--jse-modal-background);color:var(--jse-text-color)}.jse-modal.svelte-htys7e .jse-contents.svelte-htys7e{padding:20px;overflow:auto}.jse-modal.svelte-htys7e .jse-contents .jse-actions.svelte-htys7e{display:flex;flex-direction:row;justify-content:flex-end;padding-top:var(--jse-padding)}.jse-modal.svelte-htys7e .jse-contents .jse-actions button.svelte-htys7e{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;background:var(--jse-button-primary-background);color:var(--jse-button-primary-color);padding:var(--jse-padding) calc(2 * var(--jse-padding));border-radius:3px}.jse-modal.svelte-htys7e .jse-contents .jse-actions button.svelte-htys7e:hover{background:var(--jse-button-primary-background-highlight)}.jse-modal.svelte-htys7e .jse-contents .jse-actions button.svelte-htys7e:disabled{background:var(--jse-button-primary-background-disabled)}.bg.jse-modal-bg{width:100%;height:100%;top:0;left:0;background:var(--jse-modal-overlay-background)}.bg.jse-modal-bg .jse-modal-window-wrap{margin:0}.bg.jse-modal-bg .jse-modal-window{max-width:90%;margin:4rem auto 2rem auto;border-radius:2px}.bg.jse-modal-bg .jse-modal-window.jse-modal-window-sort{width:400px}.bg.jse-modal-bg .jse-modal-window.jse-modal-window-transform{width:1200px;height:1200px;max-height:80%;display:flex}.bg.jse-modal-bg .jse-modal-content{flex:1;display:flex;max-height:calc(100vh - 6rem);padding:0}.jse-modal.jse-copy-paste.svelte-htys7e .jse-shortcuts.svelte-htys7e{display:flex;flex-wrap:wrap;justify-content:space-around;margin:calc(2 * var(--jse-padding)) 0}.jse-modal.jse-copy-paste.svelte-htys7e .jse-shortcuts .jse-shortcut .jse-key.svelte-htys7e{font-size:200%;color:var(--jse-theme-color)}.svelte-htys7e.svelte-htys7e{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29weVBhc3RlTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTBDa0MsVUFBQSw0QkFBQSxDQUFBLDZsRUErRmpDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvcHlQYXN0ZU1vZGFsLnN2ZWx0ZSJdfQ== */");
}
function create_fragment16(ctx) {
  let div10;
  let header;
  let t0;
  let div9;
  let div0;
  let t1;
  let t2;
  let div7;
  let div2;
  let div1;
  let t3;
  let t4;
  let t5;
  let t6;
  let div4;
  let div3;
  let t7;
  let t8;
  let t9;
  let t10;
  let div6;
  let div5;
  let t11;
  let t12;
  let t13;
  let t14;
  let div8;
  let button;
  let t15;
  let current;
  let mounted;
  let dispose;
  header = new Header_default({
    props: { title: "Copying and pasting" },
    $$inline: true
  });
  const block = {
    c: function create() {
      div10 = element("div");
      create_component(header.$$.fragment);
      t0 = space();
      div9 = element("div");
      div0 = element("div");
      t1 = text("These actions are unavailable via the menu. Please use:");
      t2 = space();
      div7 = element("div");
      div2 = element("div");
      div1 = element("div");
      t3 = text(ctx[1]);
      t4 = text("+C");
      t5 = text("\n        for copy");
      t6 = space();
      div4 = element("div");
      div3 = element("div");
      t7 = text(ctx[1]);
      t8 = text("+X");
      t9 = text("\n        for cut");
      t10 = space();
      div6 = element("div");
      div5 = element("div");
      t11 = text(ctx[1]);
      t12 = text("+V");
      t13 = text("\n        for paste");
      t14 = space();
      div8 = element("div");
      button = element("button");
      t15 = text("Close");
      this.h();
    },
    l: function claim(nodes) {
      div10 = claim_element(nodes, "DIV", { class: true });
      var div10_nodes = children(div10);
      claim_component(header.$$.fragment, div10_nodes);
      t0 = claim_space(div10_nodes);
      div9 = claim_element(div10_nodes, "DIV", { class: true });
      var div9_nodes = children(div9);
      div0 = claim_element(div9_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "These actions are unavailable via the menu. Please use:");
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div9_nodes);
      div7 = claim_element(div9_nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      div2 = claim_element(div7_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t3 = claim_text(div1_nodes, ctx[1]);
      t4 = claim_text(div1_nodes, "+C");
      div1_nodes.forEach(detach_dev);
      t5 = claim_text(div2_nodes, "\n        for copy");
      div2_nodes.forEach(detach_dev);
      t6 = claim_space(div7_nodes);
      div4 = claim_element(div7_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      t7 = claim_text(div3_nodes, ctx[1]);
      t8 = claim_text(div3_nodes, "+X");
      div3_nodes.forEach(detach_dev);
      t9 = claim_text(div4_nodes, "\n        for cut");
      div4_nodes.forEach(detach_dev);
      t10 = claim_space(div7_nodes);
      div6 = claim_element(div7_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      t11 = claim_text(div5_nodes, ctx[1]);
      t12 = claim_text(div5_nodes, "+V");
      div5_nodes.forEach(detach_dev);
      t13 = claim_text(div6_nodes, "\n        for paste");
      div6_nodes.forEach(detach_dev);
      div7_nodes.forEach(detach_dev);
      t14 = claim_space(div9_nodes);
      div8 = claim_element(div9_nodes, "DIV", { class: true });
      var div8_nodes = children(div8);
      button = claim_element(div8_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t15 = claim_text(button_nodes, "Close");
      button_nodes.forEach(detach_dev);
      div8_nodes.forEach(detach_dev);
      div9_nodes.forEach(detach_dev);
      div10_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "svelte-htys7e");
      add_location(div0, file13, 13, 4, 388);
      attr_dev(div1, "class", "jse-key svelte-htys7e");
      add_location(div1, file13, 17, 8, 529);
      attr_dev(div2, "class", "jse-shortcut svelte-htys7e");
      add_location(div2, file13, 16, 6, 494);
      attr_dev(div3, "class", "jse-key svelte-htys7e");
      add_location(div3, file13, 23, 8, 656);
      attr_dev(div4, "class", "jse-shortcut svelte-htys7e");
      add_location(div4, file13, 22, 6, 621);
      attr_dev(div5, "class", "jse-key svelte-htys7e");
      add_location(div5, file13, 29, 8, 782);
      attr_dev(div6, "class", "jse-shortcut svelte-htys7e");
      add_location(div6, file13, 28, 6, 747);
      attr_dev(div7, "class", "jse-shortcuts svelte-htys7e");
      add_location(div7, file13, 15, 4, 460);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-primary svelte-htys7e");
      add_location(button, file13, 37, 6, 917);
      attr_dev(div8, "class", "jse-actions svelte-htys7e");
      add_location(div8, file13, 36, 4, 885);
      attr_dev(div9, "class", "jse-contents svelte-htys7e");
      add_location(div9, file13, 12, 2, 357);
      attr_dev(div10, "class", "jse-modal jse-copy-paste svelte-htys7e");
      add_location(div10, file13, 9, 0, 274);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div10, anchor);
      mount_component(header, div10, null);
      append_hydration_dev(div10, t0);
      append_hydration_dev(div10, div9);
      append_hydration_dev(div9, div0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div9, t2);
      append_hydration_dev(div9, div7);
      append_hydration_dev(div7, div2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, t4);
      append_hydration_dev(div2, t5);
      append_hydration_dev(div7, t6);
      append_hydration_dev(div7, div4);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, t7);
      append_hydration_dev(div3, t8);
      append_hydration_dev(div4, t9);
      append_hydration_dev(div7, t10);
      append_hydration_dev(div7, div6);
      append_hydration_dev(div6, div5);
      append_hydration_dev(div5, t11);
      append_hydration_dev(div5, t12);
      append_hydration_dev(div6, t13);
      append_hydration_dev(div9, t14);
      append_hydration_dev(div9, div8);
      append_hydration_dev(div8, button);
      append_hydration_dev(button, t15);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[0], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div10);
      destroy_component(header);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopyPasteModal", slots, []);
  const { close } = getContext("simple-modal");
  const ctrl = IS_MAC ? "\u2318" : "Ctrl";
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CopyPasteModal> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ getContext, IS_MAC, Header: Header_default, close, ctrl });
  return [close, ctrl];
}
var CopyPasteModal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, not_equal, {}, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopyPasteModal",
      options,
      id: create_fragment16.name
    });
  }
};
var CopyPasteModal_default = CopyPasteModal;

// ../node_modules/svelte-jsoneditor/components/modals/repair/JSONRepairComponent.svelte
var file14 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/repair/JSONRepairComponent.svelte";
function add_css11(target) {
  append_styles(target, "svelte-ajsl25", ".jse-json-repair-component.svelte-ajsl25.svelte-ajsl25{flex:1;display:flex;flex-direction:column;background:var(--jse-background-color);color:var(--jse-text-color)}.jse-json-repair-component.svelte-ajsl25 .jse-menu .jse-info.svelte-ajsl25{padding:0 var(--jse-padding)}.jse-json-repair-component.svelte-ajsl25 .jse-json-text.svelte-ajsl25{flex:1;border:none;padding:2px;font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);background:var(--jse-background-color);color:var(--jse-text-color);resize:none;outline:none}.svelte-ajsl25.svelte-ajsl25{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTlJlcGFpckNvbXBvbmVudC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNkl1QywwQkFBQSw0QkFBQSxDQUFBLGdnQkFvQnRDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkpTT05SZXBhaXJDb21wb25lbnQuc3ZlbHRlIl19 */");
}
function create_left_slot(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("Repair invalid JSON, then click apply");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { slot: true, class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "Repair invalid JSON, then click apply");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "slot", "left");
      attr_dev(div, "class", "jse-info svelte-ajsl25");
      add_location(div, file14, 112, 4, 2893);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_left_slot.name,
    type: "slot",
    source: "(113:4) ",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let message;
  let current;
  message = new Message_default({
    props: {
      type: "success",
      message: "JSON is valid now and can be parsed.",
      actions: ctx[5]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty & 32)
        message_changes.actions = ctx2[5];
      message.$set(message_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(message, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(123:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let message;
  let current;
  message = new Message_default({
    props: {
      type: "error",
      icon: faExclamationTriangle,
      message: `Cannot parse JSON: ${ctx[2].message}`,
      actions: ctx[6]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty & 4)
        message_changes.message = `Cannot parse JSON: ${ctx2[2].message}`;
      if (dirty & 64)
        message_changes.actions = ctx2[6];
      message.$set(message_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(message, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(116:2) {#if error}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let div;
  let menu;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let textarea;
  let current;
  let mounted;
  let dispose;
  menu = new Menu_default({
    props: {
      items: ctx[7],
      $$slots: { left: [create_left_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block9, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      create_component(menu.$$.fragment);
      t0 = space();
      if_block.c();
      t1 = space();
      textarea = element("textarea");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(menu.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      if_block.l(div_nodes);
      t1 = claim_space(div_nodes);
      textarea = claim_element(div_nodes, "TEXTAREA", {
        class: true,
        autocomplete: true,
        autocapitalize: true,
        spellcheck: true
      });
      children(textarea).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      textarea.value = ctx[0];
      textarea.readOnly = ctx[1];
      attr_dev(textarea, "class", "jse-json-text svelte-ajsl25");
      attr_dev(textarea, "autocomplete", "off");
      attr_dev(textarea, "autocapitalize", "off");
      attr_dev(textarea, "spellcheck", "false");
      add_location(textarea, file14, 129, 2, 3298);
      attr_dev(div, "class", "jse-json-repair-component svelte-ajsl25");
      add_location(div, file14, 110, 0, 2806);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(menu, div, null);
      append_hydration_dev(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, textarea);
      ctx[19](textarea);
      ctx[20](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(textarea, "input", ctx[8], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 128)
        menu_changes.items = ctx2[7];
      if (dirty & 134217728) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t1);
      }
      if (!current || dirty & 1) {
        prop_dev(textarea, "value", ctx2[0]);
      }
      if (!current || dirty & 2) {
        prop_dev(textarea, "readOnly", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(menu);
      if_blocks[current_block_type_index].d();
      ctx[19](null);
      ctx[20](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let error;
  let repairable;
  let defaultItems;
  let items;
  let gotoAction;
  let repairAction;
  let errorActions;
  let successActions;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JSONRepairComponent", slots, []);
  let { text: text2 = "" } = $$props;
  let { readOnly = false } = $$props;
  let { onParse } = $$props;
  let { onRepair } = $$props;
  let { onChange = null } = $$props;
  let { onApply } = $$props;
  let { onCancel } = $$props;
  let { onRenderMenu = noop_default } = $$props;
  const debug5 = createDebug("jsoneditor:JSONRepair");
  let domJsonRepair;
  let domTextArea;
  function getErrorMessage(jsonText) {
    try {
      onParse(jsonText);
      return null;
    } catch (err) {
      return normalizeJsonParseError(jsonText, err.message);
    }
  }
  function isRepairable(jsonText) {
    try {
      onRepair(jsonText);
      return true;
    } catch (err) {
      return false;
    }
  }
  function goToError() {
    if (domTextArea && error && error.position != null) {
      domTextArea.setSelectionRange(error.position, error.position);
      setTimeout(() => {
        domTextArea.focus();
      });
    }
  }
  function handleChange(event) {
    debug5("handleChange");
    const value = event.target.value;
    if (text2 === value) {
      return;
    }
    $$invalidate(0, text2 = value);
    if (onChange) {
      onChange(text2);
    }
  }
  function handleApply() {
    onApply(text2);
  }
  function handleRepair() {
    try {
      $$invalidate(0, text2 = onRepair(text2));
      if (onChange) {
        onChange(text2);
      }
    } catch (err) {
    }
  }
  $$self.$$.on_mount.push(function() {
    if (onParse === void 0 && !("onParse" in $$props || $$self.$$.bound[$$self.$$.props["onParse"]])) {
      console.warn("<JSONRepairComponent> was created without expected prop 'onParse'");
    }
    if (onRepair === void 0 && !("onRepair" in $$props || $$self.$$.bound[$$self.$$.props["onRepair"]])) {
      console.warn("<JSONRepairComponent> was created without expected prop 'onRepair'");
    }
    if (onApply === void 0 && !("onApply" in $$props || $$self.$$.bound[$$self.$$.props["onApply"]])) {
      console.warn("<JSONRepairComponent> was created without expected prop 'onApply'");
    }
    if (onCancel === void 0 && !("onCancel" in $$props || $$self.$$.bound[$$self.$$.props["onCancel"]])) {
      console.warn("<JSONRepairComponent> was created without expected prop 'onCancel'");
    }
  });
  const writable_props = [
    "text",
    "readOnly",
    "onParse",
    "onRepair",
    "onChange",
    "onApply",
    "onCancel",
    "onRenderMenu"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<JSONRepairComponent> was created with unknown prop '${key}'`);
  });
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      domTextArea = $$value;
      $$invalidate(4, domTextArea);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      domJsonRepair = $$value;
      $$invalidate(3, domJsonRepair);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onParse" in $$props2)
      $$invalidate(9, onParse = $$props2.onParse);
    if ("onRepair" in $$props2)
      $$invalidate(10, onRepair = $$props2.onRepair);
    if ("onChange" in $$props2)
      $$invalidate(11, onChange = $$props2.onChange);
    if ("onApply" in $$props2)
      $$invalidate(12, onApply = $$props2.onApply);
    if ("onCancel" in $$props2)
      $$invalidate(13, onCancel = $$props2.onCancel);
    if ("onRenderMenu" in $$props2)
      $$invalidate(14, onRenderMenu = $$props2.onRenderMenu);
  };
  $$self.$capture_state = () => ({
    faArrowDown,
    faCheck,
    faExclamationTriangle,
    faTimes,
    faWrench,
    createDebug,
    Message: Message_default,
    normalizeJsonParseError,
    Menu: Menu_default,
    noop: noop_default,
    text: text2,
    readOnly,
    onParse,
    onRepair,
    onChange,
    onApply,
    onCancel,
    onRenderMenu,
    debug: debug5,
    domJsonRepair,
    domTextArea,
    getErrorMessage,
    isRepairable,
    goToError,
    handleChange,
    handleApply,
    handleRepair,
    successActions,
    gotoAction,
    repairAction,
    repairable,
    errorActions,
    defaultItems,
    items,
    error
  });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onParse" in $$props2)
      $$invalidate(9, onParse = $$props2.onParse);
    if ("onRepair" in $$props2)
      $$invalidate(10, onRepair = $$props2.onRepair);
    if ("onChange" in $$props2)
      $$invalidate(11, onChange = $$props2.onChange);
    if ("onApply" in $$props2)
      $$invalidate(12, onApply = $$props2.onApply);
    if ("onCancel" in $$props2)
      $$invalidate(13, onCancel = $$props2.onCancel);
    if ("onRenderMenu" in $$props2)
      $$invalidate(14, onRenderMenu = $$props2.onRenderMenu);
    if ("domJsonRepair" in $$props2)
      $$invalidate(3, domJsonRepair = $$props2.domJsonRepair);
    if ("domTextArea" in $$props2)
      $$invalidate(4, domTextArea = $$props2.domTextArea);
    if ("successActions" in $$props2)
      $$invalidate(5, successActions = $$props2.successActions);
    if ("gotoAction" in $$props2)
      $$invalidate(15, gotoAction = $$props2.gotoAction);
    if ("repairAction" in $$props2)
      $$invalidate(16, repairAction = $$props2.repairAction);
    if ("repairable" in $$props2)
      $$invalidate(17, repairable = $$props2.repairable);
    if ("errorActions" in $$props2)
      $$invalidate(6, errorActions = $$props2.errorActions);
    if ("defaultItems" in $$props2)
      $$invalidate(18, defaultItems = $$props2.defaultItems);
    if ("items" in $$props2)
      $$invalidate(7, items = $$props2.items);
    if ("error" in $$props2)
      $$invalidate(2, error = $$props2.error);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(2, error = getErrorMessage(text2));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(17, repairable = isRepairable(text2));
    }
    if ($$self.$$.dirty & 4) {
      $:
        debug5("error", error);
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(18, defaultItems = [
          { space: true },
          {
            icon: faTimes,
            title: "Cancel repair",
            className: "jse-cancel",
            onClick: onCancel
          }
        ]);
    }
    if ($$self.$$.dirty & 278528) {
      $:
        $$invalidate(7, items = onRenderMenu("repair", defaultItems) || defaultItems);
    }
    if ($$self.$$.dirty & 229376) {
      $:
        $$invalidate(6, errorActions = repairable ? [gotoAction, repairAction] : [gotoAction]);
    }
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(5, successActions = [
          {
            icon: faCheck,
            text: "Apply",
            title: "Apply fixed JSON",
            disabled: readOnly,
            onClick: handleApply
          }
        ]);
    }
  };
  $:
    $$invalidate(15, gotoAction = {
      icon: faArrowDown,
      text: "Show me",
      title: "Scroll to the error location",
      onClick: goToError
    });
  $:
    $$invalidate(16, repairAction = {
      icon: faWrench,
      text: "Auto repair",
      title: "Automatically repair JSON",
      onClick: handleRepair
    });
  return [
    text2,
    readOnly,
    error,
    domJsonRepair,
    domTextArea,
    successActions,
    errorActions,
    items,
    handleChange,
    onParse,
    onRepair,
    onChange,
    onApply,
    onCancel,
    onRenderMenu,
    gotoAction,
    repairAction,
    repairable,
    defaultItems,
    textarea_binding,
    div_binding
  ];
}
var JSONRepairComponent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      not_equal,
      {
        text: 0,
        readOnly: 1,
        onParse: 9,
        onRepair: 10,
        onChange: 11,
        onApply: 12,
        onCancel: 13,
        onRenderMenu: 14
      },
      add_css11
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONRepairComponent",
      options,
      id: create_fragment17.name
    });
  }
  get text() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onParse() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onParse(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRepair() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRepair(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onApply() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onApply(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCancel() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCancel(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderMenu() {
    throw new Error("<JSONRepairComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderMenu(value) {
    throw new Error("<JSONRepairComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JSONRepairComponent_default = JSONRepairComponent;

// ../node_modules/svelte-jsoneditor/components/modals/JSONRepairModal.svelte
var file15 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/JSONRepairModal.svelte";
function add_css12(target) {
  append_styles(target, "svelte-1oz66y8", ".jse-modal.jse-repair.svelte-1oz66y8{flex:1;display:flex;flex-direction:column;font-family:var(--jse-font-family);font-size:var(--jse-font-size);line-height:normal;background:var(--jse-background-color);color:var(--jse-text-color)}.svelte-1oz66y8{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTlJlcGFpck1vZGFsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtQ29DLFVBQVUsV0FBVyxlQUFDLENBQUEsQUFDeEQsSUFBSSxDQUFFLENBQUMsQ0FDUCxPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLFdBQVcsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLENBQ25DLFNBQVMsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxDQUMvQixXQUFXLENBQUUsTUFBTSxDQUNuQixVQUFVLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxDQUN2QyxLQUFLLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxBQUM5QixDQUFBLEFBQUEsZUFBQSxFQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkpTT05SZXBhaXJNb2RhbC5zdmVsdGUiXX0= */");
}
function create_fragment18(ctx) {
  let div;
  let jsonrepaircomponent;
  let updating_text;
  let current;
  function jsonrepaircomponent_text_binding(value) {
    ctx[7](value);
  }
  let jsonrepaircomponent_props = {
    onParse: ctx[1],
    onRepair: ctx[2],
    onApply: ctx[4],
    onCancel: ctx[5],
    onRenderMenu: ctx[3]
  };
  if (ctx[0] !== void 0) {
    jsonrepaircomponent_props.text = ctx[0];
  }
  jsonrepaircomponent = new JSONRepairComponent_default({
    props: jsonrepaircomponent_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(jsonrepaircomponent, "text", jsonrepaircomponent_text_binding));
  const block = {
    c: function create() {
      div = element("div");
      create_component(jsonrepaircomponent.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(jsonrepaircomponent.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-modal jse-repair svelte-1oz66y8");
      add_location(div, file15, 24, 0, 451);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(jsonrepaircomponent, div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const jsonrepaircomponent_changes = {};
      if (dirty & 2)
        jsonrepaircomponent_changes.onParse = ctx2[1];
      if (dirty & 4)
        jsonrepaircomponent_changes.onRepair = ctx2[2];
      if (dirty & 8)
        jsonrepaircomponent_changes.onRenderMenu = ctx2[3];
      if (!updating_text && dirty & 1) {
        updating_text = true;
        jsonrepaircomponent_changes.text = ctx2[0];
        add_flush_callback(() => updating_text = false);
      }
      jsonrepaircomponent.$set(jsonrepaircomponent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(jsonrepaircomponent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonrepaircomponent.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(jsonrepaircomponent);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JSONRepairModal", slots, []);
  let { text: text2 } = $$props;
  let { onParse } = $$props;
  let { onRepair } = $$props;
  let { onApply } = $$props;
  let { onRenderMenu } = $$props;
  const { close } = getContext("simple-modal");
  function handleApply(repairedText) {
    close();
    onApply(repairedText);
  }
  function handleCancel() {
    close();
  }
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<JSONRepairModal> was created without expected prop 'text'");
    }
    if (onParse === void 0 && !("onParse" in $$props || $$self.$$.bound[$$self.$$.props["onParse"]])) {
      console.warn("<JSONRepairModal> was created without expected prop 'onParse'");
    }
    if (onRepair === void 0 && !("onRepair" in $$props || $$self.$$.bound[$$self.$$.props["onRepair"]])) {
      console.warn("<JSONRepairModal> was created without expected prop 'onRepair'");
    }
    if (onApply === void 0 && !("onApply" in $$props || $$self.$$.bound[$$self.$$.props["onApply"]])) {
      console.warn("<JSONRepairModal> was created without expected prop 'onApply'");
    }
    if (onRenderMenu === void 0 && !("onRenderMenu" in $$props || $$self.$$.bound[$$self.$$.props["onRenderMenu"]])) {
      console.warn("<JSONRepairModal> was created without expected prop 'onRenderMenu'");
    }
  });
  const writable_props = ["text", "onParse", "onRepair", "onApply", "onRenderMenu"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<JSONRepairModal> was created with unknown prop '${key}'`);
  });
  function jsonrepaircomponent_text_binding(value) {
    text2 = value;
    $$invalidate(0, text2);
  }
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("onParse" in $$props2)
      $$invalidate(1, onParse = $$props2.onParse);
    if ("onRepair" in $$props2)
      $$invalidate(2, onRepair = $$props2.onRepair);
    if ("onApply" in $$props2)
      $$invalidate(6, onApply = $$props2.onApply);
    if ("onRenderMenu" in $$props2)
      $$invalidate(3, onRenderMenu = $$props2.onRenderMenu);
  };
  $$self.$capture_state = () => ({
    getContext,
    JSONRepairComponent: JSONRepairComponent_default,
    text: text2,
    onParse,
    onRepair,
    onApply,
    onRenderMenu,
    close,
    handleApply,
    handleCancel
  });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("onParse" in $$props2)
      $$invalidate(1, onParse = $$props2.onParse);
    if ("onRepair" in $$props2)
      $$invalidate(2, onRepair = $$props2.onRepair);
    if ("onApply" in $$props2)
      $$invalidate(6, onApply = $$props2.onApply);
    if ("onRenderMenu" in $$props2)
      $$invalidate(3, onRenderMenu = $$props2.onRenderMenu);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    text2,
    onParse,
    onRepair,
    onRenderMenu,
    handleApply,
    handleCancel,
    onApply,
    jsonrepaircomponent_text_binding
  ];
}
var JSONRepairModal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance18,
      create_fragment18,
      not_equal,
      {
        text: 0,
        onParse: 1,
        onRepair: 2,
        onApply: 6,
        onRenderMenu: 3
      },
      add_css12
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONRepairModal",
      options,
      id: create_fragment18.name
    });
  }
  get text() {
    throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onParse() {
    throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onParse(value) {
    throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRepair() {
    throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRepair(value) {
    throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onApply() {
    throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onApply(value) {
    throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderMenu() {
    throw new Error("<JSONRepairModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderMenu(value) {
    throw new Error("<JSONRepairModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JSONRepairModal_default = JSONRepairModal;

// ../node_modules/svelte-jsoneditor/components/controls/DropdownButton.svelte
var file16 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/DropdownButton.svelte";
function add_css13(target) {
  append_styles(target, "svelte-1owrsi7", ".jse-dropdown-button.svelte-1owrsi7.svelte-1owrsi7{flex:1;line-height:normal;border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;position:relative;padding:0;display:flex}.jse-dropdown-button.svelte-1owrsi7 ul.svelte-1owrsi7{margin:0;padding:0}.jse-dropdown-button.svelte-1owrsi7 ul li.svelte-1owrsi7{margin:0;padding:0;list-style-type:none}.jse-dropdown-button.svelte-1owrsi7 button.jse-open-dropdown.svelte-1owrsi7{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;width:2em;background:var(--jse-context-menu-background);color:var(--jse-context-menu-color);border-radius:0}.jse-dropdown-button.svelte-1owrsi7 button.jse-open-dropdown.jse-visible.svelte-1owrsi7{background:var(--jse-context-menu-background)}.jse-dropdown-button.svelte-1owrsi7 button.jse-open-dropdown.svelte-1owrsi7:hover{background:var(--jse-context-menu-background-highlight)}.jse-dropdown-button.svelte-1owrsi7 button.jse-open-dropdown.svelte-1owrsi7:disabled{color:var(--jse-context-menu-color-disabled);background:unset}.jse-dropdown-button.svelte-1owrsi7 .jse-dropdown-items.svelte-1owrsi7{display:none;position:absolute;top:100%;left:0;z-index:1;background:var(--jse-context-menu-background);color:var(--jse-context-menu-color);box-shadow:var(--jse-controls-box-shadow)}.jse-dropdown-button.svelte-1owrsi7 .jse-dropdown-items.jse-visible.svelte-1owrsi7{display:block}.jse-dropdown-button.svelte-1owrsi7 .jse-dropdown-items button.svelte-1owrsi7{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;width:100%;text-align:left;padding:var(--jse-padding);margin:0}.jse-dropdown-button.svelte-1owrsi7 .jse-dropdown-items button.svelte-1owrsi7:hover{background:var(--jse-context-menu-background-highlight)}.jse-dropdown-button.svelte-1owrsi7 .jse-dropdown-items button.svelte-1owrsi7:disabled{color:var(--jse-context-menu-color-disabled);background:unset}.svelte-1owrsi7.svelte-1owrsi7{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRHJvcGRvd25CdXR0b24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdFa0Msb0JBQUEsOEJBQUEsQ0FBQSx3akVBaUZqQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEcm9wZG93bkJ1dHRvbi5zdmVsdGUiXX0= */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
var get_defaultItem_slot_changes = (dirty) => ({});
var get_defaultItem_slot_context = (ctx) => ({});
function create_if_block10(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: ctx[11].icon },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & 1)
        icon_changes.data = ctx2[11].icon;
      icon.$set(icon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(62:12) {#if item.icon}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let li;
  let button;
  let t0;
  let t1_value = ctx[11].text + "";
  let t1;
  let button_title_value;
  let button_disabled_value;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[11].icon && create_if_block10(ctx);
  function click_handler() {
    return ctx[9](ctx[11]);
  }
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      if (if_block)
        if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", { type: true, title: true, class: true });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t0 = claim_space(button_nodes);
      t1 = claim_text(button_nodes, t1_value);
      button_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "title", button_title_value = ctx[11].title);
      button.disabled = button_disabled_value = ctx[11].disabled;
      attr_dev(button, "class", "svelte-1owrsi7");
      add_location(button, file16, 55, 10, 1661);
      attr_dev(li, "class", "svelte-1owrsi7");
      add_location(li, file16, 54, 8, 1646);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      if (if_block)
        if_block.m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(li, t2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[11].icon) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx[11].text + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty & 1 && button_title_value !== (button_title_value = ctx[11].title)) {
        attr_dev(button, "title", button_title_value);
      }
      if (!current || dirty & 1 && button_disabled_value !== (button_disabled_value = ctx[11].disabled)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(li);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(54:6) {#each items as item}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let div1;
  let t0;
  let button;
  let icon;
  let t1;
  let div0;
  let ul;
  let current;
  let mounted;
  let dispose;
  const defaultItem_slot_template = ctx[8].defaultItem;
  const defaultItem_slot = create_slot(defaultItem_slot_template, ctx, ctx[7], get_defaultItem_slot_context);
  icon = new Icon_default({
    props: { data: faCaretDown },
    $$inline: true
  });
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div1 = element("div");
      if (defaultItem_slot)
        defaultItem_slot.c();
      t0 = space();
      button = element("button");
      create_component(icon.$$.fragment);
      t1 = space();
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, title: true });
      var div1_nodes = children(div1);
      if (defaultItem_slot)
        defaultItem_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", {
        type: true,
        class: true,
        "data-type": true
      });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      var div0_nodes = children(div0);
      ul = claim_element(div0_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-open-dropdown svelte-1owrsi7");
      attr_dev(button, "data-type", "jse-open-dropdown");
      button.disabled = ctx[4];
      toggle_class(button, "jse-visible", ctx[3]);
      add_location(button, file16, 40, 2, 1285);
      attr_dev(ul, "class", "svelte-1owrsi7");
      add_location(ul, file16, 52, 4, 1605);
      attr_dev(div0, "class", "jse-dropdown-items svelte-1owrsi7");
      set_style(div0, "width", ctx[2]);
      toggle_class(div0, "jse-visible", ctx[3]);
      add_location(div0, file16, 51, 2, 1516);
      attr_dev(div1, "class", "jse-dropdown-button svelte-1owrsi7");
      attr_dev(div1, "title", ctx[1]);
      add_location(div1, file16, 37, 0, 1187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (defaultItem_slot) {
        defaultItem_slot.m(div1, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, button);
      mount_component(icon, button, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[5], false, false, false),
          listen_dev(div1, "click", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (defaultItem_slot) {
        if (defaultItem_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            defaultItem_slot,
            defaultItem_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(defaultItem_slot_template, ctx2[7], dirty, get_defaultItem_slot_changes),
            get_defaultItem_slot_context
          );
        }
      }
      if (!current || dirty & 16) {
        prop_dev(button, "disabled", ctx2[4]);
      }
      if (!current || dirty & 8) {
        toggle_class(button, "jse-visible", ctx2[3]);
      }
      if (dirty & 1) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 4) {
        set_style(div0, "width", ctx2[2]);
      }
      if (!current || dirty & 8) {
        toggle_class(div0, "jse-visible", ctx2[3]);
      }
      if (!current || dirty & 2) {
        attr_dev(div1, "title", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(defaultItem_slot, local);
      transition_in(icon.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(defaultItem_slot, local);
      transition_out(icon.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div1);
      if (defaultItem_slot)
        defaultItem_slot.d(detaching);
      destroy_component(icon);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let allItemsDisabled;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownButton", slots, ["defaultItem"]);
  let { items = [] } = $$props;
  let { title = void 0 } = $$props;
  let { width = "120px" } = $$props;
  let visible = false;
  function toggleShow() {
    const wasVisible = visible;
    setTimeout(() => $$invalidate(3, visible = !wasVisible));
  }
  function handleClick() {
    $$invalidate(3, visible = false);
  }
  function handleKeyDown(event) {
    const combo = keyComboFromEvent(event);
    if (combo === "Escape") {
      event.preventDefault();
      $$invalidate(3, visible = false);
    }
  }
  onMount(() => {
    document.addEventListener("click", handleClick);
    document.addEventListener("keydown", handleKeyDown);
  });
  onDestroy(() => {
    document.removeEventListener("click", handleClick);
    document.removeEventListener("keydown", handleKeyDown);
  });
  const writable_props = ["items", "title", "width"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DropdownButton> was created with unknown prop '${key}'`);
  });
  const click_handler = (item) => item.onClick();
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Icon: Icon_default,
    faCaretDown,
    onDestroy,
    onMount,
    keyComboFromEvent,
    items,
    title,
    width,
    visible,
    toggleShow,
    handleClick,
    handleKeyDown,
    allItemsDisabled
  });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("visible" in $$props2)
      $$invalidate(3, visible = $$props2.visible);
    if ("allItemsDisabled" in $$props2)
      $$invalidate(4, allItemsDisabled = $$props2.allItemsDisabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(4, allItemsDisabled = items.every((item) => item.disabled === true));
    }
  };
  return [
    items,
    title,
    width,
    visible,
    allItemsDisabled,
    toggleShow,
    handleClick,
    $$scope,
    slots,
    click_handler
  ];
}
var DropdownButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, not_equal, { items: 0, title: 1, width: 2 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownButton",
      options,
      id: create_fragment19.name
    });
  }
  get items() {
    throw new Error("<DropdownButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<DropdownButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<DropdownButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<DropdownButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<DropdownButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<DropdownButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownButton_default = DropdownButton;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/contextmenu/ContextMenu.svelte
var file17 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/contextmenu/ContextMenu.svelte";
function add_css14(target) {
  append_styles(target, "svelte-195fjzg", ".jse-contextmenu.svelte-195fjzg.svelte-195fjzg{box-shadow:var(--jse-controls-box-shadow);font-family:var(--jse-font-family);font-size:var(--jse-font-size);background:var(--jse-context-menu-background);color:var(--jse-context-menu-color)}.jse-contextmenu.svelte-195fjzg button.svelte-195fjzg{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0}.jse-contextmenu.svelte-195fjzg button.svelte-195fjzg:focus{background:var(--jse-context-menu-background-highlight)}.jse-contextmenu.svelte-195fjzg .jse-row.svelte-195fjzg{display:flex;flex-direction:row;align-items:flex-start;justify-content:stretch}.jse-contextmenu.svelte-195fjzg .jse-row div.jse-label.svelte-195fjzg{flex:1;white-space:nowrap;padding:var(--jse-padding);color:var(--jse-context-menu-color-disabled);line-height:normal}.jse-contextmenu.svelte-195fjzg .jse-row div.jse-tip.svelte-195fjzg{flex:1;background:var(--jse-context-menu-tip-background);color:var(--jse-context-menu-tip-color);margin:calc(0.5 * var(--jse-padding));padding:calc(0.5 * var(--jse-padding)) var(--jse-padding);font-size:80%;line-height:1.3em;display:flex;flex-direction:row;align-items:center;gap:var(--jse-padding);border-radius:3px}.jse-contextmenu.svelte-195fjzg .jse-row div.jse-tip div.svelte-195fjzg{vertical-align:middle}.jse-contextmenu.svelte-195fjzg .jse-row button.svelte-195fjzg{flex:1;white-space:nowrap;padding:var(--jse-padding);color:inherit}.jse-contextmenu.svelte-195fjzg .jse-row button.svelte-195fjzg:hover{background:var(--jse-context-menu-background-highlight)}.jse-contextmenu.svelte-195fjzg .jse-row button.svelte-195fjzg:disabled{color:var(--jse-context-menu-color-disabled);background:unset}.jse-contextmenu.svelte-195fjzg .jse-row button .jse-insert.svelte-195fjzg{display:inline-block;position:relative;width:18px;height:18px;font-family:var(--jse-font-family-mono);font-weight:bold;font-size:16px}.jse-contextmenu.svelte-195fjzg .jse-row button .jse-insert .jse-quote.svelte-195fjzg,.jse-contextmenu.svelte-195fjzg .jse-row button .jse-insert .jse-plus.svelte-195fjzg{position:absolute;top:-4px;left:2px;font-size:24px}.jse-contextmenu.svelte-195fjzg .jse-column.svelte-195fjzg{flex:1;display:flex;flex-direction:column;align-items:stretch}.jse-contextmenu.svelte-195fjzg .jse-column.svelte-195fjzg:not(:last-child){border-right:1px solid var(--jse-context-menu-separator-color)}.jse-contextmenu.svelte-195fjzg .jse-column button.svelte-195fjzg{text-align:left;min-width:130px}.jse-contextmenu.svelte-195fjzg .jse-separator.svelte-195fjzg{width:100%;height:1px;background:var(--jse-context-menu-separator-color)}.svelte-195fjzg.svelte-195fjzg{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGV4dE1lbnUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1ZK0IsZ0JBQUEsOEJBQUEsQ0FBQSxpbUZBZ0c5QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDb250ZXh0TWVudS5zdmVsdGUiXX0= */");
}
function create_defaultItem_slot_2(ctx) {
  let button;
  let icon;
  let t;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faPen }, $$inline: true });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      t = text(" Edit value");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        slot: true,
        title: true,
        class: true
      });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      t = claim_text(button_nodes, " Edit value");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "slot", "defaultItem");
      attr_dev(button, "title", "Edit the value (Double-click on the value)");
      button.disabled = button_disabled_value = !ctx[2];
      attr_dev(button, "class", "svelte-195fjzg");
      add_location(button, file17, 230, 6, 7401);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      append_hydration_dev(button, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[18], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 4 && button_disabled_value !== (button_disabled_value = !ctx2[2])) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_defaultItem_slot_2.name,
    type: "slot",
    source: "(231:6) ",
    ctx
  });
  return block;
}
function create_defaultItem_slot_1(ctx) {
  let button;
  let icon;
  let t;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faCut }, $$inline: true });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      t = text(" Cut");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        slot: true,
        title: true,
        class: true
      });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      t = claim_text(button_nodes, " Cut");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "slot", "defaultItem");
      attr_dev(button, "title", "Cut selected contents, formatted with indentation (Ctrl+X)");
      button.disabled = button_disabled_value = !ctx[1];
      attr_dev(button, "class", "svelte-195fjzg");
      add_location(button, file17, 244, 6, 7802);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      append_hydration_dev(button, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[19], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 2 && button_disabled_value !== (button_disabled_value = !ctx2[1])) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_defaultItem_slot_1.name,
    type: "slot",
    source: "(245:6) ",
    ctx
  });
  return block;
}
function create_defaultItem_slot(ctx) {
  let button;
  let icon;
  let t;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faCopy }, $$inline: true });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      t = text(" Copy");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        slot: true,
        title: true,
        class: true
      });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      t = claim_text(button_nodes, " Copy");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "slot", "defaultItem");
      attr_dev(button, "title", "Copy selected contents, formatted with indentation (Ctrl+C)");
      button.disabled = button_disabled_value = !ctx[1];
      attr_dev(button, "class", "svelte-195fjzg");
      add_location(button, file17, 255, 6, 8150);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      append_hydration_dev(button, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[20], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 2 && button_disabled_value !== (button_disabled_value = !ctx2[1])) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_defaultItem_slot.name,
    type: "slot",
    source: "(256:6) ",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let div3;
  let div2;
  let div0;
  let icon;
  let t0;
  let div1;
  let t1;
  let current;
  icon = new Icon_default({
    props: { data: faLightbulb },
    $$inline: true
  });
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      create_component(icon.$$.fragment);
      t0 = space();
      div1 = element("div");
      t1 = text("Tip: you can open this context menu via right-click or with Ctrl+Q");
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(icon.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, "Tip: you can open this context menu via right-click or with Ctrl+Q");
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "svelte-195fjzg");
      add_location(div0, file17, 378, 8, 11774);
      attr_dev(div1, "class", "svelte-195fjzg");
      add_location(div1, file17, 381, 8, 11841);
      attr_dev(div2, "class", "jse-tip svelte-195fjzg");
      add_location(div2, file17, 377, 6, 11744);
      attr_dev(div3, "class", "jse-row svelte-195fjzg");
      add_location(div3, file17, 376, 4, 11716);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div0);
      mount_component(icon, div0, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t1);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div3);
      destroy_component(icon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(376:2) {#if showTip}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let div10;
  let div0;
  let button0;
  let icon0;
  let t0;
  let button0_disabled_value;
  let t1;
  let dropdownbutton0;
  let t2;
  let div1;
  let t3;
  let div2;
  let dropdownbutton1;
  let t4;
  let dropdownbutton2;
  let t5;
  let button1;
  let icon1;
  let t6;
  let button1_disabled_value;
  let t7;
  let div3;
  let t8;
  let div7;
  let div4;
  let button2;
  let icon2;
  let t9;
  let button2_disabled_value;
  let t10;
  let button3;
  let icon3;
  let t11;
  let button3_disabled_value;
  let t12;
  let button4;
  let icon4;
  let t13;
  let button4_disabled_value;
  let t14;
  let button5;
  let icon5;
  let t15;
  let button5_disabled_value;
  let t16;
  let button6;
  let icon6;
  let t17;
  let button6_disabled_value;
  let t18;
  let div6;
  let div5;
  let t19;
  let t20;
  let t21;
  let button7;
  let span1;
  let span0;
  let t22_value = "+";
  let t22;
  let t23;
  let button7_title_value;
  let button7_disabled_value;
  let t24;
  let button8;
  let span2;
  let t25_value = "{}";
  let t25;
  let t26;
  let button8_title_value;
  let button8_disabled_value;
  let t27;
  let button9;
  let span3;
  let t28;
  let t29;
  let button9_title_value;
  let button9_disabled_value;
  let t30;
  let button10;
  let span5;
  let span4;
  let t31;
  let t32;
  let button10_title_value;
  let button10_disabled_value;
  let t33;
  let div8;
  let t34;
  let div9;
  let button11;
  let icon7;
  let t35;
  let button11_disabled_value;
  let t36;
  let button12;
  let icon8;
  let t37;
  let button12_disabled_value;
  let t38;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faPen }, $$inline: true });
  dropdownbutton0 = new DropdownButton_default({
    props: {
      width: "11em",
      items: ctx[8],
      $$slots: { defaultItem: [create_defaultItem_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  dropdownbutton1 = new DropdownButton_default({
    props: {
      width: "10em",
      items: ctx[7],
      $$slots: { defaultItem: [create_defaultItem_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  dropdownbutton2 = new DropdownButton_default({
    props: {
      width: "12em",
      items: ctx[6],
      $$slots: { defaultItem: [create_defaultItem_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  icon1 = new Icon_default({ props: { data: faPaste }, $$inline: true });
  icon2 = new Icon_default({ props: { data: faTimes }, $$inline: true });
  icon3 = new Icon_default({ props: { data: faClone }, $$inline: true });
  icon4 = new Icon_default({
    props: { data: faCropAlt },
    $$inline: true
  });
  icon5 = new Icon_default({
    props: { data: faSortAmountDownAlt },
    $$inline: true
  });
  icon6 = new Icon_default({
    props: { data: faFilter },
    $$inline: true
  });
  icon7 = new Icon_default({
    props: { data: faCaretSquareUp },
    $$inline: true
  });
  icon8 = new Icon_default({
    props: { data: faCaretSquareDown },
    $$inline: true
  });
  let if_block = ctx[0] && create_if_block11(ctx);
  const block = {
    c: function create() {
      div10 = element("div");
      div0 = element("div");
      button0 = element("button");
      create_component(icon0.$$.fragment);
      t0 = text(" Edit key");
      t1 = space();
      create_component(dropdownbutton0.$$.fragment);
      t2 = space();
      div1 = element("div");
      t3 = space();
      div2 = element("div");
      create_component(dropdownbutton1.$$.fragment);
      t4 = space();
      create_component(dropdownbutton2.$$.fragment);
      t5 = space();
      button1 = element("button");
      create_component(icon1.$$.fragment);
      t6 = text(" Paste");
      t7 = space();
      div3 = element("div");
      t8 = space();
      div7 = element("div");
      div4 = element("div");
      button2 = element("button");
      create_component(icon2.$$.fragment);
      t9 = text(" Remove");
      t10 = space();
      button3 = element("button");
      create_component(icon3.$$.fragment);
      t11 = text(" Duplicate");
      t12 = space();
      button4 = element("button");
      create_component(icon4.$$.fragment);
      t13 = text(" Extract");
      t14 = space();
      button5 = element("button");
      create_component(icon5.$$.fragment);
      t15 = text(" Sort");
      t16 = space();
      button6 = element("button");
      create_component(icon6.$$.fragment);
      t17 = text(" Transform");
      t18 = space();
      div6 = element("div");
      div5 = element("div");
      t19 = text(ctx[13]);
      t20 = text(":");
      t21 = space();
      button7 = element("button");
      span1 = element("span");
      span0 = element("span");
      t22 = text(t22_value);
      t23 = text(" Structure");
      t24 = space();
      button8 = element("button");
      span2 = element("span");
      t25 = text(t25_value);
      t26 = text(" Object");
      t27 = space();
      button9 = element("button");
      span3 = element("span");
      t28 = text("[]");
      t29 = text(" Array");
      t30 = space();
      button10 = element("button");
      span5 = element("span");
      span4 = element("span");
      t31 = text('"');
      t32 = text(" Value");
      t33 = space();
      div8 = element("div");
      t34 = space();
      div9 = element("div");
      button11 = element("button");
      create_component(icon7.$$.fragment);
      t35 = text(" Insert before");
      t36 = space();
      button12 = element("button");
      create_component(icon8.$$.fragment);
      t37 = text(" Insert after");
      t38 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div10 = claim_element(nodes, "DIV", { class: true });
      var div10_nodes = children(div10);
      div0 = claim_element(div10_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", { type: true, title: true, class: true });
      var button0_nodes = children(button0);
      claim_component(icon0.$$.fragment, button0_nodes);
      t0 = claim_text(button0_nodes, " Edit key");
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      claim_component(dropdownbutton0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div10_nodes);
      div1 = claim_element(div10_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      t3 = claim_space(div10_nodes);
      div2 = claim_element(div10_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(dropdownbutton1.$$.fragment, div2_nodes);
      t4 = claim_space(div2_nodes);
      claim_component(dropdownbutton2.$$.fragment, div2_nodes);
      t5 = claim_space(div2_nodes);
      button1 = claim_element(div2_nodes, "BUTTON", { type: true, title: true, class: true });
      var button1_nodes = children(button1);
      claim_component(icon1.$$.fragment, button1_nodes);
      t6 = claim_text(button1_nodes, " Paste");
      button1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t7 = claim_space(div10_nodes);
      div3 = claim_element(div10_nodes, "DIV", { class: true });
      children(div3).forEach(detach_dev);
      t8 = claim_space(div10_nodes);
      div7 = claim_element(div10_nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      div4 = claim_element(div7_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      button2 = claim_element(div4_nodes, "BUTTON", { type: true, title: true, class: true });
      var button2_nodes = children(button2);
      claim_component(icon2.$$.fragment, button2_nodes);
      t9 = claim_text(button2_nodes, " Remove");
      button2_nodes.forEach(detach_dev);
      t10 = claim_space(div4_nodes);
      button3 = claim_element(div4_nodes, "BUTTON", { type: true, title: true, class: true });
      var button3_nodes = children(button3);
      claim_component(icon3.$$.fragment, button3_nodes);
      t11 = claim_text(button3_nodes, " Duplicate");
      button3_nodes.forEach(detach_dev);
      t12 = claim_space(div4_nodes);
      button4 = claim_element(div4_nodes, "BUTTON", { type: true, title: true, class: true });
      var button4_nodes = children(button4);
      claim_component(icon4.$$.fragment, button4_nodes);
      t13 = claim_text(button4_nodes, " Extract");
      button4_nodes.forEach(detach_dev);
      t14 = claim_space(div4_nodes);
      button5 = claim_element(div4_nodes, "BUTTON", { type: true, title: true, class: true });
      var button5_nodes = children(button5);
      claim_component(icon5.$$.fragment, button5_nodes);
      t15 = claim_text(button5_nodes, " Sort");
      button5_nodes.forEach(detach_dev);
      t16 = claim_space(div4_nodes);
      button6 = claim_element(div4_nodes, "BUTTON", { type: true, title: true, class: true });
      var button6_nodes = children(button6);
      claim_component(icon6.$$.fragment, button6_nodes);
      t17 = claim_text(button6_nodes, " Transform");
      button6_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t18 = claim_space(div7_nodes);
      div6 = claim_element(div7_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      t19 = claim_text(div5_nodes, ctx[13]);
      t20 = claim_text(div5_nodes, ":");
      div5_nodes.forEach(detach_dev);
      t21 = claim_space(div6_nodes);
      button7 = claim_element(div6_nodes, "BUTTON", { type: true, title: true, class: true });
      var button7_nodes = children(button7);
      span1 = claim_element(button7_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t22 = claim_text(span0_nodes, t22_value);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t23 = claim_text(button7_nodes, " Structure");
      button7_nodes.forEach(detach_dev);
      t24 = claim_space(div6_nodes);
      button8 = claim_element(div6_nodes, "BUTTON", { type: true, title: true, class: true });
      var button8_nodes = children(button8);
      span2 = claim_element(button8_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t25 = claim_text(span2_nodes, t25_value);
      span2_nodes.forEach(detach_dev);
      t26 = claim_text(button8_nodes, " Object");
      button8_nodes.forEach(detach_dev);
      t27 = claim_space(div6_nodes);
      button9 = claim_element(div6_nodes, "BUTTON", { type: true, title: true, class: true });
      var button9_nodes = children(button9);
      span3 = claim_element(button9_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      t28 = claim_text(span3_nodes, "[]");
      span3_nodes.forEach(detach_dev);
      t29 = claim_text(button9_nodes, " Array");
      button9_nodes.forEach(detach_dev);
      t30 = claim_space(div6_nodes);
      button10 = claim_element(div6_nodes, "BUTTON", { type: true, title: true, class: true });
      var button10_nodes = children(button10);
      span5 = claim_element(button10_nodes, "SPAN", { class: true });
      var span5_nodes = children(span5);
      span4 = claim_element(span5_nodes, "SPAN", { class: true });
      var span4_nodes = children(span4);
      t31 = claim_text(span4_nodes, '"');
      span4_nodes.forEach(detach_dev);
      span5_nodes.forEach(detach_dev);
      t32 = claim_text(button10_nodes, " Value");
      button10_nodes.forEach(detach_dev);
      div6_nodes.forEach(detach_dev);
      div7_nodes.forEach(detach_dev);
      t33 = claim_space(div10_nodes);
      div8 = claim_element(div10_nodes, "DIV", { class: true });
      children(div8).forEach(detach_dev);
      t34 = claim_space(div10_nodes);
      div9 = claim_element(div10_nodes, "DIV", { class: true });
      var div9_nodes = children(div9);
      button11 = claim_element(div9_nodes, "BUTTON", { type: true, title: true, class: true });
      var button11_nodes = children(button11);
      claim_component(icon7.$$.fragment, button11_nodes);
      t35 = claim_text(button11_nodes, " Insert before");
      button11_nodes.forEach(detach_dev);
      t36 = claim_space(div9_nodes);
      button12 = claim_element(div9_nodes, "BUTTON", { type: true, title: true, class: true });
      var button12_nodes = children(button12);
      claim_component(icon8.$$.fragment, button12_nodes);
      t37 = claim_text(button12_nodes, " Insert after");
      button12_nodes.forEach(detach_dev);
      div9_nodes.forEach(detach_dev);
      t38 = claim_space(div10_nodes);
      if (if_block)
        if_block.l(div10_nodes);
      div10_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "title", "Edit the key (Double-click on the key)");
      button0.disabled = button0_disabled_value = !ctx[14];
      attr_dev(button0, "class", "svelte-195fjzg");
      add_location(button0, file17, 221, 4, 7132);
      attr_dev(div0, "class", "jse-row svelte-195fjzg");
      add_location(div0, file17, 220, 2, 7106);
      attr_dev(div1, "class", "jse-separator svelte-195fjzg");
      add_location(div1, file17, 241, 2, 7683);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "title", "Paste clipboard contents (Ctrl+V)");
      button1.disabled = button1_disabled_value = !ctx[3];
      attr_dev(button1, "class", "svelte-195fjzg");
      add_location(button1, file17, 265, 4, 8440);
      attr_dev(div2, "class", "jse-row svelte-195fjzg");
      add_location(div2, file17, 242, 2, 7715);
      attr_dev(div3, "class", "jse-separator svelte-195fjzg");
      add_location(div3, file17, 274, 2, 8643);
      attr_dev(button2, "type", "button");
      attr_dev(button2, "title", "Remove selected contents (Delete)");
      button2.disabled = button2_disabled_value = !ctx[1];
      attr_dev(button2, "class", "svelte-195fjzg");
      add_location(button2, file17, 277, 6, 8732);
      attr_dev(button3, "type", "button");
      attr_dev(button3, "title", "Duplicate selected contents (Ctrl+D)");
      button3.disabled = button3_disabled_value = !ctx[16];
      attr_dev(button3, "class", "svelte-195fjzg");
      add_location(button3, file17, 285, 6, 8954);
      attr_dev(button4, "type", "button");
      attr_dev(button4, "title", "Extract selected contents");
      button4.disabled = button4_disabled_value = !ctx[15];
      attr_dev(button4, "class", "svelte-195fjzg");
      add_location(button4, file17, 293, 6, 9177);
      attr_dev(button5, "type", "button");
      attr_dev(button5, "title", "Sort array or object contents");
      button5.disabled = button5_disabled_value = !ctx[1];
      attr_dev(button5, "class", "svelte-195fjzg");
      add_location(button5, file17, 301, 6, 9385);
      attr_dev(button6, "type", "button");
      attr_dev(button6, "title", "Transform array or object contents (filter, sort, project)");
      button6.disabled = button6_disabled_value = !ctx[1];
      attr_dev(button6, "class", "svelte-195fjzg");
      add_location(button6, file17, 309, 6, 9611);
      attr_dev(div4, "class", "jse-column svelte-195fjzg");
      add_location(div4, file17, 276, 4, 8701);
      attr_dev(div5, "class", "jse-label svelte-195fjzg");
      add_location(div5, file17, 319, 6, 9905);
      attr_dev(span0, "class", "jse-plus svelte-195fjzg");
      add_location(span0, file17, 328, 33, 10206);
      attr_dev(span1, "class", "jse-insert svelte-195fjzg");
      add_location(span1, file17, 328, 8, 10181);
      attr_dev(button7, "type", "button");
      attr_dev(button7, "title", button7_title_value = ctx[13] + " structure");
      button7.disabled = button7_disabled_value = !ctx[12];
      attr_dev(button7, "class", "svelte-195fjzg");
      add_location(button7, file17, 322, 6, 9979);
      attr_dev(span2, "class", "jse-insert svelte-195fjzg");
      add_location(span2, file17, 336, 8, 10474);
      attr_dev(button8, "type", "button");
      attr_dev(button8, "title", button8_title_value = ctx[13] + " object");
      button8.disabled = button8_disabled_value = !ctx[11];
      attr_dev(button8, "class", "svelte-195fjzg");
      add_location(button8, file17, 330, 6, 10281);
      attr_dev(span3, "class", "jse-insert svelte-195fjzg");
      add_location(span3, file17, 344, 8, 10732);
      attr_dev(button9, "type", "button");
      attr_dev(button9, "title", button9_title_value = ctx[13] + " array");
      button9.disabled = button9_disabled_value = !ctx[10];
      attr_dev(button9, "class", "svelte-195fjzg");
      add_location(button9, file17, 338, 6, 10542);
      attr_dev(span4, "class", "jse-quote svelte-195fjzg");
      add_location(span4, file17, 352, 33, 11010);
      attr_dev(span5, "class", "jse-insert svelte-195fjzg");
      add_location(span5, file17, 352, 8, 10985);
      attr_dev(button10, "type", "button");
      attr_dev(button10, "title", button10_title_value = ctx[13] + " value");
      button10.disabled = button10_disabled_value = !ctx[9];
      attr_dev(button10, "class", "svelte-195fjzg");
      add_location(button10, file17, 346, 6, 10795);
      attr_dev(div6, "class", "jse-column svelte-195fjzg");
      add_location(div6, file17, 318, 4, 9874);
      attr_dev(div7, "class", "jse-row svelte-195fjzg");
      add_location(div7, file17, 275, 2, 8675);
      attr_dev(div8, "class", "jse-separator svelte-195fjzg");
      add_location(div8, file17, 356, 2, 11094);
      attr_dev(button11, "type", "button");
      attr_dev(button11, "title", "Select area before current entry to insert or paste contents");
      button11.disabled = button11_disabled_value = !ctx[1] || ctx[4];
      attr_dev(button11, "class", "svelte-195fjzg");
      add_location(button11, file17, 358, 4, 11152);
      attr_dev(button12, "type", "button");
      attr_dev(button12, "title", "Select area after current entry to insert or paste contents");
      button12.disabled = button12_disabled_value = !ctx[1] || ctx[4];
      attr_dev(button12, "class", "svelte-195fjzg");
      add_location(button12, file17, 366, 4, 11422);
      attr_dev(div9, "class", "jse-row svelte-195fjzg");
      add_location(div9, file17, 357, 2, 11126);
      attr_dev(div10, "class", "jse-contextmenu svelte-195fjzg");
      add_location(div10, file17, 219, 0, 7020);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div10, anchor);
      append_hydration_dev(div10, div0);
      append_hydration_dev(div0, button0);
      mount_component(icon0, button0, null);
      append_hydration_dev(button0, t0);
      append_hydration_dev(div0, t1);
      mount_component(dropdownbutton0, div0, null);
      append_hydration_dev(div10, t2);
      append_hydration_dev(div10, div1);
      append_hydration_dev(div10, t3);
      append_hydration_dev(div10, div2);
      mount_component(dropdownbutton1, div2, null);
      append_hydration_dev(div2, t4);
      mount_component(dropdownbutton2, div2, null);
      append_hydration_dev(div2, t5);
      append_hydration_dev(div2, button1);
      mount_component(icon1, button1, null);
      append_hydration_dev(button1, t6);
      append_hydration_dev(div10, t7);
      append_hydration_dev(div10, div3);
      append_hydration_dev(div10, t8);
      append_hydration_dev(div10, div7);
      append_hydration_dev(div7, div4);
      append_hydration_dev(div4, button2);
      mount_component(icon2, button2, null);
      append_hydration_dev(button2, t9);
      append_hydration_dev(div4, t10);
      append_hydration_dev(div4, button3);
      mount_component(icon3, button3, null);
      append_hydration_dev(button3, t11);
      append_hydration_dev(div4, t12);
      append_hydration_dev(div4, button4);
      mount_component(icon4, button4, null);
      append_hydration_dev(button4, t13);
      append_hydration_dev(div4, t14);
      append_hydration_dev(div4, button5);
      mount_component(icon5, button5, null);
      append_hydration_dev(button5, t15);
      append_hydration_dev(div4, t16);
      append_hydration_dev(div4, button6);
      mount_component(icon6, button6, null);
      append_hydration_dev(button6, t17);
      append_hydration_dev(div7, t18);
      append_hydration_dev(div7, div6);
      append_hydration_dev(div6, div5);
      append_hydration_dev(div5, t19);
      append_hydration_dev(div5, t20);
      append_hydration_dev(div6, t21);
      append_hydration_dev(div6, button7);
      append_hydration_dev(button7, span1);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t22);
      append_hydration_dev(button7, t23);
      append_hydration_dev(div6, t24);
      append_hydration_dev(div6, button8);
      append_hydration_dev(button8, span2);
      append_hydration_dev(span2, t25);
      append_hydration_dev(button8, t26);
      append_hydration_dev(div6, t27);
      append_hydration_dev(div6, button9);
      append_hydration_dev(button9, span3);
      append_hydration_dev(span3, t28);
      append_hydration_dev(button9, t29);
      append_hydration_dev(div6, t30);
      append_hydration_dev(div6, button10);
      append_hydration_dev(button10, span5);
      append_hydration_dev(span5, span4);
      append_hydration_dev(span4, t31);
      append_hydration_dev(button10, t32);
      append_hydration_dev(div10, t33);
      append_hydration_dev(div10, div8);
      append_hydration_dev(div10, t34);
      append_hydration_dev(div10, div9);
      append_hydration_dev(div9, button11);
      mount_component(icon7, button11, null);
      append_hydration_dev(button11, t35);
      append_hydration_dev(div9, t36);
      append_hydration_dev(div9, button12);
      mount_component(icon8, button12, null);
      append_hydration_dev(button12, t37);
      append_hydration_dev(div10, t38);
      if (if_block)
        if_block.m(div10, null);
      ctx[59](div10);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", ctx[17], false, false, false),
          listen_dev(button1, "click", ctx[21], false, false, false),
          listen_dev(button2, "click", ctx[22], false, false, false),
          listen_dev(button3, "click", ctx[23], false, false, false),
          listen_dev(button4, "click", ctx[24], false, false, false),
          listen_dev(button5, "click", ctx[26], false, false, false),
          listen_dev(button6, "click", ctx[27], false, false, false),
          listen_dev(button7, "click", ctx[55], false, false, false),
          listen_dev(button8, "click", ctx[56], false, false, false),
          listen_dev(button9, "click", ctx[57], false, false, false),
          listen_dev(button10, "click", ctx[58], false, false, false),
          listen_dev(button11, "click", ctx[28], false, false, false),
          listen_dev(button12, "click", ctx[29], false, false, false),
          listen_dev(div10, "keydown", ctx[30], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 16384 && button0_disabled_value !== (button0_disabled_value = !ctx2[14])) {
        prop_dev(button0, "disabled", button0_disabled_value);
      }
      const dropdownbutton0_changes = {};
      if (dirty[0] & 256)
        dropdownbutton0_changes.items = ctx2[8];
      if (dirty[0] & 4 | dirty[2] & 2) {
        dropdownbutton0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdownbutton0.$set(dropdownbutton0_changes);
      const dropdownbutton1_changes = {};
      if (dirty[0] & 128)
        dropdownbutton1_changes.items = ctx2[7];
      if (dirty[0] & 2 | dirty[2] & 2) {
        dropdownbutton1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdownbutton1.$set(dropdownbutton1_changes);
      const dropdownbutton2_changes = {};
      if (dirty[0] & 64)
        dropdownbutton2_changes.items = ctx2[6];
      if (dirty[0] & 2 | dirty[2] & 2) {
        dropdownbutton2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdownbutton2.$set(dropdownbutton2_changes);
      if (!current || dirty[0] & 8 && button1_disabled_value !== (button1_disabled_value = !ctx2[3])) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
      if (!current || dirty[0] & 2 && button2_disabled_value !== (button2_disabled_value = !ctx2[1])) {
        prop_dev(button2, "disabled", button2_disabled_value);
      }
      if (!current || dirty[0] & 65536 && button3_disabled_value !== (button3_disabled_value = !ctx2[16])) {
        prop_dev(button3, "disabled", button3_disabled_value);
      }
      if (!current || dirty[0] & 32768 && button4_disabled_value !== (button4_disabled_value = !ctx2[15])) {
        prop_dev(button4, "disabled", button4_disabled_value);
      }
      if (!current || dirty[0] & 2 && button5_disabled_value !== (button5_disabled_value = !ctx2[1])) {
        prop_dev(button5, "disabled", button5_disabled_value);
      }
      if (!current || dirty[0] & 2 && button6_disabled_value !== (button6_disabled_value = !ctx2[1])) {
        prop_dev(button6, "disabled", button6_disabled_value);
      }
      if (!current || dirty[0] & 8192)
        set_data_dev(t19, ctx2[13]);
      if (!current || dirty[0] & 8192 && button7_title_value !== (button7_title_value = ctx2[13] + " structure")) {
        attr_dev(button7, "title", button7_title_value);
      }
      if (!current || dirty[0] & 4096 && button7_disabled_value !== (button7_disabled_value = !ctx2[12])) {
        prop_dev(button7, "disabled", button7_disabled_value);
      }
      if (!current || dirty[0] & 8192 && button8_title_value !== (button8_title_value = ctx2[13] + " object")) {
        attr_dev(button8, "title", button8_title_value);
      }
      if (!current || dirty[0] & 2048 && button8_disabled_value !== (button8_disabled_value = !ctx2[11])) {
        prop_dev(button8, "disabled", button8_disabled_value);
      }
      if (!current || dirty[0] & 8192 && button9_title_value !== (button9_title_value = ctx2[13] + " array")) {
        attr_dev(button9, "title", button9_title_value);
      }
      if (!current || dirty[0] & 1024 && button9_disabled_value !== (button9_disabled_value = !ctx2[10])) {
        prop_dev(button9, "disabled", button9_disabled_value);
      }
      if (!current || dirty[0] & 8192 && button10_title_value !== (button10_title_value = ctx2[13] + " value")) {
        attr_dev(button10, "title", button10_title_value);
      }
      if (!current || dirty[0] & 512 && button10_disabled_value !== (button10_disabled_value = !ctx2[9])) {
        prop_dev(button10, "disabled", button10_disabled_value);
      }
      if (!current || dirty[0] & 18 && button11_disabled_value !== (button11_disabled_value = !ctx2[1] || ctx2[4])) {
        prop_dev(button11, "disabled", button11_disabled_value);
      }
      if (!current || dirty[0] & 18 && button12_disabled_value !== (button12_disabled_value = !ctx2[1] || ctx2[4])) {
        prop_dev(button12, "disabled", button12_disabled_value);
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div10, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(dropdownbutton0.$$.fragment, local);
      transition_in(dropdownbutton1.$$.fragment, local);
      transition_in(dropdownbutton2.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      transition_in(icon3.$$.fragment, local);
      transition_in(icon4.$$.fragment, local);
      transition_in(icon5.$$.fragment, local);
      transition_in(icon6.$$.fragment, local);
      transition_in(icon7.$$.fragment, local);
      transition_in(icon8.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(dropdownbutton0.$$.fragment, local);
      transition_out(dropdownbutton1.$$.fragment, local);
      transition_out(dropdownbutton2.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      transition_out(icon3.$$.fragment, local);
      transition_out(icon4.$$.fragment, local);
      transition_out(icon5.$$.fragment, local);
      transition_out(icon6.$$.fragment, local);
      transition_out(icon7.$$.fragment, local);
      transition_out(icon8.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div10);
      destroy_component(icon0);
      destroy_component(dropdownbutton0);
      destroy_component(dropdownbutton1);
      destroy_component(dropdownbutton2);
      destroy_component(icon1);
      destroy_component(icon2);
      destroy_component(icon3);
      destroy_component(icon4);
      destroy_component(icon5);
      destroy_component(icon6);
      destroy_component(icon7);
      destroy_component(icon8);
      if (if_block)
        if_block.d();
      ctx[59](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let selection;
  let hasJson;
  let hasSelection;
  let rootSelected;
  let focusValue;
  let hasSelectionContents;
  let canDuplicate;
  let canExtract;
  let canEditKey;
  let canEditValue;
  let convertMode;
  let insertOrConvertText;
  let canInsertOrConvertStructure;
  let canInsertOrConvertObject;
  let canInsertOrConvertArray;
  let canInsertOrConvertValue;
  let enforceString;
  let editValueDropdownItems;
  let cutDropdownItems;
  let copyDropdownItems;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenu", slots, []);
  let { json: json2 } = $$props;
  let { documentState } = $$props;
  let { parser } = $$props;
  let { showTip } = $$props;
  let { onCloseContextMenu } = $$props;
  let { onEditKey } = $$props;
  let { onEditValue } = $$props;
  let { onToggleEnforceString } = $$props;
  let { onCut } = $$props;
  let { onCopy } = $$props;
  let { onPaste } = $$props;
  let { onRemove } = $$props;
  let { onDuplicate } = $$props;
  let { onExtract } = $$props;
  let { onInsertBefore } = $$props;
  let { onInsert } = $$props;
  let { onConvert } = $$props;
  let { onInsertAfter } = $$props;
  let { onSort } = $$props;
  let { onTransform } = $$props;
  let refContextMenu;
  onMount(() => {
    setTimeout(() => {
      const firstEnabledButton = [...refContextMenu.querySelectorAll("button")].find((button) => !button.disabled);
      if (firstEnabledButton) {
        firstEnabledButton.focus();
      }
    });
  });
  function handleEditKey() {
    onCloseContextMenu();
    onEditKey();
  }
  function handleEditValue() {
    onCloseContextMenu();
    onEditValue();
  }
  function handleToggleEnforceString() {
    onCloseContextMenu();
    onToggleEnforceString();
  }
  function handleCut() {
    onCloseContextMenu();
    onCut(true);
  }
  function handleCutCompact() {
    onCloseContextMenu();
    onCut(false);
  }
  function handleCopy() {
    onCloseContextMenu();
    onCopy(true);
  }
  function handleCopyCompact() {
    onCloseContextMenu();
    onCopy(false);
  }
  function handlePaste() {
    onCloseContextMenu();
    onPaste();
  }
  function handleRemove() {
    onCloseContextMenu();
    onRemove();
  }
  function handleDuplicate() {
    onCloseContextMenu();
    onDuplicate();
  }
  function handleExtract() {
    onCloseContextMenu();
    onExtract();
  }
  function handleInsertOrConvert(type) {
    onCloseContextMenu();
    if (hasSelectionContents) {
      onConvert(type);
    } else {
      onInsert(type);
    }
  }
  function handleSort() {
    onCloseContextMenu();
    onSort();
  }
  function handleTransform() {
    onCloseContextMenu();
    onTransform();
  }
  function handleInsertBefore() {
    onCloseContextMenu();
    onInsertBefore();
  }
  function handleInsertAfter() {
    onCloseContextMenu();
    onInsertAfter();
  }
  function handleKeyDown(event) {
    const combo = keyComboFromEvent(event).replace(/^Command\+/, "Ctrl+");
    if (combo === "Up" || combo === "Down" || combo === "Left" || combo === "Right") {
      event.preventDefault();
      const buttons = Array.from(refContextMenu.querySelectorAll("button:not([disabled])"));
      const nearest = findNearestElement({
        allElements: buttons,
        currentElement: event.target,
        direction: combo,
        hasPrio: (element2) => {
          return element2.getAttribute("data-type") !== "jse-open-dropdown";
        }
      });
      if (nearest) {
        nearest.focus();
      }
    }
  }
  $$self.$$.on_mount.push(function() {
    if (json2 === void 0 && !("json" in $$props || $$self.$$.bound[$$self.$$.props["json"]])) {
      console.warn("<ContextMenu> was created without expected prop 'json'");
    }
    if (documentState === void 0 && !("documentState" in $$props || $$self.$$.bound[$$self.$$.props["documentState"]])) {
      console.warn("<ContextMenu> was created without expected prop 'documentState'");
    }
    if (parser === void 0 && !("parser" in $$props || $$self.$$.bound[$$self.$$.props["parser"]])) {
      console.warn("<ContextMenu> was created without expected prop 'parser'");
    }
    if (showTip === void 0 && !("showTip" in $$props || $$self.$$.bound[$$self.$$.props["showTip"]])) {
      console.warn("<ContextMenu> was created without expected prop 'showTip'");
    }
    if (onCloseContextMenu === void 0 && !("onCloseContextMenu" in $$props || $$self.$$.bound[$$self.$$.props["onCloseContextMenu"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onCloseContextMenu'");
    }
    if (onEditKey === void 0 && !("onEditKey" in $$props || $$self.$$.bound[$$self.$$.props["onEditKey"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onEditKey'");
    }
    if (onEditValue === void 0 && !("onEditValue" in $$props || $$self.$$.bound[$$self.$$.props["onEditValue"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onEditValue'");
    }
    if (onToggleEnforceString === void 0 && !("onToggleEnforceString" in $$props || $$self.$$.bound[$$self.$$.props["onToggleEnforceString"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onToggleEnforceString'");
    }
    if (onCut === void 0 && !("onCut" in $$props || $$self.$$.bound[$$self.$$.props["onCut"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onCut'");
    }
    if (onCopy === void 0 && !("onCopy" in $$props || $$self.$$.bound[$$self.$$.props["onCopy"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onCopy'");
    }
    if (onPaste === void 0 && !("onPaste" in $$props || $$self.$$.bound[$$self.$$.props["onPaste"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onPaste'");
    }
    if (onRemove === void 0 && !("onRemove" in $$props || $$self.$$.bound[$$self.$$.props["onRemove"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onRemove'");
    }
    if (onDuplicate === void 0 && !("onDuplicate" in $$props || $$self.$$.bound[$$self.$$.props["onDuplicate"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onDuplicate'");
    }
    if (onExtract === void 0 && !("onExtract" in $$props || $$self.$$.bound[$$self.$$.props["onExtract"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onExtract'");
    }
    if (onInsertBefore === void 0 && !("onInsertBefore" in $$props || $$self.$$.bound[$$self.$$.props["onInsertBefore"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onInsertBefore'");
    }
    if (onInsert === void 0 && !("onInsert" in $$props || $$self.$$.bound[$$self.$$.props["onInsert"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onInsert'");
    }
    if (onConvert === void 0 && !("onConvert" in $$props || $$self.$$.bound[$$self.$$.props["onConvert"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onConvert'");
    }
    if (onInsertAfter === void 0 && !("onInsertAfter" in $$props || $$self.$$.bound[$$self.$$.props["onInsertAfter"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onInsertAfter'");
    }
    if (onSort === void 0 && !("onSort" in $$props || $$self.$$.bound[$$self.$$.props["onSort"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onSort'");
    }
    if (onTransform === void 0 && !("onTransform" in $$props || $$self.$$.bound[$$self.$$.props["onTransform"]])) {
      console.warn("<ContextMenu> was created without expected prop 'onTransform'");
    }
  });
  const writable_props = [
    "json",
    "documentState",
    "parser",
    "showTip",
    "onCloseContextMenu",
    "onEditKey",
    "onEditValue",
    "onToggleEnforceString",
    "onCut",
    "onCopy",
    "onPaste",
    "onRemove",
    "onDuplicate",
    "onExtract",
    "onInsertBefore",
    "onInsert",
    "onConvert",
    "onInsertAfter",
    "onSort",
    "onTransform"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContextMenu> was created with unknown prop '${key}'`);
  });
  const click_handler = () => handleInsertOrConvert("structure");
  const click_handler_1 = () => handleInsertOrConvert("object");
  const click_handler_2 = () => handleInsertOrConvert("array");
  const click_handler_3 = () => handleInsertOrConvert("value");
  function div10_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refContextMenu = $$value;
      $$invalidate(5, refContextMenu);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(31, json2 = $$props2.json);
    if ("documentState" in $$props2)
      $$invalidate(32, documentState = $$props2.documentState);
    if ("parser" in $$props2)
      $$invalidate(33, parser = $$props2.parser);
    if ("showTip" in $$props2)
      $$invalidate(0, showTip = $$props2.showTip);
    if ("onCloseContextMenu" in $$props2)
      $$invalidate(34, onCloseContextMenu = $$props2.onCloseContextMenu);
    if ("onEditKey" in $$props2)
      $$invalidate(35, onEditKey = $$props2.onEditKey);
    if ("onEditValue" in $$props2)
      $$invalidate(36, onEditValue = $$props2.onEditValue);
    if ("onToggleEnforceString" in $$props2)
      $$invalidate(37, onToggleEnforceString = $$props2.onToggleEnforceString);
    if ("onCut" in $$props2)
      $$invalidate(38, onCut = $$props2.onCut);
    if ("onCopy" in $$props2)
      $$invalidate(39, onCopy = $$props2.onCopy);
    if ("onPaste" in $$props2)
      $$invalidate(40, onPaste = $$props2.onPaste);
    if ("onRemove" in $$props2)
      $$invalidate(41, onRemove = $$props2.onRemove);
    if ("onDuplicate" in $$props2)
      $$invalidate(42, onDuplicate = $$props2.onDuplicate);
    if ("onExtract" in $$props2)
      $$invalidate(43, onExtract = $$props2.onExtract);
    if ("onInsertBefore" in $$props2)
      $$invalidate(44, onInsertBefore = $$props2.onInsertBefore);
    if ("onInsert" in $$props2)
      $$invalidate(45, onInsert = $$props2.onInsert);
    if ("onConvert" in $$props2)
      $$invalidate(46, onConvert = $$props2.onConvert);
    if ("onInsertAfter" in $$props2)
      $$invalidate(47, onInsertAfter = $$props2.onInsertAfter);
    if ("onSort" in $$props2)
      $$invalidate(48, onSort = $$props2.onSort);
    if ("onTransform" in $$props2)
      $$invalidate(49, onTransform = $$props2.onTransform);
  };
  $$self.$capture_state = () => ({
    faCaretSquareDown,
    faCaretSquareUp,
    faClone,
    faCopy,
    faCropAlt,
    faCut,
    faFilter,
    faPaste,
    faPen,
    faSortAmountDownAlt,
    faTimes,
    compileJSONPointer,
    getIn,
    initial: initial_default,
    isEmpty: isEmpty_default,
    onMount,
    Icon: Icon_default,
    DropdownButton: DropdownButton_default,
    canConvert,
    singleItemSelected,
    keyComboFromEvent,
    isObject,
    isObjectOrArray,
    faCheckSquare,
    faLightbulb,
    faSquare,
    findNearestElement,
    isKeySelection,
    isMultiSelection,
    isValueSelection,
    getEnforceString,
    json: json2,
    documentState,
    parser,
    showTip,
    onCloseContextMenu,
    onEditKey,
    onEditValue,
    onToggleEnforceString,
    onCut,
    onCopy,
    onPaste,
    onRemove,
    onDuplicate,
    onExtract,
    onInsertBefore,
    onInsert,
    onConvert,
    onInsertAfter,
    onSort,
    onTransform,
    refContextMenu,
    handleEditKey,
    handleEditValue,
    handleToggleEnforceString,
    handleCut,
    handleCutCompact,
    handleCopy,
    handleCopyCompact,
    handlePaste,
    handleRemove,
    handleDuplicate,
    handleExtract,
    handleInsertOrConvert,
    handleSort,
    handleTransform,
    handleInsertBefore,
    handleInsertAfter,
    handleKeyDown,
    hasSelectionContents,
    copyDropdownItems,
    cutDropdownItems,
    canEditValue,
    enforceString,
    editValueDropdownItems,
    selection,
    focusValue,
    hasSelection,
    convertMode,
    canInsertOrConvertValue,
    canInsertOrConvertArray,
    canInsertOrConvertObject,
    canInsertOrConvertStructure,
    insertOrConvertText,
    hasJson,
    rootSelected,
    canEditKey,
    canExtract,
    canDuplicate
  });
  $$self.$inject_state = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(31, json2 = $$props2.json);
    if ("documentState" in $$props2)
      $$invalidate(32, documentState = $$props2.documentState);
    if ("parser" in $$props2)
      $$invalidate(33, parser = $$props2.parser);
    if ("showTip" in $$props2)
      $$invalidate(0, showTip = $$props2.showTip);
    if ("onCloseContextMenu" in $$props2)
      $$invalidate(34, onCloseContextMenu = $$props2.onCloseContextMenu);
    if ("onEditKey" in $$props2)
      $$invalidate(35, onEditKey = $$props2.onEditKey);
    if ("onEditValue" in $$props2)
      $$invalidate(36, onEditValue = $$props2.onEditValue);
    if ("onToggleEnforceString" in $$props2)
      $$invalidate(37, onToggleEnforceString = $$props2.onToggleEnforceString);
    if ("onCut" in $$props2)
      $$invalidate(38, onCut = $$props2.onCut);
    if ("onCopy" in $$props2)
      $$invalidate(39, onCopy = $$props2.onCopy);
    if ("onPaste" in $$props2)
      $$invalidate(40, onPaste = $$props2.onPaste);
    if ("onRemove" in $$props2)
      $$invalidate(41, onRemove = $$props2.onRemove);
    if ("onDuplicate" in $$props2)
      $$invalidate(42, onDuplicate = $$props2.onDuplicate);
    if ("onExtract" in $$props2)
      $$invalidate(43, onExtract = $$props2.onExtract);
    if ("onInsertBefore" in $$props2)
      $$invalidate(44, onInsertBefore = $$props2.onInsertBefore);
    if ("onInsert" in $$props2)
      $$invalidate(45, onInsert = $$props2.onInsert);
    if ("onConvert" in $$props2)
      $$invalidate(46, onConvert = $$props2.onConvert);
    if ("onInsertAfter" in $$props2)
      $$invalidate(47, onInsertAfter = $$props2.onInsertAfter);
    if ("onSort" in $$props2)
      $$invalidate(48, onSort = $$props2.onSort);
    if ("onTransform" in $$props2)
      $$invalidate(49, onTransform = $$props2.onTransform);
    if ("refContextMenu" in $$props2)
      $$invalidate(5, refContextMenu = $$props2.refContextMenu);
    if ("hasSelectionContents" in $$props2)
      $$invalidate(1, hasSelectionContents = $$props2.hasSelectionContents);
    if ("copyDropdownItems" in $$props2)
      $$invalidate(6, copyDropdownItems = $$props2.copyDropdownItems);
    if ("cutDropdownItems" in $$props2)
      $$invalidate(7, cutDropdownItems = $$props2.cutDropdownItems);
    if ("canEditValue" in $$props2)
      $$invalidate(2, canEditValue = $$props2.canEditValue);
    if ("enforceString" in $$props2)
      $$invalidate(50, enforceString = $$props2.enforceString);
    if ("editValueDropdownItems" in $$props2)
      $$invalidate(8, editValueDropdownItems = $$props2.editValueDropdownItems);
    if ("selection" in $$props2)
      $$invalidate(51, selection = $$props2.selection);
    if ("focusValue" in $$props2)
      $$invalidate(52, focusValue = $$props2.focusValue);
    if ("hasSelection" in $$props2)
      $$invalidate(3, hasSelection = $$props2.hasSelection);
    if ("convertMode" in $$props2)
      $$invalidate(53, convertMode = $$props2.convertMode);
    if ("canInsertOrConvertValue" in $$props2)
      $$invalidate(9, canInsertOrConvertValue = $$props2.canInsertOrConvertValue);
    if ("canInsertOrConvertArray" in $$props2)
      $$invalidate(10, canInsertOrConvertArray = $$props2.canInsertOrConvertArray);
    if ("canInsertOrConvertObject" in $$props2)
      $$invalidate(11, canInsertOrConvertObject = $$props2.canInsertOrConvertObject);
    if ("canInsertOrConvertStructure" in $$props2)
      $$invalidate(12, canInsertOrConvertStructure = $$props2.canInsertOrConvertStructure);
    if ("insertOrConvertText" in $$props2)
      $$invalidate(13, insertOrConvertText = $$props2.insertOrConvertText);
    if ("hasJson" in $$props2)
      $$invalidate(54, hasJson = $$props2.hasJson);
    if ("rootSelected" in $$props2)
      $$invalidate(4, rootSelected = $$props2.rootSelected);
    if ("canEditKey" in $$props2)
      $$invalidate(14, canEditKey = $$props2.canEditKey);
    if ("canExtract" in $$props2)
      $$invalidate(15, canExtract = $$props2.canExtract);
    if ("canDuplicate" in $$props2)
      $$invalidate(16, canDuplicate = $$props2.canDuplicate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 2) {
      $:
        $$invalidate(51, selection = documentState.selection);
    }
    if ($$self.$$.dirty[1] & 1) {
      $:
        $$invalidate(54, hasJson = json2 !== void 0);
    }
    if ($$self.$$.dirty[1] & 1048576) {
      $:
        $$invalidate(3, hasSelection = selection != null);
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 1048576) {
      $:
        $$invalidate(4, rootSelected = hasSelection && isEmpty_default(selection.focusPath));
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 1048577) {
      $:
        $$invalidate(52, focusValue = hasSelection ? getIn(json2, selection.focusPath) : void 0);
    }
    if ($$self.$$.dirty[1] & 9437184) {
      $:
        $$invalidate(1, hasSelectionContents = hasJson && (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection)));
    }
    if ($$self.$$.dirty[0] & 18 | $$self.$$.dirty[1] & 8388608) {
      $:
        $$invalidate(16, canDuplicate = hasJson && hasSelectionContents && !rootSelected);
    }
    if ($$self.$$.dirty[0] & 16 | $$self.$$.dirty[1] & 9437184) {
      $:
        $$invalidate(15, canExtract = hasJson && selection != null && (isMultiSelection(selection) || isValueSelection(selection)) && !rootSelected);
    }
    if ($$self.$$.dirty[0] & 16 | $$self.$$.dirty[1] & 9437185) {
      $:
        $$invalidate(14, canEditKey = hasJson && selection != null && singleItemSelected(selection) && !rootSelected && !Array.isArray(getIn(json2, initial_default(selection.focusPath))));
    }
    if ($$self.$$.dirty[1] & 11534336) {
      $:
        $$invalidate(2, canEditValue = hasJson && selection != null && singleItemSelected(selection) && !isObjectOrArray(focusValue));
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(53, convertMode = hasSelectionContents);
    }
    if ($$self.$$.dirty[1] & 4194304) {
      $:
        $$invalidate(13, insertOrConvertText = convertMode ? "Convert to" : "Insert");
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 4194304) {
      $:
        $$invalidate(12, canInsertOrConvertStructure = convertMode ? false : hasSelection);
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 7340032) {
      $:
        $$invalidate(11, canInsertOrConvertObject = convertMode ? canConvert(selection) && !isObject(focusValue) : hasSelection);
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 7340032) {
      $:
        $$invalidate(10, canInsertOrConvertArray = convertMode ? canConvert(selection) && !Array.isArray(focusValue) : hasSelection);
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 7340032) {
      $:
        $$invalidate(9, canInsertOrConvertValue = convertMode ? canConvert(selection) && isObjectOrArray(focusValue) : hasSelection);
    }
    if ($$self.$$.dirty[1] & 3145734) {
      $:
        $$invalidate(50, enforceString = selection != null ? getEnforceString(focusValue, documentState.enforceStringMap, compileJSONPointer(selection.focusPath), parser) : false);
    }
    if ($$self.$$.dirty[0] & 4 | $$self.$$.dirty[1] & 524288) {
      $:
        $$invalidate(8, editValueDropdownItems = [
          {
            icon: faPen,
            text: "Edit value",
            title: "Edit the value (Double-click on the value)",
            onClick: handleEditValue,
            disabled: !canEditValue
          },
          {
            icon: enforceString ? faCheckSquare : faSquare,
            text: "Enforce string",
            title: "Enforce keeping the value as string when it contains a numeric value",
            onClick: handleToggleEnforceString,
            disabled: !canEditValue
          }
        ]);
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(7, cutDropdownItems = [
          {
            icon: faCut,
            text: "Cut formatted",
            title: "Cut selected contents, formatted with indentation (Ctrl+X)",
            onClick: handleCut,
            disabled: !hasSelectionContents
          },
          {
            icon: faCut,
            text: "Cut compacted",
            title: "Cut selected contents, without indentation (Ctrl+Shift+X)",
            onClick: handleCutCompact,
            disabled: !hasSelectionContents
          }
        ]);
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(6, copyDropdownItems = [
          {
            icon: faCopy,
            text: "Copy formatted",
            title: "Copy selected contents, formatted with indentation (Ctrl+C)",
            onClick: handleCopy,
            disabled: !hasSelectionContents
          },
          {
            icon: faCopy,
            text: "Copy compacted",
            title: "Copy selected contents, without indentation (Ctrl+Shift+C)",
            onClick: handleCopyCompact,
            disabled: !hasSelectionContents
          }
        ]);
    }
  };
  return [
    showTip,
    hasSelectionContents,
    canEditValue,
    hasSelection,
    rootSelected,
    refContextMenu,
    copyDropdownItems,
    cutDropdownItems,
    editValueDropdownItems,
    canInsertOrConvertValue,
    canInsertOrConvertArray,
    canInsertOrConvertObject,
    canInsertOrConvertStructure,
    insertOrConvertText,
    canEditKey,
    canExtract,
    canDuplicate,
    handleEditKey,
    handleEditValue,
    handleCut,
    handleCopy,
    handlePaste,
    handleRemove,
    handleDuplicate,
    handleExtract,
    handleInsertOrConvert,
    handleSort,
    handleTransform,
    handleInsertBefore,
    handleInsertAfter,
    handleKeyDown,
    json2,
    documentState,
    parser,
    onCloseContextMenu,
    onEditKey,
    onEditValue,
    onToggleEnforceString,
    onCut,
    onCopy,
    onPaste,
    onRemove,
    onDuplicate,
    onExtract,
    onInsertBefore,
    onInsert,
    onConvert,
    onInsertAfter,
    onSort,
    onTransform,
    enforceString,
    selection,
    focusValue,
    convertMode,
    hasJson,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    div10_binding
  ];
}
var ContextMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance20,
      create_fragment20,
      not_equal,
      {
        json: 31,
        documentState: 32,
        parser: 33,
        showTip: 0,
        onCloseContextMenu: 34,
        onEditKey: 35,
        onEditValue: 36,
        onToggleEnforceString: 37,
        onCut: 38,
        onCopy: 39,
        onPaste: 40,
        onRemove: 41,
        onDuplicate: 42,
        onExtract: 43,
        onInsertBefore: 44,
        onInsert: 45,
        onConvert: 46,
        onInsertAfter: 47,
        onSort: 48,
        onTransform: 49
      },
      add_css14,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenu",
      options,
      id: create_fragment20.name
    });
  }
  get json() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set json(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get documentState() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set documentState(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showTip() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showTip(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCloseContextMenu() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCloseContextMenu(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEditKey() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEditKey(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEditValue() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEditValue(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onToggleEnforceString() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onToggleEnforceString(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCut() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCut(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCopy() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCopy(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPaste() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPaste(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRemove() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRemove(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDuplicate() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDuplicate(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExtract() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExtract(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onInsertBefore() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onInsertBefore(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onInsert() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onInsert(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onConvert() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onConvert(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onInsertAfter() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onInsertAfter(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSort() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSort(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTransform() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTransform(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenu_default = ContextMenu;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/JSONNode.svelte
var import_classnames3 = __toESM(require_classnames(), 1);

// ../node_modules/svelte-jsoneditor/components/modes/treemode/CollapsedItems.svelte
var file18 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/CollapsedItems.svelte";
function add_css15(target) {
  append_styles(target, "svelte-909nvs", "div.jse-collapsed-items.svelte-909nvs.svelte-909nvs{font-family:var(--jse-font-family);font-size:var(--jse-font-size);color:var(--jse-collapsed-items-link-color);padding:calc(0.5 * var(--jse-padding));border:8px solid transparent;border-width:8px 0;background-color:transparent;background-image:linear-gradient(var(--jse-collapsed-items-background-color), var(--jse-collapsed-items-background-color)), linear-gradient(to bottom right, transparent 50.5%, var(--jse-collapsed-items-background-color) 50.5%), linear-gradient(to bottom left, transparent 50.5%, var(--jse-collapsed-items-background-color) 50.5%), linear-gradient(to top right, transparent 50.5%, var(--jse-collapsed-items-background-color) 50.5%), linear-gradient(to top left, transparent 50.5%, var(--jse-collapsed-items-background-color) 50.5%);background-repeat:repeat, repeat-x, repeat-x, repeat-x, repeat-x;background-position:0 0, 8px 0, 8px 0, 8px 100%, 8px 100%;background-size:auto auto, 16px 16px, 16px 16px, 16px 16px, 16px 16px;background-clip:padding-box, border-box, border-box, border-box, border-box;background-origin:padding-box, border-box, border-box, border-box, border-box;display:flex}div.jse-collapsed-items.svelte-909nvs div.jse-text.svelte-909nvs,div.jse-collapsed-items.svelte-909nvs button.jse-expand-items.svelte-909nvs{margin:0 calc(0.5 * var(--jse-padding))}div.jse-collapsed-items.svelte-909nvs div.jse-text.svelte-909nvs{display:inline}div.jse-collapsed-items.svelte-909nvs button.jse-expand-items.svelte-909nvs{font-family:inherit;font-size:inherit;color:var(--jse-collapsed-items-link-color);background:none;border:none;padding:0;text-decoration:underline;cursor:pointer}div.jse-collapsed-items.svelte-909nvs button.jse-expand-items.svelte-909nvs:hover,div.jse-collapsed-items.svelte-909nvs button.jse-expand-items.svelte-909nvs:focus{color:var(--jse-collapsed-items-link-color-highlight)}.svelte-909nvs.svelte-909nvs{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sbGFwc2VkSXRlbXMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWlEa0MsR0FBQSxvQkFBQSw0QkFBQSxDQUFBLHUwREFtQ2pDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbGxhcHNlZEl0ZW1zLnN2ZWx0ZSJdfQ== */");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block7(ctx) {
  let button;
  let t0;
  let t1_value = ctx[13].start + "";
  let t1;
  let t2;
  let t3_value = ctx[13].end + "";
  let t3;
  let t4;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[12](ctx[13]);
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text("show ");
      t1 = text(t1_value);
      t2 = text("-");
      t3 = text(t3_value);
      t4 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, "show ");
      t1 = claim_text(button_nodes, t1_value);
      t2 = claim_text(button_nodes, "-");
      t3 = claim_text(button_nodes, t3_value);
      t4 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-expand-items svelte-909nvs");
      add_location(button, file18, 38, 53, 1446);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, t3);
      append_hydration_dev(button, t4);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && t1_value !== (t1_value = ctx[13].start + ""))
        set_data_dev(t1, t1_value);
      if (dirty & 16 && t3_value !== (t3_value = ctx[13].end + ""))
        set_data_dev(t3, t3_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(39:4) {#each expandItemsSections as expandItemsSection}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let div2_style_value;
  let mounted;
  let dispose;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = text("Items ");
      t1 = text(ctx[3]);
      t2 = text("-");
      t3 = text(ctx[2]);
      t4 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "Items ");
      t1 = claim_text(div0_nodes, ctx[3]);
      t2 = claim_text(div0_nodes, "-");
      t3 = claim_text(div0_nodes, ctx[2]);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-text svelte-909nvs");
      add_location(div0, file18, 37, 4, 1335);
      attr_dev(div1, "class", "svelte-909nvs");
      add_location(div1, file18, 36, 2, 1325);
      attr_dev(div2, "class", "jse-collapsed-items svelte-909nvs");
      attr_dev(div2, "style", div2_style_value = getIndentationStyle(ctx[0].length + 2));
      toggle_class(div2, "jse-selected", ctx[5]);
      add_location(div2, file18, 30, 0, 1174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div1, t4);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      if (!mounted) {
        dispose = listen_dev(div2, "mousemove", handleMouseMove, false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 8)
        set_data_dev(t1, ctx2[3]);
      if (dirty & 4)
        set_data_dev(t3, ctx2[2]);
      if (dirty & 19) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1 && div2_style_value !== (div2_style_value = getIndentationStyle(ctx2[0].length + 2))) {
        attr_dev(div2, "style", div2_style_value);
      }
      if (dirty & 32) {
        toggle_class(div2, "jse-selected", ctx2[5]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getIndentationStyle(level) {
  return `margin-left: calc(${level} * var(--jse-indent-size))`;
}
function handleMouseMove(event) {
  event.stopPropagation();
}
function instance21($$self, $$props, $$invalidate) {
  let visibleSection;
  let startIndex;
  let endIndex;
  let selected;
  let expandItemsSections;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CollapsedItems", slots, []);
  let { visibleSections } = $$props;
  let { sectionIndex } = $$props;
  let { total } = $$props;
  let { path } = $$props;
  let { pointer } = $$props;
  let { selection } = $$props;
  let { onExpandSection } = $$props;
  $$self.$$.on_mount.push(function() {
    if (visibleSections === void 0 && !("visibleSections" in $$props || $$self.$$.bound[$$self.$$.props["visibleSections"]])) {
      console.warn("<CollapsedItems> was created without expected prop 'visibleSections'");
    }
    if (sectionIndex === void 0 && !("sectionIndex" in $$props || $$self.$$.bound[$$self.$$.props["sectionIndex"]])) {
      console.warn("<CollapsedItems> was created without expected prop 'sectionIndex'");
    }
    if (total === void 0 && !("total" in $$props || $$self.$$.bound[$$self.$$.props["total"]])) {
      console.warn("<CollapsedItems> was created without expected prop 'total'");
    }
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<CollapsedItems> was created without expected prop 'path'");
    }
    if (pointer === void 0 && !("pointer" in $$props || $$self.$$.bound[$$self.$$.props["pointer"]])) {
      console.warn("<CollapsedItems> was created without expected prop 'pointer'");
    }
    if (selection === void 0 && !("selection" in $$props || $$self.$$.bound[$$self.$$.props["selection"]])) {
      console.warn("<CollapsedItems> was created without expected prop 'selection'");
    }
    if (onExpandSection === void 0 && !("onExpandSection" in $$props || $$self.$$.bound[$$self.$$.props["onExpandSection"]])) {
      console.warn("<CollapsedItems> was created without expected prop 'onExpandSection'");
    }
  });
  const writable_props = [
    "visibleSections",
    "sectionIndex",
    "total",
    "path",
    "pointer",
    "selection",
    "onExpandSection"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CollapsedItems> was created with unknown prop '${key}'`);
  });
  const click_handler = (expandItemsSection) => onExpandSection(path, expandItemsSection);
  $$self.$$set = ($$props2) => {
    if ("visibleSections" in $$props2)
      $$invalidate(6, visibleSections = $$props2.visibleSections);
    if ("sectionIndex" in $$props2)
      $$invalidate(7, sectionIndex = $$props2.sectionIndex);
    if ("total" in $$props2)
      $$invalidate(8, total = $$props2.total);
    if ("path" in $$props2)
      $$invalidate(0, path = $$props2.path);
    if ("pointer" in $$props2)
      $$invalidate(9, pointer = $$props2.pointer);
    if ("selection" in $$props2)
      $$invalidate(10, selection = $$props2.selection);
    if ("onExpandSection" in $$props2)
      $$invalidate(1, onExpandSection = $$props2.onExpandSection);
  };
  $$self.$capture_state = () => ({
    getExpandItemsSections,
    appendToJSONPointer,
    isMultiSelection,
    visibleSections,
    sectionIndex,
    total,
    path,
    pointer,
    selection,
    onExpandSection,
    getIndentationStyle,
    handleMouseMove,
    endIndex,
    startIndex,
    expandItemsSections,
    selected,
    visibleSection
  });
  $$self.$inject_state = ($$props2) => {
    if ("visibleSections" in $$props2)
      $$invalidate(6, visibleSections = $$props2.visibleSections);
    if ("sectionIndex" in $$props2)
      $$invalidate(7, sectionIndex = $$props2.sectionIndex);
    if ("total" in $$props2)
      $$invalidate(8, total = $$props2.total);
    if ("path" in $$props2)
      $$invalidate(0, path = $$props2.path);
    if ("pointer" in $$props2)
      $$invalidate(9, pointer = $$props2.pointer);
    if ("selection" in $$props2)
      $$invalidate(10, selection = $$props2.selection);
    if ("onExpandSection" in $$props2)
      $$invalidate(1, onExpandSection = $$props2.onExpandSection);
    if ("endIndex" in $$props2)
      $$invalidate(2, endIndex = $$props2.endIndex);
    if ("startIndex" in $$props2)
      $$invalidate(3, startIndex = $$props2.startIndex);
    if ("expandItemsSections" in $$props2)
      $$invalidate(4, expandItemsSections = $$props2.expandItemsSections);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("visibleSection" in $$props2)
      $$invalidate(11, visibleSection = $$props2.visibleSection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 192) {
      $:
        $$invalidate(11, visibleSection = visibleSections[sectionIndex]);
    }
    if ($$self.$$.dirty & 2048) {
      $:
        $$invalidate(3, startIndex = visibleSection.end);
    }
    if ($$self.$$.dirty & 448) {
      $:
        $$invalidate(2, endIndex = visibleSections[sectionIndex + 1] ? visibleSections[sectionIndex + 1].start : total);
    }
    if ($$self.$$.dirty & 1544) {
      $:
        $$invalidate(5, selected = isMultiSelection(selection) ? selection.pointersMap[appendToJSONPointer(pointer, startIndex)] === true : false);
    }
    if ($$self.$$.dirty & 12) {
      $:
        $$invalidate(4, expandItemsSections = getExpandItemsSections(startIndex, endIndex));
    }
  };
  return [
    path,
    onExpandSection,
    endIndex,
    startIndex,
    expandItemsSections,
    selected,
    visibleSections,
    sectionIndex,
    total,
    pointer,
    selection,
    visibleSection,
    click_handler
  ];
}
var CollapsedItems = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance21,
      create_fragment21,
      not_equal,
      {
        visibleSections: 6,
        sectionIndex: 7,
        total: 8,
        path: 0,
        pointer: 9,
        selection: 10,
        onExpandSection: 1
      },
      add_css15
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CollapsedItems",
      options,
      id: create_fragment21.name
    });
  }
  get visibleSections() {
    throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visibleSections(value) {
    throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionIndex() {
    throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionIndex(value) {
    throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get total() {
    throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set total(value) {
    throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointer() {
    throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointer(value) {
    throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExpandSection() {
    throw new Error("<CollapsedItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExpandSection(value) {
    throw new Error("<CollapsedItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CollapsedItems_default = CollapsedItems;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/contextmenu/ContextMenuButton.svelte
var file19 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/contextmenu/ContextMenuButton.svelte";
function add_css16(target) {
  append_styles(target, "svelte-9uj0og", ".jse-context-menu-button.svelte-9uj0og{position:absolute;top:calc(-0.5 * var(--jse-context-menu-button-size));right:calc(-0.5 * var(--jse-context-menu-button-size));width:var(--jse-context-menu-button-size);height:var(--jse-context-menu-button-size);padding:0;margin:0;z-index:2;cursor:pointer;background:transparent;border-radius:2px;background:var(--jse-context-menu-button-background);color:var(--jse-context-menu-button-color);border:none;box-shadow:var(--jse-controls-box-shadow)}.jse-context-menu-button.svelte-9uj0og:hover{background:var(--jse-context-menu-button-background-highlight)}.svelte-9uj0og{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGV4dE1lbnVCdXR0b24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFDcUMsd0JBQUEsY0FBQSxDQUFBLDBqQkFtQnBDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbnRleHRNZW51QnV0dG9uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment22(ctx) {
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { data: faCaretDown },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-context-menu-button svelte-9uj0og");
      attr_dev(button, "title", CONTEXT_MENU_EXPLANATION);
      toggle_class(button, "jse-selected", ctx[0]);
      add_location(button, file19, 27, 0, 810);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[1], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1) {
        toggle_class(button, "jse-selected", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuButton", slots, []);
  let { selected } = $$props;
  let { onContextMenu } = $$props;
  function handleClick(event) {
    let buttonElem = event.target;
    while (buttonElem && buttonElem.nodeName !== "BUTTON") {
      buttonElem = buttonElem.parentNode;
    }
    if (buttonElem) {
      onContextMenu({
        anchor: buttonElem,
        left: 0,
        top: 0,
        width: CONTEXT_MENU_WIDTH,
        height: CONTEXT_MENU_HEIGHT,
        offsetTop: 2,
        offsetLeft: 0,
        showTip: true
      });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (selected === void 0 && !("selected" in $$props || $$self.$$.bound[$$self.$$.props["selected"]])) {
      console.warn("<ContextMenuButton> was created without expected prop 'selected'");
    }
    if (onContextMenu === void 0 && !("onContextMenu" in $$props || $$self.$$.bound[$$self.$$.props["onContextMenu"]])) {
      console.warn("<ContextMenuButton> was created without expected prop 'onContextMenu'");
    }
  });
  const writable_props = ["selected", "onContextMenu"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContextMenuButton> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("onContextMenu" in $$props2)
      $$invalidate(2, onContextMenu = $$props2.onContextMenu);
  };
  $$self.$capture_state = () => ({
    faCaretDown,
    Icon: Icon_default,
    CONTEXT_MENU_EXPLANATION,
    CONTEXT_MENU_HEIGHT,
    CONTEXT_MENU_WIDTH,
    selected,
    onContextMenu,
    handleClick
  });
  $$self.$inject_state = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("onContextMenu" in $$props2)
      $$invalidate(2, onContextMenu = $$props2.onContextMenu);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [selected, handleClick, onContextMenu];
}
var ContextMenuButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, not_equal, { selected: 0, onContextMenu: 2 }, add_css16);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuButton",
      options,
      id: create_fragment22.name
    });
  }
  get selected() {
    throw new Error("<ContextMenuButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ContextMenuButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onContextMenu() {
    throw new Error("<ContextMenuButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onContextMenu(value) {
    throw new Error("<ContextMenuButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuButton_default = ContextMenuButton;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/JSONKey.svelte
var import_classnames2 = __toESM(require_classnames(), 1);

// ../node_modules/svelte-jsoneditor/components/modes/treemode/highlight/SearchResultHighlighter.svelte
var file20 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/highlight/SearchResultHighlighter.svelte";
function add_css17(target) {
  append_styles(target, "svelte-1i5p1ro", ".jse-highlight.svelte-1i5p1ro{background-color:var(--jse-search-match-color);outline:var(--jse-search-match-outline)}.jse-highlight.jse-active.svelte-1i5p1ro{background-color:var(--jse-search-match-active-color);outline:var(--jse-search-match-active-outline)}.svelte-1i5p1ro{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoUmVzdWx0SGlnaGxpZ2h0ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWUyQyxjQUFBLGVBQUEsQ0FBQSxzUEFPMUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VhcmNoUmVzdWx0SGlnaGxpZ2h0ZXIuc3ZlbHRlIl19 */");
}
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_else_block6(ctx) {
  let span;
  let t_value = addNewLineSuffix(ctx[3].text) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "jse-highlight svelte-1i5p1ro");
      toggle_class(span, "jse-active", ctx[3].active);
      add_location(span, file20, 11, 4, 328);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = addNewLineSuffix(ctx2[3].text) + ""))
        set_data_dev(t, t_value);
      if (dirty & 1) {
        toggle_class(span, "jse-active", ctx2[3].active);
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(11:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let t_value = ctx[3].text + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[3].text + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(9:2) {#if part.type === 'normal'}",
    ctx
  });
  return block;
}
function create_each_block8(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3].type === "normal")
      return create_if_block12;
    return create_else_block6;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy2(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block8.name,
    type: "each",
    source: "(8:0) {#each parts as part}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let each_1_anchor;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let parts;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SearchResultHighlighter", slots, []);
  let { text: text2 } = $$props;
  let { searchResultItems } = $$props;
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<SearchResultHighlighter> was created without expected prop 'text'");
    }
    if (searchResultItems === void 0 && !("searchResultItems" in $$props || $$self.$$.bound[$$self.$$.props["searchResultItems"]])) {
      console.warn("<SearchResultHighlighter> was created without expected prop 'searchResultItems'");
    }
  });
  const writable_props = ["text", "searchResultItems"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SearchResultHighlighter> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("searchResultItems" in $$props2)
      $$invalidate(2, searchResultItems = $$props2.searchResultItems);
  };
  $$self.$capture_state = () => ({
    splitValue,
    addNewLineSuffix,
    text: text2,
    searchResultItems,
    parts
  });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("searchResultItems" in $$props2)
      $$invalidate(2, searchResultItems = $$props2.searchResultItems);
    if ("parts" in $$props2)
      $$invalidate(0, parts = $$props2.parts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      $:
        $$invalidate(0, parts = splitValue(String(text2), searchResultItems));
    }
  };
  return [parts, text2, searchResultItems];
}
var SearchResultHighlighter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { text: 1, searchResultItems: 2 }, add_css17);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SearchResultHighlighter",
      options,
      id: create_fragment23.name
    });
  }
  get text() {
    throw new Error("<SearchResultHighlighter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SearchResultHighlighter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchResultItems() {
    throw new Error("<SearchResultHighlighter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchResultItems(value) {
    throw new Error("<SearchResultHighlighter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SearchResultHighlighter_default = SearchResultHighlighter;

// ../node_modules/svelte-jsoneditor/components/controls/EditableDiv.svelte
var import_classnames = __toESM(require_classnames(), 1);
var file21 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/EditableDiv.svelte";
function add_css18(target) {
  append_styles(target, "svelte-1vfqt1y", ".jse-value.jse-string.svelte-1vfqt1y{color:var(--jse-value-color-string)}.jse-value.jse-object.svelte-1vfqt1y,.jse-value.jse-array.svelte-1vfqt1y{min-width:16px;color:var(--jse-delimiter-color)}.jse-value.jse-number.svelte-1vfqt1y{color:var(--jse-value-color-number)}.jse-value.jse-boolean.svelte-1vfqt1y{color:var(--jse-value-color-boolean)}.jse-value.jse-null.svelte-1vfqt1y{color:var(--jse-value-color-null)}.jse-value.jse-invalid.svelte-1vfqt1y{color:var(--jse-text-color)}.jse-value.jse-url.svelte-1vfqt1y{color:var(--jse-value-color-url);text-decoration:underline}div.jse-editable-div.svelte-1vfqt1y{min-width:2em;padding:0 5px;box-sizing:border-box;outline:none;border-radius:1px;vertical-align:top;word-break:normal;white-space:pre-wrap;overflow-wrap:anywhere}div.jse-editable-div.jse-short-text.svelte-1vfqt1y{overflow-wrap:normal}div.jse-editable-div[contenteditable=true].svelte-1vfqt1y{outline:var(--jse-edit-outline);background:inherit !important;position:relative;border-radius:0;z-index:3}div.jse-editable-div.jse-empty.svelte-1vfqt1y:not(:focus){outline:1px dotted var(--jse-tag-background);-moz-outline-radius:2px}div.jse-editable-div.jse-empty.svelte-1vfqt1y::after{pointer-events:none;color:var(--jse-tag-background)}.svelte-1vfqt1y{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdGFibGVEaXYuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTZHK0IsVUFBQSxXQUFBLGVBQUEsQ0FBQSxnc0NBb0Q5QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFZGl0YWJsZURpdi5zdmVsdGUiXX0= */");
}
function create_fragment24(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        contenteditable: true,
        spellcheck: true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty((0, import_classnames.default)("jse-editable-div", ctx[2], { "jse-short-text": ctx[0] })) + " svelte-1vfqt1y");
      attr_dev(div, "contenteditable", "true");
      attr_dev(div, "spellcheck", "false");
      add_location(div, file21, 98, 0, 3124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[13](div);
      if (!mounted) {
        dispose = [
          listen_dev(div, "input", ctx[3], false, false, false),
          listen_dev(div, "keydown", ctx[4], false, false, false),
          listen_dev(div, "paste", ctx[5], false, false, false),
          listen_dev(div, "blur", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 5 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames.default)("jse-editable-div", ctx2[2], { "jse-short-text": ctx2[0] })) + " svelte-1vfqt1y")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EditableDiv", slots, []);
  const debug5 = createDebug("jsoneditor:EditableDiv");
  let { value } = $$props;
  let { shortText = false } = $$props;
  let { onChange } = $$props;
  let { onCancel } = $$props;
  let { onFind } = $$props;
  let { onPaste = noop_default } = $$props;
  let { onValueClass = () => "" } = $$props;
  let domValue;
  let valueClass = onValueClass(value);
  let closed = false;
  onMount(() => {
    debug5("onMount", { value });
    setDomValue(value);
    setTimeout(() => setCursorToEnd(domValue));
  });
  onDestroy(() => {
    const newValue = getDomValue();
    debug5("onDestroy", { closed, value, newValue });
    if (!closed && newValue !== value) {
      onChange(newValue, UPDATE_SELECTION.NO);
    }
  });
  function getDomValue() {
    return removeNewLineSuffix(domValue.innerText);
  }
  function setDomValue(updatedValue) {
    $$invalidate(1, domValue.innerText = addNewLineSuffix(updatedValue), domValue);
  }
  function handleValueInput() {
    const newValue = getDomValue();
    if (newValue === "") {
      setDomValue("");
    }
    $$invalidate(2, valueClass = onValueClass(newValue));
  }
  function handleValueKeyDown(event) {
    event.stopPropagation();
    const combo = keyComboFromEvent(event).replace(/^Command\+/, "Ctrl+");
    if (combo === "Escape") {
      closed = true;
      onCancel();
    }
    if (combo === "Enter" || combo === "Tab") {
      closed = true;
      const newValue = getDomValue();
      onChange(newValue, UPDATE_SELECTION.NEXT_INSIDE);
    }
    if (combo === "Ctrl+F") {
      event.preventDefault();
      onFind(false);
    }
    if (combo === "Ctrl+H") {
      event.preventDefault();
      onFind(true);
    }
  }
  function handleValuePaste(event) {
    if (!onPaste) {
      return;
    }
    const clipboardText = event.clipboardData.getData("text/plain");
    onPaste(clipboardText);
  }
  function handleBlur() {
    const hasFocus = document.hasFocus();
    const newValue = getDomValue();
    debug5("handleBlur", { hasFocus, closed, value, newValue });
    if (document.hasFocus() && !closed) {
      closed = true;
      if (newValue !== value) {
        onChange(newValue, UPDATE_SELECTION.SELF);
      } else {
        onCancel();
      }
    }
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<EditableDiv> was created without expected prop 'value'");
    }
    if (onChange === void 0 && !("onChange" in $$props || $$self.$$.bound[$$self.$$.props["onChange"]])) {
      console.warn("<EditableDiv> was created without expected prop 'onChange'");
    }
    if (onCancel === void 0 && !("onCancel" in $$props || $$self.$$.bound[$$self.$$.props["onCancel"]])) {
      console.warn("<EditableDiv> was created without expected prop 'onCancel'");
    }
    if (onFind === void 0 && !("onFind" in $$props || $$self.$$.bound[$$self.$$.props["onFind"]])) {
      console.warn("<EditableDiv> was created without expected prop 'onFind'");
    }
  });
  const writable_props = [
    "value",
    "shortText",
    "onChange",
    "onCancel",
    "onFind",
    "onPaste",
    "onValueClass"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EditableDiv> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      domValue = $$value;
      $$invalidate(1, domValue);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(7, value = $$props2.value);
    if ("shortText" in $$props2)
      $$invalidate(0, shortText = $$props2.shortText);
    if ("onChange" in $$props2)
      $$invalidate(8, onChange = $$props2.onChange);
    if ("onCancel" in $$props2)
      $$invalidate(9, onCancel = $$props2.onCancel);
    if ("onFind" in $$props2)
      $$invalidate(10, onFind = $$props2.onFind);
    if ("onPaste" in $$props2)
      $$invalidate(11, onPaste = $$props2.onPaste);
    if ("onValueClass" in $$props2)
      $$invalidate(12, onValueClass = $$props2.onValueClass);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    addNewLineSuffix,
    removeNewLineSuffix,
    setCursorToEnd,
    keyComboFromEvent,
    createDebug,
    classnames: import_classnames.default,
    noop: noop_default,
    UPDATE_SELECTION,
    debug: debug5,
    value,
    shortText,
    onChange,
    onCancel,
    onFind,
    onPaste,
    onValueClass,
    domValue,
    valueClass,
    closed,
    getDomValue,
    setDomValue,
    handleValueInput,
    handleValueKeyDown,
    handleValuePaste,
    handleBlur
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(7, value = $$props2.value);
    if ("shortText" in $$props2)
      $$invalidate(0, shortText = $$props2.shortText);
    if ("onChange" in $$props2)
      $$invalidate(8, onChange = $$props2.onChange);
    if ("onCancel" in $$props2)
      $$invalidate(9, onCancel = $$props2.onCancel);
    if ("onFind" in $$props2)
      $$invalidate(10, onFind = $$props2.onFind);
    if ("onPaste" in $$props2)
      $$invalidate(11, onPaste = $$props2.onPaste);
    if ("onValueClass" in $$props2)
      $$invalidate(12, onValueClass = $$props2.onValueClass);
    if ("domValue" in $$props2)
      $$invalidate(1, domValue = $$props2.domValue);
    if ("valueClass" in $$props2)
      $$invalidate(2, valueClass = $$props2.valueClass);
    if ("closed" in $$props2)
      closed = $$props2.closed;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    shortText,
    domValue,
    valueClass,
    handleValueInput,
    handleValueKeyDown,
    handleValuePaste,
    handleBlur,
    value,
    onChange,
    onCancel,
    onFind,
    onPaste,
    onValueClass,
    div_binding
  ];
}
var EditableDiv = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance24,
      create_fragment24,
      not_equal,
      {
        value: 7,
        shortText: 0,
        onChange: 8,
        onCancel: 9,
        onFind: 10,
        onPaste: 11,
        onValueClass: 12
      },
      add_css18
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EditableDiv",
      options,
      id: create_fragment24.name
    });
  }
  get value() {
    throw new Error("<EditableDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<EditableDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shortText() {
    throw new Error("<EditableDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shortText(value) {
    throw new Error("<EditableDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<EditableDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<EditableDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCancel() {
    throw new Error("<EditableDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCancel(value) {
    throw new Error("<EditableDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFind() {
    throw new Error("<EditableDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFind(value) {
    throw new Error("<EditableDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPaste() {
    throw new Error("<EditableDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPaste(value) {
    throw new Error("<EditableDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onValueClass() {
    throw new Error("<EditableDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onValueClass(value) {
    throw new Error("<EditableDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EditableDiv_default = EditableDiv;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/JSONKey.svelte
var file22 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/JSONKey.svelte";
function add_css19(target) {
  append_styles(target, "svelte-q2wt5d", '.jse-key.svelte-q2wt5d{display:inline-block;min-width:2em;padding:0 5px;box-sizing:border-box;outline:none;border-radius:1px;vertical-align:top;color:var(--jse-key-color);word-break:normal;overflow-wrap:normal;white-space:pre-wrap}.jse-key.svelte-q2wt5d:hover{background:var(--jse-hover-background-color)}.jse-key.svelte-q2wt5d:hover{background:var(--jse-hover-background-color)}.jse-key.jse-empty.svelte-q2wt5d{min-width:3em;outline:1px dotted var(--jse-tag-background);-moz-outline-radius:2px}.jse-key.jse-empty.svelte-q2wt5d::after{pointer-events:none;color:var(--jse-tag-background);content:"key"}.svelte-q2wt5d{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTktleS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBdUUyQixRQUFBLGNBQUEsQ0FBQSxrbEJBNEIxQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJKU09OS2V5LnN2ZWx0ZSJdfQ== */');
}
function create_else_block7(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_27, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-type": true, class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-type", "selectable-key");
      attr_dev(div, "class", div_class_value = null_to_empty(ctx[6](ctx[0])) + " svelte-q2wt5d");
      add_location(div, file22, 59, 2, 2099);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "dblclick", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & 1 && div_class_value !== (div_class_value = null_to_empty(ctx2[6](ctx2[0])) + " svelte-q2wt5d")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(59:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let editablediv;
  let current;
  editablediv = new EditableDiv_default({
    props: {
      value: ctx[2].normalization.escapeValue(ctx[0]),
      shortText: true,
      onChange: ctx[7],
      onCancel: ctx[8],
      onFind: ctx[2].onFind
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(editablediv.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(editablediv.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(editablediv, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const editablediv_changes = {};
      if (dirty & 5)
        editablediv_changes.value = ctx2[2].normalization.escapeValue(ctx2[0]);
      if (dirty & 4)
        editablediv_changes.onFind = ctx2[2].onFind;
      editablediv.$set(editablediv_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(editablediv.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(editablediv.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(editablediv, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(51:0) {#if isEditingKey}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let t_value = addNewLineSuffix(ctx[2].normalization.escapeValue(ctx[0])) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 5 && t_value !== (t_value = addNewLineSuffix(ctx2[2].normalization.escapeValue(ctx2[0])) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(63:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let searchresulthighlighter;
  let current;
  searchresulthighlighter = new SearchResultHighlighter_default({
    props: {
      text: ctx[2].normalization.escapeValue(ctx[0]),
      searchResultItems: ctx[1]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(searchresulthighlighter.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(searchresulthighlighter.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(searchresulthighlighter, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const searchresulthighlighter_changes = {};
      if (dirty & 5)
        searchresulthighlighter_changes.text = ctx2[2].normalization.escapeValue(ctx2[0]);
      if (dirty & 2)
        searchresulthighlighter_changes.searchResultItems = ctx2[1];
      searchresulthighlighter.$set(searchresulthighlighter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchresulthighlighter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchresulthighlighter.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(searchresulthighlighter, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(61:4) {#if searchResultItems}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let contextmenubutton;
  let current;
  contextmenubutton = new ContextMenuButton_default({
    props: {
      selected: true,
      onContextMenu: ctx[2].onContextMenu
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(contextmenubutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(contextmenubutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(contextmenubutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextmenubutton_changes = {};
      if (dirty & 4)
        contextmenubutton_changes.onContextMenu = ctx2[2].onContextMenu;
      contextmenubutton.$set(contextmenubutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextmenubutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextmenubutton.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(contextmenubutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(68:0) {#if !context.readOnly && isSelected && !isEditingKey}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_18, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !ctx[2].readOnly && ctx[3] && !ctx[4] && create_if_block13(ctx);
  const block = {
    c: function create() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t.parentNode, t);
      }
      if (!ctx2[2].readOnly && ctx2[3] && !ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 28) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block13(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy2(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let isSelected;
  let isEditingKey;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JSONKey", slots, []);
  let { path } = $$props;
  let { pointer } = $$props;
  let { key } = $$props;
  let { selection } = $$props;
  let { searchResultItems } = $$props;
  let { onUpdateKey } = $$props;
  let { context } = $$props;
  function handleKeyDoubleClick(event) {
    if (!isEditingKey && !context.readOnly) {
      event.preventDefault();
      context.onSelect(createKeySelection(path, true));
    }
  }
  function getKeyClass(key2) {
    return (0, import_classnames2.default)("jse-key", { "jse-empty": key2 === "" });
  }
  function handleChangeValue(newKey, updateSelection) {
    const updatedKey = onUpdateKey(key, context.normalization.unescapeValue(newKey));
    const updatedPath = initial_default(path).concat(updatedKey);
    context.onSelect(updateSelection === UPDATE_SELECTION.NEXT_INSIDE ? createValueSelection(updatedPath, false) : createKeySelection(updatedPath, false));
    if (updateSelection !== UPDATE_SELECTION.SELF) {
      context.focus();
    }
  }
  function handleCancelChange() {
    context.onSelect(createKeySelection(path, false));
    context.focus();
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<JSONKey> was created without expected prop 'path'");
    }
    if (pointer === void 0 && !("pointer" in $$props || $$self.$$.bound[$$self.$$.props["pointer"]])) {
      console.warn("<JSONKey> was created without expected prop 'pointer'");
    }
    if (key === void 0 && !("key" in $$props || $$self.$$.bound[$$self.$$.props["key"]])) {
      console.warn("<JSONKey> was created without expected prop 'key'");
    }
    if (selection === void 0 && !("selection" in $$props || $$self.$$.bound[$$self.$$.props["selection"]])) {
      console.warn("<JSONKey> was created without expected prop 'selection'");
    }
    if (searchResultItems === void 0 && !("searchResultItems" in $$props || $$self.$$.bound[$$self.$$.props["searchResultItems"]])) {
      console.warn("<JSONKey> was created without expected prop 'searchResultItems'");
    }
    if (onUpdateKey === void 0 && !("onUpdateKey" in $$props || $$self.$$.bound[$$self.$$.props["onUpdateKey"]])) {
      console.warn("<JSONKey> was created without expected prop 'onUpdateKey'");
    }
    if (context === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<JSONKey> was created without expected prop 'context'");
    }
  });
  const writable_props = [
    "path",
    "pointer",
    "key",
    "selection",
    "searchResultItems",
    "onUpdateKey",
    "context"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<JSONKey> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(9, path = $$props2.path);
    if ("pointer" in $$props2)
      $$invalidate(10, pointer = $$props2.pointer);
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("selection" in $$props2)
      $$invalidate(11, selection = $$props2.selection);
    if ("searchResultItems" in $$props2)
      $$invalidate(1, searchResultItems = $$props2.searchResultItems);
    if ("onUpdateKey" in $$props2)
      $$invalidate(12, onUpdateKey = $$props2.onUpdateKey);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
  };
  $$self.$capture_state = () => ({
    classnames: import_classnames2.default,
    initial: initial_default,
    createKeySelection,
    createValueSelection,
    isEditingSelection,
    SearchResultHighlighter: SearchResultHighlighter_default,
    EditableDiv: EditableDiv_default,
    addNewLineSuffix,
    UPDATE_SELECTION,
    isKeySelection,
    ContextMenuButton: ContextMenuButton_default,
    path,
    pointer,
    key,
    selection,
    searchResultItems,
    onUpdateKey,
    context,
    handleKeyDoubleClick,
    getKeyClass,
    handleChangeValue,
    handleCancelChange,
    isEditingKey,
    isSelected
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(9, path = $$props2.path);
    if ("pointer" in $$props2)
      $$invalidate(10, pointer = $$props2.pointer);
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("selection" in $$props2)
      $$invalidate(11, selection = $$props2.selection);
    if ("searchResultItems" in $$props2)
      $$invalidate(1, searchResultItems = $$props2.searchResultItems);
    if ("onUpdateKey" in $$props2)
      $$invalidate(12, onUpdateKey = $$props2.onUpdateKey);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
    if ("isEditingKey" in $$props2)
      $$invalidate(4, isEditingKey = $$props2.isEditingKey);
    if ("isSelected" in $$props2)
      $$invalidate(3, isSelected = $$props2.isSelected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3072) {
      $:
        $$invalidate(3, isSelected = selection ? selection.pointersMap[pointer] === true && isKeySelection(selection) : void 0);
    }
    if ($$self.$$.dirty & 2056) {
      $:
        $$invalidate(4, isEditingKey = isSelected && isEditingSelection(selection));
    }
  };
  return [
    key,
    searchResultItems,
    context,
    isSelected,
    isEditingKey,
    handleKeyDoubleClick,
    getKeyClass,
    handleChangeValue,
    handleCancelChange,
    path,
    pointer,
    selection,
    onUpdateKey
  ];
}
var JSONKey = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      not_equal,
      {
        path: 9,
        pointer: 10,
        key: 0,
        selection: 11,
        searchResultItems: 1,
        onUpdateKey: 12,
        context: 2
      },
      add_css19
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONKey",
      options,
      id: create_fragment25.name
    });
  }
  get path() {
    throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointer() {
    throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointer(value) {
    throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchResultItems() {
    throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchResultItems(value) {
    throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onUpdateKey() {
    throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onUpdateKey(value) {
    throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JSONKey_default = JSONKey;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/JSONValue.svelte
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_each_block9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[9].props];
  var switch_value = ctx[9].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[9].props)]) : {};
      if (switch_value !== (switch_value = ctx2[9].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block9.name,
    type: "each",
    source: "(31:0) {#each renderers as renderer}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let isEditing;
  let renderers;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JSONValue", slots, []);
  let { path } = $$props;
  let { value } = $$props;
  let { context } = $$props;
  let { isSelected } = $$props;
  let { enforceString } = $$props;
  let { selection } = $$props;
  let { searchResultItems } = $$props;
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<JSONValue> was created without expected prop 'path'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<JSONValue> was created without expected prop 'value'");
    }
    if (context === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<JSONValue> was created without expected prop 'context'");
    }
    if (isSelected === void 0 && !("isSelected" in $$props || $$self.$$.bound[$$self.$$.props["isSelected"]])) {
      console.warn("<JSONValue> was created without expected prop 'isSelected'");
    }
    if (enforceString === void 0 && !("enforceString" in $$props || $$self.$$.bound[$$self.$$.props["enforceString"]])) {
      console.warn("<JSONValue> was created without expected prop 'enforceString'");
    }
    if (selection === void 0 && !("selection" in $$props || $$self.$$.bound[$$self.$$.props["selection"]])) {
      console.warn("<JSONValue> was created without expected prop 'selection'");
    }
    if (searchResultItems === void 0 && !("searchResultItems" in $$props || $$self.$$.bound[$$self.$$.props["searchResultItems"]])) {
      console.warn("<JSONValue> was created without expected prop 'searchResultItems'");
    }
  });
  const writable_props = [
    "path",
    "value",
    "context",
    "isSelected",
    "enforceString",
    "selection",
    "searchResultItems"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<JSONValue> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(1, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("context" in $$props2)
      $$invalidate(3, context = $$props2.context);
    if ("isSelected" in $$props2)
      $$invalidate(4, isSelected = $$props2.isSelected);
    if ("enforceString" in $$props2)
      $$invalidate(5, enforceString = $$props2.enforceString);
    if ("selection" in $$props2)
      $$invalidate(6, selection = $$props2.selection);
    if ("searchResultItems" in $$props2)
      $$invalidate(7, searchResultItems = $$props2.searchResultItems);
  };
  $$self.$capture_state = () => ({
    isEditingSelection,
    isValueSelection,
    path,
    value,
    context,
    isSelected,
    enforceString,
    selection,
    searchResultItems,
    isEditing,
    renderers
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(1, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("context" in $$props2)
      $$invalidate(3, context = $$props2.context);
    if ("isSelected" in $$props2)
      $$invalidate(4, isSelected = $$props2.isSelected);
    if ("enforceString" in $$props2)
      $$invalidate(5, enforceString = $$props2.enforceString);
    if ("selection" in $$props2)
      $$invalidate(6, selection = $$props2.selection);
    if ("searchResultItems" in $$props2)
      $$invalidate(7, searchResultItems = $$props2.searchResultItems);
    if ("isEditing" in $$props2)
      $$invalidate(8, isEditing = $$props2.isEditing);
    if ("renderers" in $$props2)
      $$invalidate(0, renderers = $$props2.renderers);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 72) {
      $:
        $$invalidate(8, isEditing = !context.readOnly && isValueSelection(selection) && isEditingSelection(selection));
    }
    if ($$self.$$.dirty & 510) {
      $:
        $$invalidate(0, renderers = context.onRenderValue({
          path,
          value,
          readOnly: context.readOnly,
          enforceString,
          isSelected,
          isEditing,
          parser: context.parser,
          normalization: context.normalization,
          selection,
          searchResultItems,
          onPatch: context.onPatch,
          onPasteJson: context.onPasteJson,
          onSelect: context.onSelect,
          onFind: context.onFind,
          focus: context.focus
        }));
    }
  };
  return [
    renderers,
    path,
    value,
    context,
    isSelected,
    enforceString,
    selection,
    searchResultItems,
    isEditing
  ];
}
var JSONValue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, not_equal, {
      path: 1,
      value: 2,
      context: 3,
      isSelected: 4,
      enforceString: 5,
      selection: 6,
      searchResultItems: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONValue",
      options,
      id: create_fragment26.name
    });
  }
  get path() {
    throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSelected() {
    throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enforceString() {
    throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enforceString(value) {
    throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchResultItems() {
    throw new Error("<JSONValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchResultItems(value) {
    throw new Error("<JSONValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JSONValue_default = JSONValue;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/singleton.js
var singleton2 = {
  selecting: false,
  selectionAnchor: null,
  selectionAnchorType: null,
  selectionFocus: null,
  dragging: false
};

// ../node_modules/svelte-jsoneditor/logic/dragging.js
function onMoveSelection({ json: json2, documentState, deltaY, items }) {
  const selection = documentState.selection;
  const dragInsideAction = deltaY < 0 ? findSwapPathUp({ json: json2, selection, deltaY, items }) : findSwapPathDown({ json: json2, selection, deltaY, items });
  if (!dragInsideAction || dragInsideAction.offset === 0) {
    return {
      operations: void 0,
      updatedSelection: void 0,
      offset: 0
    };
  }
  const operations = moveInsideParent(json2, documentState.selection, dragInsideAction);
  const path = initial_default(getStartPath(selection));
  const value = getIn(json2, path);
  if (Array.isArray(value)) {
    const updatedSelection = createUpdatedArraySelection({
      items,
      json: json2,
      selection,
      offset: dragInsideAction.offset
    });
    return {
      operations,
      updatedSelection,
      offset: dragInsideAction.offset
    };
  } else {
    return {
      operations,
      updatedSelection: void 0,
      offset: dragInsideAction.offset
    };
  }
}
function findSwapPathUp({ items, selection, deltaY }) {
  const initialPath = getStartPath(selection);
  const initialIndex = items.findIndex((item) => isEqual_default(item.path, initialPath));
  const prevHeight = () => {
    var _a;
    return (_a = items[index - 1]) == null ? void 0 : _a.height;
  };
  let index = initialIndex;
  let cumulativeHeight = 0;
  while (prevHeight() !== void 0 && Math.abs(deltaY) > cumulativeHeight + prevHeight() / 2) {
    cumulativeHeight += prevHeight();
    index -= 1;
  }
  const beforePath = items[index].path;
  const offset = index - initialIndex;
  return index !== initialIndex && items[index] !== void 0 ? { beforePath, offset } : void 0;
}
function findSwapPathDown({ json: json2, items, selection, deltaY }) {
  var _a;
  const initialPath = getEndPath(selection);
  const initialIndex = items.findIndex((item) => isEqual_default(item.path, initialPath));
  let cumulativeHeight = 0;
  let index = initialIndex;
  const nextHeight = () => {
    var _a2;
    return (_a2 = items[index + 1]) == null ? void 0 : _a2.height;
  };
  while (nextHeight() !== void 0 && Math.abs(deltaY) > cumulativeHeight + nextHeight() / 2) {
    cumulativeHeight += nextHeight();
    index += 1;
  }
  const parentPath = initial_default(initialPath);
  const parent = getIn(json2, parentPath);
  const isArray = Array.isArray(parent);
  const beforeIndex = isArray ? index : index + 1;
  const beforePath = (_a = items[beforeIndex]) == null ? void 0 : _a.path;
  const offset = index - initialIndex;
  return beforePath ? { beforePath, offset } : { append: true, offset };
}
function createUpdatedArraySelection({ items, json: json2, selection, offset }) {
  var _a, _b;
  const startPath = getStartPath(selection);
  const endPath = getEndPath(selection);
  const startIndex = items.findIndex((item) => isEqual_default(item.path, startPath));
  const endIndex = items.findIndex((item) => isEqual_default(item.path, endPath));
  const anchorPath = (_a = items[startIndex + offset]) == null ? void 0 : _a.path;
  const focusPath = (_b = items[endIndex + offset]) == null ? void 0 : _b.path;
  return createMultiSelection(json2, anchorPath, focusPath);
}

// ../node_modules/svelte-jsoneditor/utils/jsonPointer.js
function filterMapOrUndefined(map, filter) {
  if (!map) {
    return void 0;
  }
  const filteredMap = {};
  for (const p of Object.keys(map)) {
    if (filter(p, map[p])) {
      filteredMap[p] = map[p];
    }
  }
  return Object.keys(filteredMap).length > 0 ? filteredMap : void 0;
}
function filterPointerOrUndefined(map, pointer) {
  return filterMapOrUndefined(map, (p) => startsWithJSONPointer(p, pointer));
}

// ../node_modules/svelte-jsoneditor/components/controls/tooltip/Tooltip.svelte
var file23 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/tooltip/Tooltip.svelte";
function add_css20(target) {
  append_styles(target, "svelte-1nmtmhq", ".jse-tooltip.svelte-1nmtmhq{font-family:var(--jse-font-family);font-size:var(--jse-font-size);line-height:normal;padding:calc(0.5 * var(--jse-padding)) var(--jse-padding);border-radius:3px;background:var(--jse-context-menu-background);color:var(--jse-context-menu-color);white-space:nowrap;box-shadow:var(--jse-controls-box-shadow)}.svelte-1nmtmhq{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9vbHRpcC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBTzRCLFlBQVksZUFBQyxDQUFBLEFBQ3ZDLFdBQVcsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLENBQ25DLFNBQVMsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxDQUMvQixXQUFXLENBQUUsTUFBTSxDQUNuQixPQUFPLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxDQUMxRCxhQUFhLENBQUUsR0FBRyxDQUNsQixVQUFVLENBQUUsSUFBSSw2QkFBNkIsQ0FBQyxDQUM5QyxLQUFLLENBQUUsSUFBSSx3QkFBd0IsQ0FBQyxDQUNwQyxXQUFXLENBQUUsTUFBTSxDQUNuQixVQUFVLENBQUUsSUFBSSx5QkFBeUIsQ0FBQyxBQUM1QyxDQUFBLEFBQUEsZUFBQSxFQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRvb2x0aXAuc3ZlbHRlIl19 */");
}
function create_fragment27(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ctx[0]);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-tooltip svelte-1nmtmhq");
      add_location(div, file23, 3, 0, 37);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, []);
  let { text: text2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Tooltip> was created without expected prop 'text'");
    }
  });
  const writable_props = ["text"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tooltip> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  $$self.$capture_state = () => ({ text: text2 });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [text2];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { text: 0 }, add_css20);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment27.name
    });
  }
  get text() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

// ../node_modules/svelte-jsoneditor/components/controls/tooltip/tooltip.js
function tooltip(node, { text: text2, openAbsolutePopup, closeAbsolutePopup }) {
  let popupId;
  function handleMouseEnter() {
    const props = {
      text: text2
    };
    popupId = openAbsolutePopup(Tooltip_default, props, {
      position: "top",
      width: 10 * text2.length,
      offsetTop: 3,
      anchor: node,
      closeOnOuterClick: true
    });
  }
  function handleMouseLeave() {
    closeAbsolutePopup(popupId);
  }
  node.addEventListener("mouseenter", handleMouseEnter);
  node.addEventListener("mouseleave", handleMouseLeave);
  return {
    destroy() {
      node.removeEventListener("mouseenter", handleMouseEnter);
      node.removeEventListener("mouseleave", handleMouseLeave);
    }
  };
}

// ../node_modules/svelte-jsoneditor/components/modes/treemode/ValidationErrorIcon.svelte
var file24 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/ValidationErrorIcon.svelte";
function add_css21(target) {
  append_styles(target, "svelte-1j54zzm", "button.jse-validation-error.svelte-1j54zzm{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;color:var(--jse-warning-color);padding:0 5px;margin:0;font-size:var(--jse-font-size-mono);height:var(--jse-line-height);overflow:hidden}.svelte-1j54zzm{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmFsaWRhdGlvbkVycm9ySWNvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUJ3QyxNQUFNLHFCQUFxQixlQUFDLENBQUEsQUFDbEUsTUFBTSxDQUFFLElBQUksQ0FDWixVQUFVLENBQUUsV0FBVyxDQUN2QixLQUFLLENBQUUsT0FBTyxDQUNkLE1BQU0sQ0FBRSxPQUFPLENBQ2YsV0FBVyxDQUFFLElBQUksaUJBQWlCLENBQUMsQ0FDbkMsU0FBUyxDQUFFLElBQUksZUFBZSxDQUFDLENBQy9CLE9BQU8sQ0FBRSxHQUFHLENBQ1osTUFBTSxDQUFFLENBQUMsQ0FDVCxLQUFLLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxDQUMvQixPQUFPLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDZCxNQUFNLENBQUUsQ0FBQyxDQUNULFNBQVMsQ0FBRSxJQUFJLG9CQUFvQixDQUFDLENBQ3BDLE1BQU0sQ0FBRSxJQUFJLGlCQUFpQixDQUFDLENBQzlCLFFBQVEsQ0FBRSxNQUFNLEFBQ2xCLENBQUEsQUFBQSxlQUFBLEVBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmFsaWRhdGlvbkVycm9ySWNvbi5zdmVsdGUiXX0= */");
}
function create_fragment28(ctx) {
  let button;
  let icon;
  let tooltip_action;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { data: faExclamationTriangle },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-validation-error svelte-1j54zzm");
      add_location(button, file24, 10, 0, 432);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            function() {
              if (is_function(ctx[0]))
                ctx[0].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          action_destroyer(tooltip_action = tooltip.call(null, button, {
            text: ctx[1],
            ...ctx[2]
          }))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 2)
        tooltip_action.update.call(null, {
          text: ctx[1],
          ...ctx[2]
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let text2;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ValidationErrorIcon", slots, []);
  const absolutePopupContext = getContext("absolute-popup");
  let { validationError } = $$props;
  let { onExpand } = $$props;
  $$self.$$.on_mount.push(function() {
    if (validationError === void 0 && !("validationError" in $$props || $$self.$$.bound[$$self.$$.props["validationError"]])) {
      console.warn("<ValidationErrorIcon> was created without expected prop 'validationError'");
    }
    if (onExpand === void 0 && !("onExpand" in $$props || $$self.$$.bound[$$self.$$.props["onExpand"]])) {
      console.warn("<ValidationErrorIcon> was created without expected prop 'onExpand'");
    }
  });
  const writable_props = ["validationError", "onExpand"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ValidationErrorIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("validationError" in $$props2)
      $$invalidate(3, validationError = $$props2.validationError);
    if ("onExpand" in $$props2)
      $$invalidate(0, onExpand = $$props2.onExpand);
  };
  $$self.$capture_state = () => ({
    faExclamationTriangle,
    Icon: Icon_default,
    getContext,
    tooltip,
    absolutePopupContext,
    validationError,
    onExpand,
    text: text2
  });
  $$self.$inject_state = ($$props2) => {
    if ("validationError" in $$props2)
      $$invalidate(3, validationError = $$props2.validationError);
    if ("onExpand" in $$props2)
      $$invalidate(0, onExpand = $$props2.onExpand);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(1, text2 = validationError.isChildError ? "Contains invalid data" : validationError.message);
    }
  };
  return [onExpand, text2, absolutePopupContext, validationError];
}
var ValidationErrorIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { validationError: 3, onExpand: 0 }, add_css21);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ValidationErrorIcon",
      options,
      id: create_fragment28.name
    });
  }
  get validationError() {
    throw new Error("<ValidationErrorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationError(value) {
    throw new Error("<ValidationErrorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExpand() {
    throw new Error("<ValidationErrorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExpand(value) {
    throw new Error("<ValidationErrorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ValidationErrorIcon_default = ValidationErrorIcon;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/JSONNode.svelte
var { Object: Object_14 } = globals;
var file25 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/JSONNode.svelte";
function add_css22(target) {
  append_styles(target, "svelte-mirq6d", ".jse-json-node.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{position:relative;color:var(--jse-text-color)}.jse-json-node.jse-root.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{min-height:100%;padding-bottom:2px;box-sizing:border-box}.jse-json-node.jse-root.svelte-mirq6d>.jse-header-outer.svelte-mirq6d .jse-context-menu-button,.jse-json-node.jse-root.svelte-mirq6d>.jse-contents-outer.svelte-mirq6d>.jse-contents.svelte-mirq6d .jse-context-menu-button{top:0;right:calc(-2px - var(--jse-context-menu-button-size))}.jse-json-node.jse-root.svelte-mirq6d>.jse-contents-outer.svelte-mirq6d>.jse-contents.svelte-mirq6d.svelte-mirq6d{padding-left:0}.jse-json-node.jse-hovered.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-meta.svelte-mirq6d,.jse-json-node.jse-hovered.svelte-mirq6d .jse-props .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-hovered.svelte-mirq6d .jse-items .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-hovered.svelte-mirq6d .jse-props .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-hovered.svelte-mirq6d .jse-items .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-hovered.svelte-mirq6d .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{background:var(--jse-hover-background-color)}.jse-json-node.svelte-mirq6d .jse-props.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.svelte-mirq6d .jse-items.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{position:relative}.jse-json-node.svelte-mirq6d .jse-header-outer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.svelte-mirq6d .jse-footer-outer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{display:flex}.jse-json-node.svelte-mirq6d .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{position:relative}.jse-json-node.svelte-mirq6d .jse-header .jse-meta.svelte-mirq6d>.jse-meta-inner.svelte-mirq6d.svelte-mirq6d{display:flex;justify-content:center}.jse-json-node.svelte-mirq6d .jse-contents-outer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{display:flex}.jse-json-node.svelte-mirq6d .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.svelte-mirq6d .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{display:flex;flex-direction:row}.jse-json-node.svelte-mirq6d .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{padding-left:var(--jse-indent-size)}.jse-json-node.svelte-mirq6d .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{display:inline-flex;padding-left:calc(var(--jse-indent-size) + 5px)}.jse-json-node.svelte-mirq6d .jse-insert-selection-area.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{visibility:hidden;padding:0 calc(0.5 * var(--jse-padding));flex:1}.jse-json-node.svelte-mirq6d .jse-insert-selection-area.jse-inside.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{display:inline-flex;align-items:center}.jse-json-node.svelte-mirq6d .jse-insert-selection-area.jse-after.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{display:flex;align-items:flex-end}.jse-json-node.svelte-mirq6d:hover>.jse-contents-outer .jse-insert-selection-area.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d:not(.jse-selected),.jse-json-node.svelte-mirq6d .jse-header-outer.svelte-mirq6d:hover>.jse-insert-selection-area.svelte-mirq6d.svelte-mirq6d:not(.jse-selected),.jse-json-node.svelte-mirq6d .jse-footer-outer:hover .jse-insert-selection-area.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d:not(.jse-selected){visibility:visible;z-index:1}.jse-json-node.svelte-mirq6d .jse-context-menu-button-anchor.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{position:relative}.jse-json-node.svelte-mirq6d .jse-insert-area.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{display:flex;position:relative;max-width:250px;min-width:100px;height:0;margin-right:calc(0.5 * var(--jse-padding));outline:1px solid}.jse-json-node.svelte-mirq6d .jse-insert-area.svelte-mirq6d .jse-context-menu-button{right:-1px;background:var(--jse-selection-background-color)}.jse-json-node.svelte-mirq6d .jse-insert-area.jse-hovered.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{outline-color:var(--jse-selection-background-color)}.jse-json-node.jse-selected.svelte-mirq6d .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected.svelte-mirq6d .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected.svelte-mirq6d .jse-meta.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected.svelte-mirq6d .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected.svelte-mirq6d .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected.svelte-mirq6d .jse-key,.jse-json-node.jse-selected.svelte-mirq6d .jse-value{background:var(--jse-selection-background-color) !important;cursor:grab}.jse-json-node.jse-selected.svelte-mirq6d .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{cursor:pointer}.jse-json-node.jse-selected-key.svelte-mirq6d>.jse-contents-outer.svelte-mirq6d>.jse-contents.svelte-mirq6d>.jse-identifier>.jse-key,.jse-json-node.jse-selected-key.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-identifier>.jse-key{background:var(--jse-selection-background-color);cursor:grab}.jse-json-node.jse-selected-value.svelte-mirq6d>.jse-contents-outer.svelte-mirq6d>.jse-contents.svelte-mirq6d>.jse-value{background:var(--jse-selection-background-color);cursor:grab}.jse-json-node.svelte-mirq6d .jse-collapsed-items.jse-selected,.jse-json-node.jse-selected.svelte-mirq6d .jse-collapsed-items,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-collapsed-items{background-color:var(--jse-selection-background-color);cursor:grab;background-image:linear-gradient(var(--jse-collapsed-items-selected-background-color), var(--jse-collapsed-items-selected-background-color)), linear-gradient(to bottom right, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%), linear-gradient(to bottom left, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%), linear-gradient(to top right, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%), linear-gradient(to top left, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%)}.jse-json-node.jse-selected-value.svelte-mirq6d .jse-meta.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-meta.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d>.jse-footer-outer.svelte-mirq6d>.jse-footer.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{background:var(--jse-selection-background-color) !important}.jse-json-node.jse-selected-value.svelte-mirq6d .jse-meta.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-meta.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-meta.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-meta.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d>.jse-footer-outer.svelte-mirq6d>.jse-footer.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d>.jse-footer-outer.svelte-mirq6d>.jse-footer.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-contents.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-contents.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-header.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-header.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-footer.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-footer.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-expand.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-expand.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-contents.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-contents.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-header.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-header.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-footer.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-footer.svelte-mirq6d .jse-value,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-expand.svelte-mirq6d .jse-key,.jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-expand.svelte-mirq6d .jse-value{background:var(--jse-selection-background-color);cursor:grab}.jse-json-node.jse-readonly.svelte-mirq6d .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-readonly.svelte-mirq6d .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-readonly.svelte-mirq6d .jse-meta.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-readonly.svelte-mirq6d .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-readonly.svelte-mirq6d .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-json-node.jse-readonly.svelte-mirq6d .jse-key,.jse-json-node.jse-readonly.svelte-mirq6d .jse-value,.jse-json-node.jse-readonly.svelte-mirq6d .jse-collapsed-items{cursor:default !important}.jse-json-node.svelte-mirq6d .jse-insert-area.jse-selected.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{z-index:2;outline-color:var(--jse-context-menu-button-background)}.jse-json-node.svelte-mirq6d .jse-insert-area.jse-selected.svelte-mirq6d .jse-context-menu-button{background:var(--jse-context-menu-button-background)}.jse-json-node.svelte-mirq6d .jse-insert-area.jse-selected.svelte-mirq6d .jse-context-menu-button:hover{background:var(--jse-context-menu-button-background-highlight)}.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-meta.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-value{background:var(--jse-selection-background-light-color) !important;cursor:grab}.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{cursor:pointer}.jse-main:not(.jse-focus) .jse-json-node.jse-selected-key.svelte-mirq6d>.jse-contents-outer.svelte-mirq6d>.jse-contents.svelte-mirq6d>.jse-identifier>.jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-key.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-identifier>.jse-key{background:var(--jse-selection-background-light-color);cursor:grab}.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d>.jse-contents-outer.svelte-mirq6d>.jse-contents.svelte-mirq6d>.jse-value{background:var(--jse-selection-background-light-color);cursor:grab}.jse-main:not(.jse-focus) .jse-json-node.svelte-mirq6d .jse-collapsed-items.jse-selected,.jse-main:not(.jse-focus) .jse-json-node.jse-selected.svelte-mirq6d .jse-collapsed-items,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-collapsed-items{background-color:var(--jse-selection-background-light-color);cursor:grab;background-image:linear-gradient(var(--jse-collapsed-items-selected-background-color), var(--jse-collapsed-items-selected-background-color)), linear-gradient(to bottom right, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%), linear-gradient(to bottom left, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%), linear-gradient(to top right, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%), linear-gradient(to top left, transparent 50.5%, var(--jse-collapsed-items-selected-background-color) 50.5%)}.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-meta.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-meta.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d>.jse-footer-outer.svelte-mirq6d>.jse-footer.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{background:var(--jse-selection-background-light-color) !important}.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-meta.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-meta.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-meta.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d>.jse-header-outer.svelte-mirq6d>.jse-header.svelte-mirq6d>.jse-meta.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d>.jse-footer-outer.svelte-mirq6d>.jse-footer.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d>.jse-footer-outer.svelte-mirq6d>.jse-footer.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-contents.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-contents.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-header.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-header.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-footer.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-footer.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-expand.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-props .jse-expand.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-contents.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-contents.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-header.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-header.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-footer.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-footer.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-expand.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-selected-value.svelte-mirq6d .jse-items .jse-expand.svelte-mirq6d .jse-value{background:var(--jse-selection-background-light-color);cursor:grab}.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-header.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-contents.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-meta.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-footer.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-key,.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-value,.jse-main:not(.jse-focus) .jse-json-node.jse-readonly.svelte-mirq6d .jse-collapsed-items{cursor:default !important}.jse-main:not(.jse-focus) .jse-json-node.svelte-mirq6d .jse-insert-area.jse-selected.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{z-index:2;outline-color:var(--jse-selection-background-color)}.jse-main:not(.jse-focus) .jse-json-node.svelte-mirq6d .jse-insert-area.jse-selected.svelte-mirq6d .jse-context-menu-button{background:var(--jse-selection-background-color)}.jse-main:not(.jse-focus) .jse-json-node.svelte-mirq6d .jse-insert-area.jse-selected.svelte-mirq6d .jse-context-menu-button:hover{background:var(--jse-selection-background-color)}.jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{width:var(--jse-indent-size);padding:0;margin:0;border:none;cursor:pointer;background:transparent;color:var(--jse-delimiter-color);font-size:var(--jse-font-size-mono);height:var(--jse-line-height)}.jse-expand.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d:hover{opacity:0.8}.jse-meta.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-separator.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-index.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d,.jse-bracket.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{vertical-align:top;color:var(--jse-delimiter-color)}.jse-index.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{padding:0 calc(0.5 * var(--jse-padding))}.jse-bracket.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{padding:0 2px}.jse-bracket.jse-expanded.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{padding-right:var(--jse-padding)}.jse-tag.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{border:none;font-size:80%;font-family:var(--jse-font-family);color:var(--jse-tag-color);background:var(--jse-tag-background);border-radius:2px;cursor:pointer;position:relative;display:inline-block;padding:0 4px;line-height:normal;margin:1px 0}.jse-tag.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d:hover{opacity:0.8}.jse-tag.jse-expanded.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{opacity:0.7;cursor:inherit}.jse-identifier.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{vertical-align:top;position:relative}.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d.svelte-mirq6d{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTk5vZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTh0QjRCLGNBQUEsd0RBQUEsQ0FBQSxrN29CQW9VM0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSlNPTk5vZGUuc3ZlbHRlIl19 */");
}
var get_identifier_slot_changes_2 = (dirty) => ({});
var get_identifier_slot_context_2 = (ctx) => ({});
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[53] = list[i];
  return child_ctx;
}
var get_identifier_slot_changes_1 = (dirty) => ({});
var get_identifier_slot_context_1 = (ctx) => ({});
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i];
  child_ctx[49] = i;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i];
  return child_ctx;
}
var get_identifier_slot_changes = (dirty) => ({});
var get_identifier_slot_context = (ctx) => ({});
function create_else_block_5(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let jsonvalue;
  let t2;
  let show_if = !ctx[8].readOnly && ctx[16] && ctx[7] && (isValueSelection(ctx[7]) || isMultiSelection(ctx[7])) && !ctx[7].edit && isEqual_default(ctx[7].focusPath, ctx[1]);
  let t3;
  let t4;
  let current;
  const identifier_slot_template = ctx[34].identifier;
  const identifier_slot = create_slot(identifier_slot_template, ctx, ctx[35], get_identifier_slot_context_2);
  let if_block0 = !ctx[17] && create_if_block_262(ctx);
  jsonvalue = new JSONValue_default({
    props: {
      path: ctx[1],
      value: ctx[0],
      enforceString: ctx[13],
      isSelected: ctx[16],
      selection: ctx[16] ? ctx[7] : void 0,
      searchResultItems: filterValueSearchResults(ctx[6], ctx[9]),
      context: ctx[8]
    },
    $$inline: true
  });
  let if_block1 = show_if && create_if_block_252(ctx);
  let if_block2 = ctx[15] && create_if_block_242(ctx);
  let if_block3 = !ctx[17] && create_if_block_232(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (identifier_slot)
        identifier_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(jsonvalue.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (identifier_slot)
        identifier_slot.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block0)
        if_block0.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      claim_component(jsonvalue.$$.fragment, div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      t4 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-contents svelte-mirq6d");
      add_location(div0, file25, 684, 6, 28528);
      attr_dev(div1, "class", "jse-contents-outer svelte-mirq6d");
      attr_dev(div1, "style", ctx[18]);
      add_location(div1, file25, 683, 4, 28464);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (identifier_slot) {
        identifier_slot.m(div0, null);
      }
      append_hydration_dev(div0, t0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t1);
      mount_component(jsonvalue, div0, null);
      append_hydration_dev(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      append_hydration_dev(div1, t4);
      if (if_block3)
        if_block3.m(div1, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (identifier_slot) {
        if (identifier_slot.p && (!current || dirty[1] & 16)) {
          update_slot_base(
            identifier_slot,
            identifier_slot_template,
            ctx2,
            ctx2[35],
            !current ? get_all_dirty_from_scope(ctx2[35]) : get_slot_changes(identifier_slot_template, ctx2[35], dirty, get_identifier_slot_changes_2),
            get_identifier_slot_context_2
          );
        }
      }
      if (!ctx2[17]) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_262(ctx2);
          if_block0.c();
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const jsonvalue_changes = {};
      if (dirty[0] & 2)
        jsonvalue_changes.path = ctx2[1];
      if (dirty[0] & 1)
        jsonvalue_changes.value = ctx2[0];
      if (dirty[0] & 8192)
        jsonvalue_changes.enforceString = ctx2[13];
      if (dirty[0] & 65536)
        jsonvalue_changes.isSelected = ctx2[16];
      if (dirty[0] & 65664)
        jsonvalue_changes.selection = ctx2[16] ? ctx2[7] : void 0;
      if (dirty[0] & 576)
        jsonvalue_changes.searchResultItems = filterValueSearchResults(ctx2[6], ctx2[9]);
      if (dirty[0] & 256)
        jsonvalue_changes.context = ctx2[8];
      jsonvalue.$set(jsonvalue_changes);
      if (dirty[0] & 65922)
        show_if = !ctx2[8].readOnly && ctx2[16] && ctx2[7] && (isValueSelection(ctx2[7]) || isMultiSelection(ctx2[7])) && !ctx2[7].edit && isEqual_default(ctx2[7].focusPath, ctx2[1]);
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 65922) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_252(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[15]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 32768) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_242(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!ctx2[17]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_232(ctx2);
          if_block3.c();
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!current || dirty[0] & 262144) {
        attr_dev(div1, "style", ctx2[18]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(identifier_slot, local);
      transition_in(jsonvalue.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(identifier_slot, local);
      transition_out(jsonvalue.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div1);
      if (identifier_slot)
        identifier_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      destroy_component(jsonvalue);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_5.name,
    type: "else",
    source: "(683:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let div3;
  let div2;
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let t2;
  let div1;
  let div0;
  let t3;
  let show_if = !ctx[8].readOnly && ctx[16] && ctx[7] && (isValueSelection(ctx[7]) || isMultiSelection(ctx[7])) && !ctx[7].edit && isEqual_default(ctx[7].focusPath, ctx[1]);
  let t4;
  let t5;
  let t6;
  let if_block6_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_222, create_else_block_4];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (ctx2[12])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const identifier_slot_template = ctx[34].identifier;
  const identifier_slot = create_slot(identifier_slot_template, ctx, ctx[35], get_identifier_slot_context_1);
  let if_block1 = !ctx[17] && create_if_block_21(ctx);
  function select_block_type_5(ctx2, dirty) {
    if (ctx2[12])
      return create_if_block_20;
    return create_else_block_3;
  }
  let current_block_type = select_block_type_5(ctx, [-1, -1]);
  let if_block2 = current_block_type(ctx);
  let if_block3 = show_if && create_if_block_192(ctx);
  let if_block4 = ctx[15] && (!ctx[12] || !ctx[15].isChildError) && create_if_block_182(ctx);
  function select_block_type_6(ctx2, dirty) {
    if (ctx2[12])
      return create_if_block_162;
    if (!ctx2[17])
      return create_if_block_172;
  }
  let current_block_type_1 = select_block_type_6(ctx, [-1, -1]);
  let if_block5 = current_block_type_1 && current_block_type_1(ctx);
  let if_block6 = ctx[12] && create_if_block_132(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      button = element("button");
      if_block0.c();
      t0 = space();
      if (identifier_slot)
        identifier_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      div0 = element("div");
      if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      button = claim_element(div2_nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      if (identifier_slot)
        identifier_slot.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      if (if_block1)
        if_block1.l(div2_nodes);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true, "data-type": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block2.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      if (if_block3)
        if_block3.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      t4 = claim_space(div3_nodes);
      if (if_block4)
        if_block4.l(div3_nodes);
      t5 = claim_space(div3_nodes);
      if (if_block5)
        if_block5.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      t6 = claim_space(nodes);
      if (if_block6)
        if_block6.l(nodes);
      if_block6_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-expand svelte-mirq6d");
      attr_dev(button, "title", "Expand or collapse this object (Ctrl+Click to expand/collapse recursively)");
      add_location(button, file25, 569, 8, 23998);
      attr_dev(div0, "class", "jse-meta-inner svelte-mirq6d");
      add_location(div0, file25, 586, 10, 24538);
      attr_dev(div1, "class", "jse-meta svelte-mirq6d");
      attr_dev(div1, "data-type", "selectable-value");
      add_location(div1, file25, 585, 8, 24476);
      attr_dev(div2, "class", "jse-header svelte-mirq6d");
      add_location(div2, file25, 568, 6, 23965);
      attr_dev(div3, "class", "jse-header-outer svelte-mirq6d");
      attr_dev(div3, "style", ctx[18]);
      add_location(div3, file25, 567, 4, 23903);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, button);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(div2, t0);
      if (identifier_slot) {
        identifier_slot.m(div2, null);
      }
      append_hydration_dev(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if_block2.m(div0, null);
      append_hydration_dev(div2, t3);
      if (if_block3)
        if_block3.m(div2, null);
      append_hydration_dev(div3, t4);
      if (if_block4)
        if_block4.m(div3, null);
      append_hydration_dev(div3, t5);
      if (if_block5)
        if_block5.m(div3, null);
      insert_hydration_dev(target, t6, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_hydration_dev(target, if_block6_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[21], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, null);
      }
      if (identifier_slot) {
        if (identifier_slot.p && (!current || dirty[1] & 16)) {
          update_slot_base(
            identifier_slot,
            identifier_slot_template,
            ctx2,
            ctx2[35],
            !current ? get_all_dirty_from_scope(ctx2[35]) : get_slot_changes(identifier_slot_template, ctx2[35], dirty, get_identifier_slot_changes_1),
            get_identifier_slot_context_1
          );
        }
      }
      if (!ctx2[17]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_21(ctx2);
          if_block1.c();
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_5(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div0, null);
        }
      }
      if (dirty[0] & 65922)
        show_if = !ctx2[8].readOnly && ctx2[16] && ctx2[7] && (isValueSelection(ctx2[7]) || isMultiSelection(ctx2[7])) && !ctx2[7].edit && isEqual_default(ctx2[7].focusPath, ctx2[1]);
      if (show_if) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 65922) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_192(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[15] && (!ctx2[12] || !ctx2[15].isChildError)) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 36864) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_182(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div3, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_6(ctx2, dirty)) && if_block5) {
        if_block5.p(ctx2, dirty);
      } else {
        if (if_block5)
          if_block5.d(1);
        if_block5 = current_block_type_1 && current_block_type_1(ctx2);
        if (if_block5) {
          if_block5.c();
          if_block5.m(div3, null);
        }
      }
      if (!current || dirty[0] & 262144) {
        attr_dev(div3, "style", ctx2[18]);
      }
      if (ctx2[12]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_132(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(identifier_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(identifier_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div3);
      if_blocks[current_block_type_index].d();
      if (identifier_slot)
        identifier_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5) {
        if_block5.d();
      }
      if (detaching)
        detach_dev(t6);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(567:28) ",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let div3;
  let div2;
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let t2;
  let div1;
  let div0;
  let t3;
  let show_if = !ctx[8].readOnly && ctx[16] && ctx[7] && (isValueSelection(ctx[7]) || isMultiSelection(ctx[7])) && !ctx[7].edit && isEqual_default(ctx[7].focusPath, ctx[1]);
  let t4;
  let t5;
  let t6;
  let if_block6_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_11, create_else_block_2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[12])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const identifier_slot_template = ctx[34].identifier;
  const identifier_slot = create_slot(identifier_slot_template, ctx, ctx[35], get_identifier_slot_context);
  let if_block1 = !ctx[17] && create_if_block_10(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[12])
      return create_if_block_9;
    return create_else_block_12;
  }
  let current_block_type = select_block_type_2(ctx, [-1, -1]);
  let if_block2 = current_block_type(ctx);
  let if_block3 = show_if && create_if_block_8(ctx);
  let if_block4 = ctx[15] && (!ctx[12] || !ctx[15].isChildError) && create_if_block_7(ctx);
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[12])
      return create_if_block_6;
    return create_else_block8;
  }
  let current_block_type_1 = select_block_type_3(ctx, [-1, -1]);
  let if_block5 = current_block_type_1(ctx);
  let if_block6 = ctx[12] && create_if_block_28(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      button = element("button");
      if_block0.c();
      t0 = space();
      if (identifier_slot)
        identifier_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      div0 = element("div");
      if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      button = claim_element(div2_nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      if (identifier_slot)
        identifier_slot.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      if (if_block1)
        if_block1.l(div2_nodes);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true, "data-type": true });
      var div0_nodes = children(div0);
      if_block2.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      if (if_block3)
        if_block3.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      t4 = claim_space(div3_nodes);
      if (if_block4)
        if_block4.l(div3_nodes);
      t5 = claim_space(div3_nodes);
      if_block5.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      t6 = claim_space(nodes);
      if (if_block6)
        if_block6.l(nodes);
      if_block6_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-expand svelte-mirq6d");
      attr_dev(button, "title", "Expand or collapse this array (Ctrl+Click to expand/collapse recursively)");
      add_location(button, file25, 444, 8, 19042);
      attr_dev(div0, "class", "jse-meta-inner svelte-mirq6d");
      attr_dev(div0, "data-type", "selectable-value");
      add_location(div0, file25, 461, 10, 19552);
      attr_dev(div1, "class", "jse-meta svelte-mirq6d");
      add_location(div1, file25, 460, 8, 19519);
      attr_dev(div2, "class", "jse-header svelte-mirq6d");
      add_location(div2, file25, 443, 6, 19009);
      attr_dev(div3, "class", "jse-header-outer svelte-mirq6d");
      attr_dev(div3, "style", ctx[18]);
      add_location(div3, file25, 442, 4, 18947);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, button);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(div2, t0);
      if (identifier_slot) {
        identifier_slot.m(div2, null);
      }
      append_hydration_dev(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if_block2.m(div0, null);
      append_hydration_dev(div2, t3);
      if (if_block3)
        if_block3.m(div2, null);
      append_hydration_dev(div3, t4);
      if (if_block4)
        if_block4.m(div3, null);
      append_hydration_dev(div3, t5);
      if_block5.m(div3, null);
      insert_hydration_dev(target, t6, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_hydration_dev(target, if_block6_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[21], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, null);
      }
      if (identifier_slot) {
        if (identifier_slot.p && (!current || dirty[1] & 16)) {
          update_slot_base(
            identifier_slot,
            identifier_slot_template,
            ctx2,
            ctx2[35],
            !current ? get_all_dirty_from_scope(ctx2[35]) : get_slot_changes(identifier_slot_template, ctx2[35], dirty, get_identifier_slot_changes),
            get_identifier_slot_context
          );
        }
      }
      if (!ctx2[17]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_10(ctx2);
          if_block1.c();
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div0, null);
        }
      }
      if (dirty[0] & 65922)
        show_if = !ctx2[8].readOnly && ctx2[16] && ctx2[7] && (isValueSelection(ctx2[7]) || isMultiSelection(ctx2[7])) && !ctx2[7].edit && isEqual_default(ctx2[7].focusPath, ctx2[1]);
      if (show_if) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 65922) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_8(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[15] && (!ctx2[12] || !ctx2[15].isChildError)) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 36864) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_7(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div3, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx2, dirty)) && if_block5) {
        if_block5.p(ctx2, dirty);
      } else {
        if_block5.d(1);
        if_block5 = current_block_type_1(ctx2);
        if (if_block5) {
          if_block5.c();
          if_block5.m(div3, null);
        }
      }
      if (!current || dirty[0] & 262144) {
        attr_dev(div3, "style", ctx2[18]);
      }
      if (ctx2[12]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_28(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(identifier_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(identifier_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div3);
      if_blocks[current_block_type_index].d();
      if (identifier_slot)
        identifier_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if_block5.d();
      if (detaching)
        detach_dev(t6);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach_dev(if_block6_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(442:2) {#if Array.isArray(value)}",
    ctx
  });
  return block;
}
function create_if_block_262(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(":");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ":");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-separator svelte-mirq6d");
      add_location(div, file25, 687, 10, 28620);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_262.name,
    type: "if",
    source: "(687:8) {#if !root}",
    ctx
  });
  return block;
}
function create_if_block_252(ctx) {
  let div;
  let contextmenubutton;
  let current;
  contextmenubutton = new ContextMenuButton_default({
    props: {
      selected: true,
      onContextMenu: ctx[8].onContextMenu
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(contextmenubutton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(contextmenubutton.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-context-menu-button-anchor svelte-mirq6d");
      add_location(div, file25, 699, 10, 29136);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(contextmenubutton, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextmenubutton_changes = {};
      if (dirty[0] & 256)
        contextmenubutton_changes.onContextMenu = ctx2[8].onContextMenu;
      contextmenubutton.$set(contextmenubutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextmenubutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextmenubutton.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(contextmenubutton);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_252.name,
    type: "if",
    source: "(699:8) {#if !context.readOnly && isSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !selection.edit && isEqual(selection.focusPath, path)}",
    ctx
  });
  return block;
}
function create_if_block_242(ctx) {
  let validationerroricon;
  let current;
  validationerroricon = new ValidationErrorIcon_default({
    props: {
      validationError: ctx[15],
      onExpand: ctx[22]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(validationerroricon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(validationerroricon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(validationerroricon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const validationerroricon_changes = {};
      if (dirty[0] & 32768)
        validationerroricon_changes.validationError = ctx2[15];
      validationerroricon.$set(validationerroricon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(validationerroricon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(validationerroricon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(validationerroricon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_242.name,
    type: "if",
    source: "(705:6) {#if validationError}",
    ctx
  });
  return block;
}
function create_if_block_232(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-selection-area jse-after svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-after");
      add_location(div, file25, 709, 8, 29518);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[30], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_232.name,
    type: "if",
    source: "(708:6) {#if !root}",
    ctx
  });
  return block;
}
function create_else_block_4(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faCaretRight },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_4.name,
    type: "else",
    source: "(578:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_222(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faCaretDown },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(576:10) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_21(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(":");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ":");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-separator svelte-mirq6d");
      add_location(div, file25, 583, 10, 24419);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_21.name,
    type: "if",
    source: "(583:8) {#if !root}",
    ctx
  });
  return block;
}
function create_else_block_3(ctx) {
  let div0;
  let t0;
  let t1;
  let button;
  let t2_value = Object.keys(ctx[0]).length + "";
  let t2;
  let t3;
  let t4_value = Object.keys(ctx[0]).length === 1 ? "prop" : "props";
  let t4;
  let t5;
  let div1;
  let t6;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div0 = element("div");
      t0 = text("{");
      t1 = space();
      button = element("button");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      div1 = element("div");
      t6 = text("}");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "{");
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t2 = claim_text(button_nodes, t2_value);
      t3 = claim_space(button_nodes);
      t4 = claim_text(button_nodes, t4_value);
      button_nodes.forEach(detach_dev);
      t5 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t6 = claim_text(div1_nodes, "}");
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-bracket svelte-mirq6d");
      add_location(div0, file25, 590, 14, 24695);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-tag svelte-mirq6d");
      add_location(button, file25, 591, 14, 24749);
      attr_dev(div1, "class", "jse-bracket svelte-mirq6d");
      add_location(div1, file25, 595, 14, 24963);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, t3);
      append_hydration_dev(button, t4);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, t6);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[22], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1 && t2_value !== (t2_value = Object.keys(ctx2[0]).length + ""))
        set_data_dev(t2, t2_value);
      if (dirty[0] & 1 && t4_value !== (t4_value = Object.keys(ctx2[0]).length === 1 ? "prop" : "props"))
        set_data_dev(t4, t4_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(button);
      if (detaching)
        detach_dev(t5);
      if (detaching)
        detach_dev(div1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_3.name,
    type: "else",
    source: "(590:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_20(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("{");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "{");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-bracket jse-expanded svelte-mirq6d");
      add_location(div, file25, 588, 14, 24608);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_20.name,
    type: "if",
    source: "(588:12) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_192(ctx) {
  let div;
  let contextmenubutton;
  let current;
  contextmenubutton = new ContextMenuButton_default({
    props: {
      selected: true,
      onContextMenu: ctx[8].onContextMenu
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(contextmenubutton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(contextmenubutton.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-context-menu-button-anchor svelte-mirq6d");
      add_location(div, file25, 600, 10, 25243);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(contextmenubutton, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextmenubutton_changes = {};
      if (dirty[0] & 256)
        contextmenubutton_changes.onContextMenu = ctx2[8].onContextMenu;
      contextmenubutton.$set(contextmenubutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextmenubutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextmenubutton.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(contextmenubutton);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_192.name,
    type: "if",
    source: "(600:8) {#if !context.readOnly && isSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !selection.edit && isEqual(selection.focusPath, path)}",
    ctx
  });
  return block;
}
function create_if_block_182(ctx) {
  let validationerroricon;
  let current;
  validationerroricon = new ValidationErrorIcon_default({
    props: {
      validationError: ctx[15],
      onExpand: ctx[22]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(validationerroricon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(validationerroricon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(validationerroricon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const validationerroricon_changes = {};
      if (dirty[0] & 32768)
        validationerroricon_changes.validationError = ctx2[15];
      validationerroricon.$set(validationerroricon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(validationerroricon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(validationerroricon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(validationerroricon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(606:6) {#if validationError && (!expanded || !validationError.isChildError)}",
    ctx
  });
  return block;
}
function create_if_block_172(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-selection-area jse-after svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-after");
      add_location(div, file25, 617, 8, 25934);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[30], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(616:22) ",
    ctx
  });
  return block;
}
function create_if_block_162(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-selection-area jse-inside svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-inside");
      add_location(div, file25, 610, 8, 25676);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[29], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(609:6) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let div0;
  let show_if = !ctx[8].readOnly && (ctx[10] === HOVER_INSERT_INSIDE || ctx[16] && isInsideSelection(ctx[7]));
  let t0;
  let t1;
  let div3;
  let div2;
  let div1;
  let t2;
  let t3;
  let current;
  let if_block0 = show_if && create_if_block_152(ctx);
  let each_value_2 = ctx[19](ctx[1], ctx[0], ctx[2], ctx[3], ctx[4], ctx[5], ctx[6], ctx[7], ctx[11]);
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = !ctx[17] && create_if_block_142(ctx);
  const block = {
    c: function create() {
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      t2 = text("}");
      t3 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { "data-type": true, class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, "}");
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      if (if_block1)
        if_block1.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-props svelte-mirq6d");
      add_location(div0, file25, 625, 6, 26141);
      attr_dev(div1, "class", "jse-bracket svelte-mirq6d");
      add_location(div1, file25, 670, 10, 28094);
      attr_dev(div2, "data-type", "selectable-value");
      attr_dev(div2, "class", "jse-footer svelte-mirq6d");
      add_location(div2, file25, 669, 8, 28030);
      attr_dev(div3, "class", "jse-footer-outer svelte-mirq6d");
      attr_dev(div3, "style", ctx[18]);
      add_location(div3, file25, 668, 6, 27966);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div3, t3);
      if (if_block1)
        if_block1.m(div3, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 66944)
        show_if = !ctx2[8].readOnly && (ctx2[10] === HOVER_INSERT_INSIDE || ctx2[16] && isInsideSelection(ctx2[7]));
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 66944) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_152(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & 76024319) {
        each_value_2 = ctx2[19](ctx2[1], ctx2[0], ctx2[2], ctx2[3], ctx2[4], ctx2[5], ctx2[6], ctx2[7], ctx2[11]);
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!ctx2[17]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_142(ctx2);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[0] & 262144) {
        attr_dev(div3, "style", ctx2[18]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div0);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(div3);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(625:4) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let div;
  let contextmenubutton;
  let div_style_value;
  let current;
  contextmenubutton = new ContextMenuButton_default({
    props: {
      selected: ctx[16] && isInsideSelection(ctx[7]),
      onContextMenu: ctx[31]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(contextmenubutton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-type": true,
        style: true,
        title: true
      });
      var div_nodes = children(div);
      claim_component(contextmenubutton.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-area jse-inside svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-inside");
      attr_dev(div, "style", div_style_value = getIndentationStyle2(ctx[1].length + 1));
      attr_dev(div, "title", INSERT_EXPLANATION);
      toggle_class(div, "jse-hovered", ctx[10] === HOVER_INSERT_INSIDE);
      toggle_class(div, "jse-selected", ctx[16] && isInsideSelection(ctx[7]));
      add_location(div, file25, 627, 10, 26290);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(contextmenubutton, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextmenubutton_changes = {};
      if (dirty[0] & 65664)
        contextmenubutton_changes.selected = ctx2[16] && isInsideSelection(ctx2[7]);
      contextmenubutton.$set(contextmenubutton_changes);
      if (!current || dirty[0] & 2 && div_style_value !== (div_style_value = getIndentationStyle2(ctx2[1].length + 1))) {
        attr_dev(div, "style", div_style_value);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(div, "jse-hovered", ctx2[10] === HOVER_INSERT_INSIDE);
      }
      if (!current || dirty[0] & 65664) {
        toggle_class(div, "jse-selected", ctx2[16] && isInsideSelection(ctx2[7]));
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextmenubutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextmenubutton.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(contextmenubutton);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(627:8) {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isSelected && isInsideSelection(selection)))}",
    ctx
  });
  return block;
}
function create_identifier_slot_1(ctx) {
  let div;
  let jsonkey;
  let t;
  let current;
  jsonkey = new JSONKey_default({
    props: {
      path: ctx[53].path,
      pointer: ctx[53].pointer,
      key: ctx[53].key,
      selection: ctx[53].selection,
      searchResultItems: ctx[53].keySearchResultItemsMap,
      context: ctx[8],
      onUpdateKey: ctx[23]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(jsonkey.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { slot: true, class: true });
      var div_nodes = children(div);
      claim_component(jsonkey.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "slot", "identifier");
      attr_dev(div, "class", "jse-identifier svelte-mirq6d");
      add_location(div, file25, 654, 12, 27517);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(jsonkey, div, null);
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const jsonkey_changes = {};
      if (dirty[0] & 2303)
        jsonkey_changes.path = ctx2[53].path;
      if (dirty[0] & 2303)
        jsonkey_changes.pointer = ctx2[53].pointer;
      if (dirty[0] & 2303)
        jsonkey_changes.key = ctx2[53].key;
      if (dirty[0] & 2303)
        jsonkey_changes.selection = ctx2[53].selection;
      if (dirty[0] & 2303)
        jsonkey_changes.searchResultItems = ctx2[53].keySearchResultItemsMap;
      if (dirty[0] & 256)
        jsonkey_changes.context = ctx2[8];
      jsonkey.$set(jsonkey_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(jsonkey.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonkey.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(jsonkey);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_identifier_slot_1.name,
    type: "slot",
    source: "(655:12) ",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[53].value,
      path: ctx[53].path,
      expandedMap: ctx[53].expandedMap,
      enforceStringMap: ctx[53].enforceStringMap,
      visibleSectionsMap: ctx[53].visibleSectionsMap,
      validationErrorsMap: ctx[53].validationErrorsMap,
      searchResultItemsMap: ctx[53].valueSearchResultItemsMap,
      selection: ctx[53].selection,
      context: ctx[8],
      onDragSelectionStart: ctx[26],
      $$slots: { identifier: [create_identifier_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const jsonnode_changes = {};
      if (dirty[0] & 2303)
        jsonnode_changes.value = ctx2[53].value;
      if (dirty[0] & 2303)
        jsonnode_changes.path = ctx2[53].path;
      if (dirty[0] & 2303)
        jsonnode_changes.expandedMap = ctx2[53].expandedMap;
      if (dirty[0] & 2303)
        jsonnode_changes.enforceStringMap = ctx2[53].enforceStringMap;
      if (dirty[0] & 2303)
        jsonnode_changes.visibleSectionsMap = ctx2[53].visibleSectionsMap;
      if (dirty[0] & 2303)
        jsonnode_changes.validationErrorsMap = ctx2[53].validationErrorsMap;
      if (dirty[0] & 2303)
        jsonnode_changes.searchResultItemsMap = ctx2[53].valueSearchResultItemsMap;
      if (dirty[0] & 2303)
        jsonnode_changes.selection = ctx2[53].selection;
      if (dirty[0] & 256)
        jsonnode_changes.context = ctx2[8];
      if (dirty[0] & 2559 | dirty[1] & 16) {
        jsonnode_changes.$$scope = { dirty, ctx: ctx2 };
      }
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(642:8) {#each getProps(path, value, expandedMap, enforceStringMap, visibleSectionsMap, validationErrorsMap, searchResultItemsMap, selection, dragging) as prop}",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-selection-area jse-after svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-after");
      add_location(div, file25, 674, 10, 28246);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[30], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(673:8) {#if !root}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faCaretRight },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(453:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faCaretDown },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(451:10) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(":");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ":");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-separator svelte-mirq6d");
      add_location(div, file25, 458, 10, 19462);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(458:8) {#if !root}",
    ctx
  });
  return block;
}
function create_else_block_12(ctx) {
  let div0;
  let t0;
  let t1;
  let button;
  let t2_value = ctx[0].length + "";
  let t2;
  let t3;
  let t4_value = ctx[0].length === 1 ? "item" : "items";
  let t4;
  let t5;
  let div1;
  let t6;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div0 = element("div");
      t0 = text("[");
      t1 = space();
      button = element("button");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      div1 = element("div");
      t6 = text("]");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "[");
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t2 = claim_text(button_nodes, t2_value);
      t3 = claim_space(button_nodes);
      t4 = claim_text(button_nodes, t4_value);
      button_nodes.forEach(detach_dev);
      t5 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t6 = claim_text(div1_nodes, "]");
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-bracket svelte-mirq6d");
      add_location(div0, file25, 469, 14, 19877);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-tag svelte-mirq6d");
      add_location(button, file25, 470, 14, 19924);
      attr_dev(div1, "class", "jse-bracket svelte-mirq6d");
      add_location(div1, file25, 474, 14, 20112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      append_hydration_dev(div0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, t3);
      append_hydration_dev(button, t4);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, t6);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[22], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[0].length + ""))
        set_data_dev(t2, t2_value);
      if (dirty[0] & 1 && t4_value !== (t4_value = ctx2[0].length === 1 ? "item" : "items"))
        set_data_dev(t4, t4_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(button);
      if (detaching)
        detach_dev(t5);
      if (detaching)
        detach_dev(div1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(469:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let div;
  let t0;
  let t1;
  let span;
  let t2_value = ctx[0].length + "";
  let t2;
  let t3;
  let t4_value = ctx[0].length === 1 ? "item" : "items";
  let t4;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("[");
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "[");
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, t2_value);
      t3 = claim_space(span_nodes);
      t4 = claim_text(span_nodes, t4_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-bracket svelte-mirq6d");
      add_location(div, file25, 463, 14, 19651);
      attr_dev(span, "class", "jse-tag jse-expanded svelte-mirq6d");
      add_location(span, file25, 464, 14, 19698);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t2);
      append_hydration_dev(span, t3);
      append_hydration_dev(span, t4);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[0].length + ""))
        set_data_dev(t2, t2_value);
      if (dirty[0] & 1 && t4_value !== (t4_value = ctx2[0].length === 1 ? "item" : "items"))
        set_data_dev(t4, t4_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(463:12) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let div;
  let contextmenubutton;
  let current;
  contextmenubutton = new ContextMenuButton_default({
    props: {
      selected: true,
      onContextMenu: ctx[8].onContextMenu
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(contextmenubutton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(contextmenubutton.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-context-menu-button-anchor svelte-mirq6d");
      add_location(div, file25, 479, 10, 20385);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(contextmenubutton, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextmenubutton_changes = {};
      if (dirty[0] & 256)
        contextmenubutton_changes.onContextMenu = ctx2[8].onContextMenu;
      contextmenubutton.$set(contextmenubutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextmenubutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextmenubutton.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(contextmenubutton);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(479:8) {#if !context.readOnly && isSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !selection.edit && isEqual(selection.focusPath, path)}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let validationerroricon;
  let current;
  validationerroricon = new ValidationErrorIcon_default({
    props: {
      validationError: ctx[15],
      onExpand: ctx[22]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(validationerroricon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(validationerroricon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(validationerroricon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const validationerroricon_changes = {};
      if (dirty[0] & 32768)
        validationerroricon_changes.validationError = ctx2[15];
      validationerroricon.$set(validationerroricon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(validationerroricon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(validationerroricon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(validationerroricon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(485:6) {#if validationError && (!expanded || !validationError.isChildError)}",
    ctx
  });
  return block;
}
function create_else_block8(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-selection-area jse-after svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-after");
      add_location(div, file25, 496, 8, 21067);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[30], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(495:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-selection-area jse-inside svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-inside");
      add_location(div, file25, 489, 8, 20818);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[29], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(488:6) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let div0;
  let show_if = !ctx[8].readOnly && (ctx[10] === HOVER_INSERT_INSIDE || ctx[16] && isInsideSelection(ctx[7]));
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div2;
  let div1;
  let span;
  let t2;
  let t3;
  let current;
  let if_block0 = show_if && create_if_block_52(ctx);
  let each_value = ctx[14] || DEFAULT_VISIBLE_SECTIONS;
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[49];
  validate_each_keys(ctx, each_value, get_each_context10, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context10(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block10(key, child_ctx));
  }
  let if_block1 = !ctx[17] && create_if_block_35(ctx);
  const block = {
    c: function create() {
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      span = element("span");
      t2 = text("]");
      t3 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { "data-type": true, class: true });
      var div1_nodes = children(div1);
      span = claim_element(div1_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, "]");
      span_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      if (if_block1)
        if_block1.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-items svelte-mirq6d");
      add_location(div0, file25, 504, 6, 21274);
      attr_dev(span, "class", "jse-bracket svelte-mirq6d");
      add_location(span, file25, 554, 10, 23519);
      attr_dev(div1, "data-type", "selectable-value");
      attr_dev(div1, "class", "jse-footer svelte-mirq6d");
      add_location(div1, file25, 553, 8, 23455);
      attr_dev(div2, "class", "jse-footer-outer svelte-mirq6d");
      attr_dev(div2, "style", ctx[18]);
      add_location(div2, file25, 552, 6, 23391);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, span);
      append_hydration_dev(span, t2);
      append_hydration_dev(div2, t3);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 66944)
        show_if = !ctx2[8].readOnly && (ctx2[10] === HOVER_INSERT_INSIDE || ctx2[16] && isInsideSelection(ctx2[7]));
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 66944) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & 68176895) {
        each_value = ctx2[14] || DEFAULT_VISIBLE_SECTIONS;
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context10, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block10, null, get_each_context10);
        check_outros();
      }
      if (!ctx2[17]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_35(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[0] & 262144) {
        attr_dev(div2, "style", ctx2[18]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div0);
      if (if_block0)
        if_block0.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(div2);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(504:4) {#if expanded}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let div;
  let contextmenubutton;
  let div_style_value;
  let current;
  contextmenubutton = new ContextMenuButton_default({
    props: {
      selected: ctx[16] && isInsideSelection(ctx[7]),
      onContextMenu: ctx[31]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(contextmenubutton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-type": true,
        style: true,
        title: true
      });
      var div_nodes = children(div);
      claim_component(contextmenubutton.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-area jse-inside svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-inside");
      attr_dev(div, "style", div_style_value = getIndentationStyle2(ctx[1].length + 1));
      attr_dev(div, "title", INSERT_EXPLANATION);
      toggle_class(div, "jse-hovered", ctx[10] === HOVER_INSERT_INSIDE);
      toggle_class(div, "jse-selected", ctx[16] && isInsideSelection(ctx[7]));
      add_location(div, file25, 506, 10, 21423);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(contextmenubutton, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextmenubutton_changes = {};
      if (dirty[0] & 65664)
        contextmenubutton_changes.selected = ctx2[16] && isInsideSelection(ctx2[7]);
      contextmenubutton.$set(contextmenubutton_changes);
      if (!current || dirty[0] & 2 && div_style_value !== (div_style_value = getIndentationStyle2(ctx2[1].length + 1))) {
        attr_dev(div, "style", div_style_value);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(div, "jse-hovered", ctx2[10] === HOVER_INSERT_INSIDE);
      }
      if (!current || dirty[0] & 65664) {
        toggle_class(div, "jse-selected", ctx2[16] && isInsideSelection(ctx2[7]));
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextmenubutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextmenubutton.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(contextmenubutton);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(506:8) {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isSelected && isInsideSelection(selection)))}",
    ctx
  });
  return block;
}
function create_identifier_slot(ctx) {
  let div1;
  let div0;
  let t_value = ctx[50].index + "";
  let t;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { slot: true, class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t = claim_text(div0_nodes, t_value);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-index svelte-mirq6d");
      add_location(div0, file25, 535, 16, 22872);
      attr_dev(div1, "slot", "identifier");
      attr_dev(div1, "class", "jse-identifier svelte-mirq6d");
      add_location(div1, file25, 534, 14, 22809);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 18687 && t_value !== (t_value = ctx2[50].index + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_identifier_slot.name,
    type: "slot",
    source: "(535:14) ",
    ctx
  });
  return block;
}
function create_each_block_12(key_1, ctx) {
  let first;
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: ctx[50].value,
      path: ctx[50].path,
      expandedMap: ctx[50].expandedMap,
      enforceStringMap: ctx[50].enforceStringMap,
      visibleSectionsMap: ctx[50].visibleSectionsMap,
      validationErrorsMap: ctx[50].validationErrorsMap,
      searchResultItemsMap: ctx[50].searchResultItemsMap,
      selection: ctx[50].selection,
      context: ctx[8],
      onDragSelectionStart: ctx[26],
      $$slots: { identifier: [create_identifier_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(jsonnode.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(jsonnode.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const jsonnode_changes = {};
      if (dirty[0] & 18687)
        jsonnode_changes.value = ctx[50].value;
      if (dirty[0] & 18687)
        jsonnode_changes.path = ctx[50].path;
      if (dirty[0] & 18687)
        jsonnode_changes.expandedMap = ctx[50].expandedMap;
      if (dirty[0] & 18687)
        jsonnode_changes.enforceStringMap = ctx[50].enforceStringMap;
      if (dirty[0] & 18687)
        jsonnode_changes.visibleSectionsMap = ctx[50].visibleSectionsMap;
      if (dirty[0] & 18687)
        jsonnode_changes.validationErrorsMap = ctx[50].validationErrorsMap;
      if (dirty[0] & 18687)
        jsonnode_changes.searchResultItemsMap = ctx[50].searchResultItemsMap;
      if (dirty[0] & 18687)
        jsonnode_changes.selection = ctx[50].selection;
      if (dirty[0] & 256)
        jsonnode_changes.context = ctx[8];
      if (dirty[0] & 18687 | dirty[1] & 16) {
        jsonnode_changes.$$scope = { dirty, ctx };
      }
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(522:10) {#each getItems(path, value, visibleSection, expandedMap, enforceStringMap, visibleSectionsMap, validationErrorsMap, searchResultItemsMap, selection, dragging) as item (item.index)}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let collapseditems;
  let current;
  collapseditems = new CollapsedItems_default({
    props: {
      visibleSections: ctx[14] || DEFAULT_VISIBLE_SECTIONS,
      sectionIndex: ctx[49],
      total: ctx[0].length,
      path: ctx[1],
      pointer: ctx[9],
      onExpandSection: ctx[8].onExpandSection,
      selection: ctx[7]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(collapseditems.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collapseditems.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collapseditems, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const collapseditems_changes = {};
      if (dirty[0] & 16384)
        collapseditems_changes.visibleSections = ctx2[14] || DEFAULT_VISIBLE_SECTIONS;
      if (dirty[0] & 16384)
        collapseditems_changes.sectionIndex = ctx2[49];
      if (dirty[0] & 1)
        collapseditems_changes.total = ctx2[0].length;
      if (dirty[0] & 2)
        collapseditems_changes.path = ctx2[1];
      if (dirty[0] & 512)
        collapseditems_changes.pointer = ctx2[9];
      if (dirty[0] & 256)
        collapseditems_changes.onExpandSection = ctx2[8].onExpandSection;
      if (dirty[0] & 128)
        collapseditems_changes.selection = ctx2[7];
      collapseditems.$set(collapseditems_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapseditems.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapseditems.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(collapseditems, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(540:10) {#if visibleSection.end < value.length}",
    ctx
  });
  return block;
}
function create_each_block10(key_1, ctx) {
  let first;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let if_block_anchor;
  let current;
  let each_value_1 = ctx[20](ctx[1], ctx[0], ctx[47], ctx[2], ctx[3], ctx[4], ctx[5], ctx[6], ctx[7], ctx[11]);
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[50].index;
  validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_12(key, child_ctx));
  }
  let if_block = ctx[47].end < ctx[0].length && create_if_block_42(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 68176383) {
        each_value_1 = ctx[20](ctx[1], ctx[0], ctx[47], ctx[2], ctx[3], ctx[4], ctx[5], ctx[6], ctx[7], ctx[11]);
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block_12, t, get_each_context_12);
        check_outros();
      }
      if (ctx[47].end < ctx[0].length) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 16385) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_42(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(first);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block10.name,
    type: "each",
    source: "(521:8) {#each visibleSections || DEFAULT_VISIBLE_SECTIONS as visibleSection, sectionIndex (sectionIndex)}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-type": true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-selection-area jse-after svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-after");
      add_location(div, file25, 558, 10, 23666);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[30], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(557:8) {#if !root}",
    ctx
  });
  return block;
}
function create_if_block14(ctx) {
  let div;
  let contextmenubutton;
  let current;
  contextmenubutton = new ContextMenuButton_default({
    props: {
      selected: ctx[16] && isAfterSelection(ctx[7]),
      onContextMenu: ctx[32]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(contextmenubutton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-type": true,
        style: true,
        title: true
      });
      var div_nodes = children(div);
      claim_component(contextmenubutton.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-insert-area jse-after svelte-mirq6d");
      attr_dev(div, "data-type", "insert-selection-area-after");
      attr_dev(div, "style", ctx[18]);
      attr_dev(div, "title", INSERT_EXPLANATION);
      toggle_class(div, "jse-hovered", ctx[10] === HOVER_INSERT_AFTER);
      toggle_class(div, "jse-selected", ctx[16] && isAfterSelection(ctx[7]));
      add_location(div, file25, 718, 4, 29819);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(contextmenubutton, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextmenubutton_changes = {};
      if (dirty[0] & 65664)
        contextmenubutton_changes.selected = ctx2[16] && isAfterSelection(ctx2[7]);
      contextmenubutton.$set(contextmenubutton_changes);
      if (!current || dirty[0] & 262144) {
        attr_dev(div, "style", ctx2[18]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(div, "jse-hovered", ctx2[10] === HOVER_INSERT_AFTER);
      }
      if (!current || dirty[0] & 65664) {
        toggle_class(div, "jse-selected", ctx2[16] && isAfterSelection(ctx2[7]));
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextmenubutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextmenubutton.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(contextmenubutton);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(718:2) {#if !context.readOnly && (hover === HOVER_INSERT_AFTER || (isSelected && isAfterSelection(selection)))}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let div;
  let show_if_1;
  let show_if_2;
  let current_block_type_index;
  let if_block0;
  let t;
  let show_if = !ctx[8].readOnly && (ctx[10] === HOVER_INSERT_AFTER || ctx[16] && isAfterSelection(ctx[7]));
  let div_class_value;
  let div_data_path_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_19, create_if_block_122, create_else_block_5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & 1)
      show_if_1 = null;
    if (dirty[0] & 1)
      show_if_2 = null;
    if (show_if_1 == null)
      show_if_1 = !!Array.isArray(ctx2[0]);
    if (show_if_1)
      return 0;
    if (show_if_2 == null)
      show_if_2 = !!isObject(ctx2[0]);
    if (show_if_2)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = show_if && create_if_block14(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-path": true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty((0, import_classnames3.default)("jse-json-node", { "jse-expanded": ctx[12] }, ctx[8].onClassName(ctx[1], ctx[0]))) + " svelte-mirq6d");
      attr_dev(div, "data-path", div_data_path_value = encodeDataPath(ctx[1]));
      toggle_class(div, "jse-root", ctx[17]);
      toggle_class(div, "jse-selected", ctx[16] && isMultiSelection(ctx[7]));
      toggle_class(div, "jse-selected-key", ctx[16] && isKeySelection(ctx[7]));
      toggle_class(div, "jse-selected-value", ctx[16] && isValueSelection(ctx[7]));
      toggle_class(div, "jse-readonly", ctx[8].readOnly);
      toggle_class(div, "jse-hovered", ctx[10] === HOVER_COLLECTION);
      add_location(div, file25, 421, 0, 18263);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "mousedown", ctx[24], false, false, false),
          listen_dev(div, "mousemove", ctx[25], false, false, false),
          listen_dev(div, "mouseover", ctx[27], false, false, false),
          listen_dev(div, "mouseout", ctx[28], false, false, false),
          listen_dev(div, "focus", void 0, false, false, false),
          listen_dev(div, "blur", void 0, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (dirty[0] & 66944)
        show_if = !ctx2[8].readOnly && (ctx2[10] === HOVER_INSERT_AFTER || ctx2[16] && isAfterSelection(ctx2[7]));
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 66944) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block14(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 4355 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames3.default)("jse-json-node", { "jse-expanded": ctx2[12] }, ctx2[8].onClassName(ctx2[1], ctx2[0]))) + " svelte-mirq6d")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & 2 && div_data_path_value !== (div_data_path_value = encodeDataPath(ctx2[1]))) {
        attr_dev(div, "data-path", div_data_path_value);
      }
      if (!current || dirty[0] & 135427) {
        toggle_class(div, "jse-root", ctx2[17]);
      }
      if (!current || dirty[0] & 70019) {
        toggle_class(div, "jse-selected", ctx2[16] && isMultiSelection(ctx2[7]));
      }
      if (!current || dirty[0] & 70019) {
        toggle_class(div, "jse-selected-key", ctx2[16] && isKeySelection(ctx2[7]));
      }
      if (!current || dirty[0] & 70019) {
        toggle_class(div, "jse-selected-value", ctx2[16] && isValueSelection(ctx2[7]));
      }
      if (!current || dirty[0] & 4355) {
        toggle_class(div, "jse-readonly", ctx2[8].readOnly);
      }
      if (!current || dirty[0] & 5379) {
        toggle_class(div, "jse-hovered", ctx2[10] === HOVER_COLLECTION);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getIndentationStyle2(level) {
  return `margin-left: calc(${level} * var(--jse-indent-size))`;
}
function instance29($$self, $$props, $$invalidate) {
  let root;
  let indentationStyle;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JSONNode", slots, ["identifier"]);
  let { value } = $$props;
  let { path } = $$props;
  let { expandedMap } = $$props;
  let { enforceStringMap } = $$props;
  let { visibleSectionsMap } = $$props;
  let { validationErrorsMap } = $$props;
  let { searchResultItemsMap } = $$props;
  let { selection } = $$props;
  let { context } = $$props;
  let { onDragSelectionStart } = $$props;
  const debug5 = createDebug("jsoneditor:JSONNode");
  let hover = void 0;
  let hoverTimer = void 0;
  let dragging = void 0;
  const memoizePath = createMemoizePath();
  let pointer;
  let expanded;
  let enforceString;
  let visibleSections;
  let validationError;
  let isSelected;
  function getProps(path2, object, expandedMap2, enforceStringMap2, visibleSectionsMap2, validationErrorsMap2, searchResultItemsMap2, selection2, dragging2) {
    let props = Object.keys(object).map((key) => {
      const keyPointer = appendToJSONPointer(pointer, key);
      return {
        key,
        value: object[key],
        path: memoizePath(path2.concat(key)),
        pointer: keyPointer,
        expandedMap: filterPointerOrUndefined(expandedMap2, keyPointer),
        enforceStringMap: filterPointerOrUndefined(enforceStringMap2, keyPointer),
        visibleSectionsMap: filterPointerOrUndefined(visibleSectionsMap2, keyPointer),
        validationErrorsMap: filterPointerOrUndefined(validationErrorsMap2, keyPointer),
        keySearchResultItemsMap: filterKeySearchResults(searchResultItemsMap2, keyPointer),
        valueSearchResultItemsMap: filterPointerOrUndefined(searchResultItemsMap2, keyPointer),
        selection: selectionIfOverlapping(selection2, keyPointer)
      };
    });
    if (dragging2 && dragging2.offset !== 0) {
      props = moveItems(props, dragging2.selectionStartIndex, dragging2.selectionItemsCount, dragging2.offset);
    }
    return props;
  }
  function getItems(path2, array, visibleSection, expandedMap2, enforceStringMap2, visibleSectionsMap2, validationErrorsMap2, searchResultItemsMap2, selection2, dragging2) {
    const start = visibleSection.start;
    const end = Math.min(visibleSection.end, array.length);
    let items = [];
    for (let index = start; index < end; index++) {
      const itemPointer = appendToJSONPointer(pointer, index);
      items.push({
        index,
        value: array[index],
        path: memoizePath(path2.concat(String(index))),
        pointer: itemPointer,
        expandedMap: filterPointerOrUndefined(expandedMap2, itemPointer),
        enforceStringMap: filterPointerOrUndefined(enforceStringMap2, itemPointer),
        visibleSectionsMap: filterPointerOrUndefined(visibleSectionsMap2, itemPointer),
        validationErrorsMap: filterPointerOrUndefined(validationErrorsMap2, itemPointer),
        searchResultItemsMap: filterPointerOrUndefined(searchResultItemsMap2, itemPointer),
        selection: selectionIfOverlapping(selection2, itemPointer)
      });
    }
    if (dragging2 && dragging2.offset !== 0) {
      const originalIndexes = items.map((item) => item.index);
      items = moveItems(items, dragging2.selectionStartIndex, dragging2.selectionItemsCount, dragging2.offset);
      for (let i = 0; i < items.length; i++) {
        items[i].index = originalIndexes[i];
      }
    }
    return items;
  }
  function toggleExpand(event) {
    event.stopPropagation();
    const recursive = event.ctrlKey;
    context.onExpand(path, !expanded, recursive);
  }
  function handleExpand(event) {
    event.stopPropagation();
    context.onExpand(path, true);
  }
  function handleUpdateKey(oldKey, newKey) {
    const operations = rename(path, Object.keys(value), oldKey, newKey);
    context.onPatch(operations);
    const newKeyUnique = last_default(parseJSONPointer(operations[0].path));
    return newKeyUnique;
  }
  function handleMouseDown2(event) {
    if (isContentEditableDiv(event.target) || event.which === 1 && isChildOfNodeName(event.target, "BUTTON")) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    document.addEventListener("mousemove", handleMouseMoveGlobal, true);
    document.addEventListener("mouseup", handleMouseUpGlobal);
    const anchorType = getSelectionTypeFromTarget(event.target);
    const json2 = context.getJson();
    const documentState = context.getDocumentState();
    if (isPathInsideSelection(selection, path, anchorType)) {
      if (event.button === 0) {
        onDragSelectionStart(event);
      }
      return;
    }
    singleton2.selecting = true;
    singleton2.selectionAnchor = path;
    singleton2.selectionAnchorType = anchorType;
    singleton2.selectionFocus = path;
    if (event.shiftKey) {
      if (selection) {
        context.onSelect(createMultiSelection(json2, selection.anchorPath, path));
      }
    } else {
      if (anchorType === SelectionType.multi) {
        if (root && event.target.hasAttribute("data-path")) {
          const lastCaretPosition = last_default(getVisibleCaretPositions(value, documentState));
          context.onSelect(fromCaretPosition(lastCaretPosition));
        } else {
          context.onSelect(createMultiSelection(json2, path, path));
        }
      } else {
        context.onSelect(fromSelectionType(json2, anchorType, path));
      }
    }
    context.focus();
  }
  function handleMouseMove2(event) {
    if (singleton2.selecting) {
      event.preventDefault();
      event.stopPropagation();
      if (singleton2.selectionFocus == null) {
        if (window.getSelection) {
          window.getSelection().empty();
        }
      }
      const selectionType = getSelectionTypeFromTarget(event.target);
      if (!isEqual_default(path, singleton2.selectionFocus) || selectionType !== singleton2.selectionAnchorType) {
        singleton2.selectionFocus = path;
        singleton2.selectionAnchorType = selectionType;
        const json2 = context.getJson();
        context.onSelect(createMultiSelection(json2, singleton2.selectionAnchor, singleton2.selectionFocus));
      }
    }
  }
  function handleMouseMoveGlobal(event) {
    context.onDrag(event);
  }
  function handleMouseUpGlobal(event) {
    if (singleton2.selecting) {
      singleton2.selecting = false;
      event.stopPropagation();
    }
    context.onDragEnd();
    document.removeEventListener("mousemove", handleMouseMoveGlobal, true);
    document.removeEventListener("mouseup", handleMouseUpGlobal);
  }
  function findContentTop() {
    var _a, _b;
    return ((_b = (_a = context.findElement([])) == null ? void 0 : _a.getBoundingClientRect()) == null ? void 0 : _b.top) || 0;
  }
  function calculateDeltaY(dragging2, event) {
    const contentTop = findContentTop();
    const contentOffset = contentTop - dragging2.initialContentTop;
    const clientOffset = event.clientY - dragging2.initialClientY;
    return clientOffset - contentOffset;
  }
  function handleDragSelectionStart(event) {
    if (context.readOnly) {
      return;
    }
    const selectionParentPath = initial_default(selection.focusPath);
    if (!isEqual_default(path, selectionParentPath)) {
      onDragSelectionStart(event);
      return;
    }
    const items = getVisibleItemsWithHeights(selection, visibleSections || DEFAULT_VISIBLE_SECTIONS);
    debug5("dragSelectionStart", { selection, items });
    if (!items) {
      debug5("Cannot drag the current selection (probably spread over multiple sections)");
      return;
    }
    const initialPath = getStartPath(selection);
    const selectionStartIndex = items.findIndex((item) => isEqual_default(item.path, initialPath));
    const json2 = context.getJson();
    const documentState = context.getDocumentState();
    const { offset } = onMoveSelection({ json: json2, documentState, deltaY: 0, items });
    $$invalidate(11, dragging = {
      initialTarget: event.target,
      initialClientY: event.clientY,
      initialContentTop: findContentTop(),
      selectionStartIndex,
      selectionItemsCount: getSelectionPaths(selection).length,
      items,
      offset,
      didMoveItems: false
    });
    singleton2.dragging = true;
    document.addEventListener("mousemove", handleDragSelection, true);
    document.addEventListener("mouseup", handleDragSelectionEnd);
  }
  function handleDragSelection(event) {
    if (dragging) {
      const json2 = context.getJson();
      const documentState = context.getDocumentState();
      const deltaY = calculateDeltaY(dragging, event);
      const { offset } = onMoveSelection({
        json: json2,
        documentState,
        deltaY,
        items: dragging.items
      });
      if (offset !== dragging.offset) {
        debug5("drag selection", offset, deltaY);
        $$invalidate(11, dragging = { ...dragging, offset, didMoveItems: true });
      }
    }
  }
  function handleDragSelectionEnd(event) {
    if (dragging) {
      const json2 = context.getJson();
      const documentState = context.getDocumentState();
      const deltaY = calculateDeltaY(dragging, event);
      const { operations, updatedSelection } = onMoveSelection({
        json: json2,
        documentState,
        deltaY,
        items: dragging.items
      });
      if (operations) {
        context.onPatch(operations, (patchedJson, patchedState) => ({
          state: {
            ...patchedState,
            selection: updatedSelection || selection
          }
        }));
      } else {
        if (event.target === dragging.initialTarget && !dragging.didMoveItems) {
          const selectionType = getSelectionTypeFromTarget(event.target);
          const path2 = getDataPathFromTarget(event.target);
          if (path2) {
            context.onSelect(fromSelectionType(json2, selectionType, path2));
          }
        }
      }
      $$invalidate(11, dragging = void 0);
      singleton2.dragging = false;
      document.removeEventListener("mousemove", handleDragSelection, true);
      document.removeEventListener("mouseup", handleDragSelectionEnd);
    }
  }
  function getVisibleItemsWithHeights(selection2, visibleSections2) {
    const items = [];
    function addHeight(prop) {
      const itemPath = path.concat(prop);
      const element2 = context.findElement(itemPath);
      if (element2 != null) {
        items.push({
          path: itemPath,
          height: element2.clientHeight
        });
      }
    }
    if (Array.isArray(value)) {
      const startPath = getStartPath(selection2);
      const endPath = getEndPath(selection2);
      const startIndex = last_default(startPath);
      const endIndex = last_default(endPath);
      const currentSection = visibleSections2.find((visibleSection) => {
        return startIndex >= visibleSection.start && endIndex <= visibleSection.end;
      });
      if (!currentSection) {
        return null;
      }
      const { start, end } = currentSection;
      forEachIndex(start, Math.min(value.length, end), (index) => addHeight(String(index)));
    } else {
      Object.keys(value).forEach(addHeight);
    }
    return items;
  }
  function handleMouseOver(event) {
    if (singleton2.selecting || singleton2.dragging) {
      return;
    }
    event.stopPropagation();
    if (isChildOfAttribute(event.target, "data-type", "selectable-value")) {
      $$invalidate(10, hover = HOVER_COLLECTION);
    } else if (isChildOfAttribute(event.target, "data-type", "insert-selection-area-inside")) {
      $$invalidate(10, hover = HOVER_INSERT_INSIDE);
    } else if (isChildOfAttribute(event.target, "data-type", "insert-selection-area-after")) {
      $$invalidate(10, hover = HOVER_INSERT_AFTER);
    }
    clearTimeout(hoverTimer);
  }
  function handleMouseOut(event) {
    event.stopPropagation();
    hoverTimer = setTimeout(() => $$invalidate(10, hover = void 0));
  }
  function handleInsertInside(event) {
    if (!event.shiftKey) {
      event.stopPropagation();
      event.preventDefault();
      context.onSelect(createInsideSelection(path));
    }
  }
  function handleInsertAfter(event) {
    if (!event.shiftKey) {
      event.stopPropagation();
      event.preventDefault();
      context.onSelect(createAfterSelection(path));
    }
  }
  function handleInsertInsideOpenContextMenu(props) {
    context.onSelect(createInsideSelection(path));
    context.onContextMenu(props);
  }
  function handleInsertAfterOpenContextMenu(props) {
    context.onSelect(createAfterSelection(path));
    context.onContextMenu(props);
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<JSONNode> was created without expected prop 'value'");
    }
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<JSONNode> was created without expected prop 'path'");
    }
    if (expandedMap === void 0 && !("expandedMap" in $$props || $$self.$$.bound[$$self.$$.props["expandedMap"]])) {
      console.warn("<JSONNode> was created without expected prop 'expandedMap'");
    }
    if (enforceStringMap === void 0 && !("enforceStringMap" in $$props || $$self.$$.bound[$$self.$$.props["enforceStringMap"]])) {
      console.warn("<JSONNode> was created without expected prop 'enforceStringMap'");
    }
    if (visibleSectionsMap === void 0 && !("visibleSectionsMap" in $$props || $$self.$$.bound[$$self.$$.props["visibleSectionsMap"]])) {
      console.warn("<JSONNode> was created without expected prop 'visibleSectionsMap'");
    }
    if (validationErrorsMap === void 0 && !("validationErrorsMap" in $$props || $$self.$$.bound[$$self.$$.props["validationErrorsMap"]])) {
      console.warn("<JSONNode> was created without expected prop 'validationErrorsMap'");
    }
    if (searchResultItemsMap === void 0 && !("searchResultItemsMap" in $$props || $$self.$$.bound[$$self.$$.props["searchResultItemsMap"]])) {
      console.warn("<JSONNode> was created without expected prop 'searchResultItemsMap'");
    }
    if (selection === void 0 && !("selection" in $$props || $$self.$$.bound[$$self.$$.props["selection"]])) {
      console.warn("<JSONNode> was created without expected prop 'selection'");
    }
    if (context === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<JSONNode> was created without expected prop 'context'");
    }
    if (onDragSelectionStart === void 0 && !("onDragSelectionStart" in $$props || $$self.$$.bound[$$self.$$.props["onDragSelectionStart"]])) {
      console.warn("<JSONNode> was created without expected prop 'onDragSelectionStart'");
    }
  });
  const writable_props = [
    "value",
    "path",
    "expandedMap",
    "enforceStringMap",
    "visibleSectionsMap",
    "validationErrorsMap",
    "searchResultItemsMap",
    "selection",
    "context",
    "onDragSelectionStart"
  ];
  Object_14.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<JSONNode> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("path" in $$props2)
      $$invalidate(1, path = $$props2.path);
    if ("expandedMap" in $$props2)
      $$invalidate(2, expandedMap = $$props2.expandedMap);
    if ("enforceStringMap" in $$props2)
      $$invalidate(3, enforceStringMap = $$props2.enforceStringMap);
    if ("visibleSectionsMap" in $$props2)
      $$invalidate(4, visibleSectionsMap = $$props2.visibleSectionsMap);
    if ("validationErrorsMap" in $$props2)
      $$invalidate(5, validationErrorsMap = $$props2.validationErrorsMap);
    if ("searchResultItemsMap" in $$props2)
      $$invalidate(6, searchResultItemsMap = $$props2.searchResultItemsMap);
    if ("selection" in $$props2)
      $$invalidate(7, selection = $$props2.selection);
    if ("context" in $$props2)
      $$invalidate(8, context = $$props2.context);
    if ("onDragSelectionStart" in $$props2)
      $$invalidate(33, onDragSelectionStart = $$props2.onDragSelectionStart);
    if ("$$scope" in $$props2)
      $$invalidate(35, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    faCaretDown,
    faCaretRight,
    classnames: import_classnames3.default,
    appendToJSONPointer,
    compileJSONPointer,
    parseJSONPointer,
    initial: initial_default,
    isEqual: isEqual_default,
    last: last_default,
    Icon: Icon_default,
    DEFAULT_VISIBLE_SECTIONS,
    HOVER_COLLECTION,
    HOVER_INSERT_AFTER,
    HOVER_INSERT_INSIDE,
    INSERT_EXPLANATION,
    getVisibleCaretPositions,
    rename,
    createAfterSelection,
    createInsideSelection,
    createMultiSelection,
    fromCaretPosition,
    fromSelectionType,
    getEndPath,
    getSelectionPaths,
    isInsideSelection,
    isKeySelection,
    isPathInsideSelection,
    isValueSelection,
    encodeDataPath,
    getDataPathFromTarget,
    getSelectionTypeFromTarget,
    isChildOfAttribute,
    isChildOfNodeName,
    isContentEditableDiv,
    CollapsedItems: CollapsedItems_default,
    ContextMenuButton: ContextMenuButton_default,
    JSONKey: JSONKey_default,
    JSONValue: JSONValue_default,
    singleton: singleton2,
    createDebug,
    onMoveSelection,
    forEachIndex,
    moveItems,
    SelectionType,
    getStartPath,
    isAfterSelection,
    isMultiSelection,
    selectionIfOverlapping,
    filterPointerOrUndefined,
    filterKeySearchResults,
    filterValueSearchResults,
    createMemoizePath,
    getEnforceString,
    ValidationErrorIcon: ValidationErrorIcon_default,
    isObject,
    value,
    path,
    expandedMap,
    enforceStringMap,
    visibleSectionsMap,
    validationErrorsMap,
    searchResultItemsMap,
    selection,
    context,
    onDragSelectionStart,
    debug: debug5,
    hover,
    hoverTimer,
    dragging,
    memoizePath,
    pointer,
    expanded,
    enforceString,
    visibleSections,
    validationError,
    isSelected,
    getIndentationStyle: getIndentationStyle2,
    getProps,
    getItems,
    toggleExpand,
    handleExpand,
    handleUpdateKey,
    handleMouseDown: handleMouseDown2,
    handleMouseMove: handleMouseMove2,
    handleMouseMoveGlobal,
    handleMouseUpGlobal,
    findContentTop,
    calculateDeltaY,
    handleDragSelectionStart,
    handleDragSelection,
    handleDragSelectionEnd,
    getVisibleItemsWithHeights,
    handleMouseOver,
    handleMouseOut,
    handleInsertInside,
    handleInsertAfter,
    handleInsertInsideOpenContextMenu,
    handleInsertAfterOpenContextMenu,
    root,
    indentationStyle
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("path" in $$props2)
      $$invalidate(1, path = $$props2.path);
    if ("expandedMap" in $$props2)
      $$invalidate(2, expandedMap = $$props2.expandedMap);
    if ("enforceStringMap" in $$props2)
      $$invalidate(3, enforceStringMap = $$props2.enforceStringMap);
    if ("visibleSectionsMap" in $$props2)
      $$invalidate(4, visibleSectionsMap = $$props2.visibleSectionsMap);
    if ("validationErrorsMap" in $$props2)
      $$invalidate(5, validationErrorsMap = $$props2.validationErrorsMap);
    if ("searchResultItemsMap" in $$props2)
      $$invalidate(6, searchResultItemsMap = $$props2.searchResultItemsMap);
    if ("selection" in $$props2)
      $$invalidate(7, selection = $$props2.selection);
    if ("context" in $$props2)
      $$invalidate(8, context = $$props2.context);
    if ("onDragSelectionStart" in $$props2)
      $$invalidate(33, onDragSelectionStart = $$props2.onDragSelectionStart);
    if ("hover" in $$props2)
      $$invalidate(10, hover = $$props2.hover);
    if ("hoverTimer" in $$props2)
      hoverTimer = $$props2.hoverTimer;
    if ("dragging" in $$props2)
      $$invalidate(11, dragging = $$props2.dragging);
    if ("pointer" in $$props2)
      $$invalidate(9, pointer = $$props2.pointer);
    if ("expanded" in $$props2)
      $$invalidate(12, expanded = $$props2.expanded);
    if ("enforceString" in $$props2)
      $$invalidate(13, enforceString = $$props2.enforceString);
    if ("visibleSections" in $$props2)
      $$invalidate(14, visibleSections = $$props2.visibleSections);
    if ("validationError" in $$props2)
      $$invalidate(15, validationError = $$props2.validationError);
    if ("isSelected" in $$props2)
      $$invalidate(16, isSelected = $$props2.isSelected);
    if ("root" in $$props2)
      $$invalidate(17, root = $$props2.root);
    if ("indentationStyle" in $$props2)
      $$invalidate(18, indentationStyle = $$props2.indentationStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(9, pointer = compileJSONPointer(path));
    }
    if ($$self.$$.dirty[0] & 516) {
      $:
        $$invalidate(12, expanded = expandedMap ? expandedMap[pointer] === true : false);
    }
    if ($$self.$$.dirty[0] & 777) {
      $:
        $$invalidate(13, enforceString = getEnforceString(value, enforceStringMap, pointer, context.parser));
    }
    if ($$self.$$.dirty[0] & 528) {
      $:
        $$invalidate(14, visibleSections = visibleSectionsMap ? visibleSectionsMap[pointer] : void 0);
    }
    if ($$self.$$.dirty[0] & 544) {
      $:
        $$invalidate(15, validationError = validationErrorsMap ? validationErrorsMap[pointer] : void 0);
    }
    if ($$self.$$.dirty[0] & 640) {
      $:
        $$invalidate(16, isSelected = selection ? selection.pointersMap[pointer] === true : false);
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(17, root = path.length === 0);
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(18, indentationStyle = getIndentationStyle2(path.length));
    }
  };
  return [
    value,
    path,
    expandedMap,
    enforceStringMap,
    visibleSectionsMap,
    validationErrorsMap,
    searchResultItemsMap,
    selection,
    context,
    pointer,
    hover,
    dragging,
    expanded,
    enforceString,
    visibleSections,
    validationError,
    isSelected,
    root,
    indentationStyle,
    getProps,
    getItems,
    toggleExpand,
    handleExpand,
    handleUpdateKey,
    handleMouseDown2,
    handleMouseMove2,
    handleDragSelectionStart,
    handleMouseOver,
    handleMouseOut,
    handleInsertInside,
    handleInsertAfter,
    handleInsertInsideOpenContextMenu,
    handleInsertAfterOpenContextMenu,
    onDragSelectionStart,
    slots,
    $$scope
  ];
}
var JSONNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance29,
      create_fragment29,
      not_equal,
      {
        value: 0,
        path: 1,
        expandedMap: 2,
        enforceStringMap: 3,
        visibleSectionsMap: 4,
        validationErrorsMap: 5,
        searchResultItemsMap: 6,
        selection: 7,
        context: 8,
        onDragSelectionStart: 33
      },
      add_css22,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONNode",
      options,
      id: create_fragment29.name
    });
  }
  get value() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandedMap() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedMap(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enforceStringMap() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enforceStringMap(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visibleSectionsMap() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visibleSectionsMap(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationErrorsMap() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationErrorsMap(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchResultItemsMap() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchResultItemsMap(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDragSelectionStart() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDragSelectionStart(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JSONNode_default = JSONNode;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/menu/TreeMenu.svelte
function create_fragment30(ctx) {
  let menu;
  let current;
  menu = new Menu_default({
    props: { items: ctx[0] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(menu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(menu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 1)
        menu_changes.items = ctx2[0];
      menu.$set(menu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(menu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let hasJson;
  let hasSelection;
  let hasSelectionContents;
  let expandMenuItem;
  let collapseMenuItem;
  let searchMenuItem;
  let defaultItems;
  let items;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeMenu", slots, []);
  let { json: json2 } = $$props;
  let { selection } = $$props;
  let { readOnly } = $$props;
  let { showSearch = false } = $$props;
  let { historyState } = $$props;
  let { onExpandAll } = $$props;
  let { onCollapseAll } = $$props;
  let { onUndo } = $$props;
  let { onRedo } = $$props;
  let { onSort } = $$props;
  let { onTransform } = $$props;
  let { onContextMenu } = $$props;
  let { onCopy } = $$props;
  let { onRenderMenu = noop_default } = $$props;
  function handleToggleSearch() {
    $$invalidate(1, showSearch = !showSearch);
  }
  $$self.$$.on_mount.push(function() {
    if (json2 === void 0 && !("json" in $$props || $$self.$$.bound[$$self.$$.props["json"]])) {
      console.warn("<TreeMenu> was created without expected prop 'json'");
    }
    if (selection === void 0 && !("selection" in $$props || $$self.$$.bound[$$self.$$.props["selection"]])) {
      console.warn("<TreeMenu> was created without expected prop 'selection'");
    }
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console.warn("<TreeMenu> was created without expected prop 'readOnly'");
    }
    if (historyState === void 0 && !("historyState" in $$props || $$self.$$.bound[$$self.$$.props["historyState"]])) {
      console.warn("<TreeMenu> was created without expected prop 'historyState'");
    }
    if (onExpandAll === void 0 && !("onExpandAll" in $$props || $$self.$$.bound[$$self.$$.props["onExpandAll"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onExpandAll'");
    }
    if (onCollapseAll === void 0 && !("onCollapseAll" in $$props || $$self.$$.bound[$$self.$$.props["onCollapseAll"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onCollapseAll'");
    }
    if (onUndo === void 0 && !("onUndo" in $$props || $$self.$$.bound[$$self.$$.props["onUndo"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onUndo'");
    }
    if (onRedo === void 0 && !("onRedo" in $$props || $$self.$$.bound[$$self.$$.props["onRedo"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onRedo'");
    }
    if (onSort === void 0 && !("onSort" in $$props || $$self.$$.bound[$$self.$$.props["onSort"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onSort'");
    }
    if (onTransform === void 0 && !("onTransform" in $$props || $$self.$$.bound[$$self.$$.props["onTransform"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onTransform'");
    }
    if (onContextMenu === void 0 && !("onContextMenu" in $$props || $$self.$$.bound[$$self.$$.props["onContextMenu"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onContextMenu'");
    }
    if (onCopy === void 0 && !("onCopy" in $$props || $$self.$$.bound[$$self.$$.props["onCopy"]])) {
      console.warn("<TreeMenu> was created without expected prop 'onCopy'");
    }
  });
  const writable_props = [
    "json",
    "selection",
    "readOnly",
    "showSearch",
    "historyState",
    "onExpandAll",
    "onCollapseAll",
    "onUndo",
    "onRedo",
    "onSort",
    "onTransform",
    "onContextMenu",
    "onCopy",
    "onRenderMenu"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TreeMenu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(2, json2 = $$props2.json);
    if ("selection" in $$props2)
      $$invalidate(3, selection = $$props2.selection);
    if ("readOnly" in $$props2)
      $$invalidate(4, readOnly = $$props2.readOnly);
    if ("showSearch" in $$props2)
      $$invalidate(1, showSearch = $$props2.showSearch);
    if ("historyState" in $$props2)
      $$invalidate(5, historyState = $$props2.historyState);
    if ("onExpandAll" in $$props2)
      $$invalidate(6, onExpandAll = $$props2.onExpandAll);
    if ("onCollapseAll" in $$props2)
      $$invalidate(7, onCollapseAll = $$props2.onCollapseAll);
    if ("onUndo" in $$props2)
      $$invalidate(8, onUndo = $$props2.onUndo);
    if ("onRedo" in $$props2)
      $$invalidate(9, onRedo = $$props2.onRedo);
    if ("onSort" in $$props2)
      $$invalidate(10, onSort = $$props2.onSort);
    if ("onTransform" in $$props2)
      $$invalidate(11, onTransform = $$props2.onTransform);
    if ("onContextMenu" in $$props2)
      $$invalidate(12, onContextMenu = $$props2.onContextMenu);
    if ("onCopy" in $$props2)
      $$invalidate(13, onCopy = $$props2.onCopy);
    if ("onRenderMenu" in $$props2)
      $$invalidate(14, onRenderMenu = $$props2.onRenderMenu);
  };
  $$self.$capture_state = () => ({
    faCopy,
    faEllipsisV,
    faFilter,
    faRedo,
    faSearch,
    faSortAmountDownAlt,
    faUndo,
    CONTEXT_MENU_EXPLANATION,
    faJSONEditorCollapse,
    faJSONEditorExpand,
    isObjectOrArray,
    Menu: Menu_default,
    noop: noop_default,
    isKeySelection,
    isMultiSelection,
    isValueSelection,
    json: json2,
    selection,
    readOnly,
    showSearch,
    historyState,
    onExpandAll,
    onCollapseAll,
    onUndo,
    onRedo,
    onSort,
    onTransform,
    onContextMenu,
    onCopy,
    onRenderMenu,
    handleToggleSearch,
    defaultItems,
    items,
    searchMenuItem,
    hasSelectionContents,
    collapseMenuItem,
    expandMenuItem,
    hasJson,
    hasSelection
  });
  $$self.$inject_state = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(2, json2 = $$props2.json);
    if ("selection" in $$props2)
      $$invalidate(3, selection = $$props2.selection);
    if ("readOnly" in $$props2)
      $$invalidate(4, readOnly = $$props2.readOnly);
    if ("showSearch" in $$props2)
      $$invalidate(1, showSearch = $$props2.showSearch);
    if ("historyState" in $$props2)
      $$invalidate(5, historyState = $$props2.historyState);
    if ("onExpandAll" in $$props2)
      $$invalidate(6, onExpandAll = $$props2.onExpandAll);
    if ("onCollapseAll" in $$props2)
      $$invalidate(7, onCollapseAll = $$props2.onCollapseAll);
    if ("onUndo" in $$props2)
      $$invalidate(8, onUndo = $$props2.onUndo);
    if ("onRedo" in $$props2)
      $$invalidate(9, onRedo = $$props2.onRedo);
    if ("onSort" in $$props2)
      $$invalidate(10, onSort = $$props2.onSort);
    if ("onTransform" in $$props2)
      $$invalidate(11, onTransform = $$props2.onTransform);
    if ("onContextMenu" in $$props2)
      $$invalidate(12, onContextMenu = $$props2.onContextMenu);
    if ("onCopy" in $$props2)
      $$invalidate(13, onCopy = $$props2.onCopy);
    if ("onRenderMenu" in $$props2)
      $$invalidate(14, onRenderMenu = $$props2.onRenderMenu);
    if ("defaultItems" in $$props2)
      $$invalidate(15, defaultItems = $$props2.defaultItems);
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("searchMenuItem" in $$props2)
      $$invalidate(16, searchMenuItem = $$props2.searchMenuItem);
    if ("hasSelectionContents" in $$props2)
      $$invalidate(17, hasSelectionContents = $$props2.hasSelectionContents);
    if ("collapseMenuItem" in $$props2)
      $$invalidate(18, collapseMenuItem = $$props2.collapseMenuItem);
    if ("expandMenuItem" in $$props2)
      $$invalidate(19, expandMenuItem = $$props2.expandMenuItem);
    if ("hasJson" in $$props2)
      $$invalidate(20, hasJson = $$props2.hasJson);
    if ("hasSelection" in $$props2)
      hasSelection = $$props2.hasSelection;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(20, hasJson = json2 !== void 0);
    }
    if ($$self.$$.dirty & 8) {
      $:
        hasSelection = selection != null;
    }
    if ($$self.$$.dirty & 1048584) {
      $:
        $$invalidate(17, hasSelectionContents = hasJson && (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection)));
    }
    if ($$self.$$.dirty & 68) {
      $:
        $$invalidate(19, expandMenuItem = {
          icon: faJSONEditorExpand,
          title: "Expand all",
          className: "jse-expand-all",
          onClick: onExpandAll,
          disabled: !isObjectOrArray(json2)
        });
    }
    if ($$self.$$.dirty & 132) {
      $:
        $$invalidate(18, collapseMenuItem = {
          icon: faJSONEditorCollapse,
          title: "Collapse all",
          className: "jse-collapse-all",
          onClick: onCollapseAll,
          disabled: !isObjectOrArray(json2)
        });
    }
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(16, searchMenuItem = {
          icon: faSearch,
          title: "Search (Ctrl+F)",
          className: "jse-search",
          onClick: handleToggleSearch,
          disabled: json2 === void 0
        });
    }
    if ($$self.$$.dirty & 999220) {
      $:
        $$invalidate(15, defaultItems = !readOnly ? [
          expandMenuItem,
          collapseMenuItem,
          { separator: true },
          {
            icon: faSortAmountDownAlt,
            title: "Sort",
            className: "jse-sort",
            onClick: onSort,
            disabled: readOnly || json2 === void 0
          },
          {
            icon: faFilter,
            title: "Transform contents (filter, sort, project)",
            className: "jse-transform",
            onClick: onTransform,
            disabled: readOnly || json2 === void 0
          },
          searchMenuItem,
          {
            icon: faEllipsisV,
            title: CONTEXT_MENU_EXPLANATION,
            className: "jse-contextmenu",
            onClick: onContextMenu
          },
          { separator: true },
          {
            icon: faUndo,
            title: "Undo (Ctrl+Z)",
            className: "jse-undo",
            onClick: onUndo,
            disabled: !historyState.canUndo
          },
          {
            icon: faRedo,
            title: "Redo (Ctrl+Shift+Z)",
            className: "jse-redo",
            onClick: onRedo,
            disabled: !historyState.canRedo
          },
          { space: true }
        ] : [
          expandMenuItem,
          collapseMenuItem,
          { separator: true },
          {
            icon: faCopy,
            title: "Copy (Ctrl+C)",
            className: "jse-copy",
            onClick: onCopy,
            disabled: !hasSelectionContents
          },
          { separator: true },
          searchMenuItem,
          { space: true }
        ]);
    }
    if ($$self.$$.dirty & 49152) {
      $:
        $$invalidate(0, items = onRenderMenu("tree", defaultItems) || defaultItems);
    }
  };
  return [
    items,
    showSearch,
    json2,
    selection,
    readOnly,
    historyState,
    onExpandAll,
    onCollapseAll,
    onUndo,
    onRedo,
    onSort,
    onTransform,
    onContextMenu,
    onCopy,
    onRenderMenu,
    defaultItems,
    searchMenuItem,
    hasSelectionContents,
    collapseMenuItem,
    expandMenuItem,
    hasJson
  ];
}
var TreeMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, not_equal, {
      json: 2,
      selection: 3,
      readOnly: 4,
      showSearch: 1,
      historyState: 5,
      onExpandAll: 6,
      onCollapseAll: 7,
      onUndo: 8,
      onRedo: 9,
      onSort: 10,
      onTransform: 11,
      onContextMenu: 12,
      onCopy: 13,
      onRenderMenu: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeMenu",
      options,
      id: create_fragment30.name
    });
  }
  get json() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set json(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showSearch() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showSearch(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get historyState() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set historyState(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExpandAll() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExpandAll(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCollapseAll() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCollapseAll(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onUndo() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onUndo(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRedo() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRedo(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSort() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSort(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTransform() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTransform(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onContextMenu() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onContextMenu(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCopy() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCopy(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderMenu() {
    throw new Error("<TreeMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderMenu(value) {
    throw new Error("<TreeMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeMenu_default = TreeMenu;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/Welcome.svelte
var file26 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/Welcome.svelte";
function add_css23(target) {
  append_styles(target, "svelte-cmvfqc", '@charset "UTF-8";.jse-welcome.svelte-cmvfqc.svelte-cmvfqc{flex:1;overflow:auto;font-family:var(--jse-font-family);font-size:var(--jse-font-size);display:flex;flex-direction:column;align-items:center;border-left:var(--jse-main-border);border-right:var(--jse-main-border)}.jse-welcome.svelte-cmvfqc.svelte-cmvfqc:last-child{border-bottom:var(--jse-main-border)}.jse-welcome.svelte-cmvfqc .jse-space.jse-before.svelte-cmvfqc{flex:1}.jse-welcome.svelte-cmvfqc .jse-space.jse-after.svelte-cmvfqc{flex:2}.jse-welcome.svelte-cmvfqc .jse-contents.svelte-cmvfqc{margin:2em var(--jse-padding) 0;color:var(--jse-panel-color-readonly)}.jse-welcome.svelte-cmvfqc .jse-contents ul.svelte-cmvfqc{list-style:"\u25CF";list-style-position:outside;padding-left:20px}.jse-welcome.svelte-cmvfqc .jse-contents ul li.svelte-cmvfqc{padding-left:10px}.jse-welcome.svelte-cmvfqc .jse-contents ul li span.jse-bold.svelte-cmvfqc{font-family:var(--jse-font-family-mono);font-weight:bold}.svelte-cmvfqc.svelte-cmvfqc{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2VsY29tZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcUIyQixTQUFBLE9BQUEsQ0FBQSxzOEJBb0MxQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJXZWxjb21lLnN2ZWx0ZSJdfQ== */');
}
function create_if_block15(ctx) {
  let ul;
  let li0;
  let t0;
  let t1;
  let li1;
  let t2;
  let span0;
  let t3;
  let t4;
  let li2;
  let t5;
  let span1;
  let t6;
  let t7;
  let li3;
  let t8;
  let span2;
  let t9;
  const block = {
    c: function create() {
      ul = element("ul");
      li0 = element("li");
      t0 = text("Click inside the editor");
      t1 = space();
      li1 = element("li");
      t2 = text("Paste clipboard data using ");
      span0 = element("span");
      t3 = text("Ctrl+V");
      t4 = space();
      li2 = element("li");
      t5 = text("Create a new object by typing ");
      span1 = element("span");
      t6 = text("{");
      t7 = space();
      li3 = element("li");
      t8 = text("Create a new array by typing ");
      span2 = element("span");
      t9 = text("[");
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      li0 = claim_element(ul_nodes, "LI", { class: true });
      var li0_nodes = children(li0);
      t0 = claim_text(li0_nodes, "Click inside the editor");
      li0_nodes.forEach(detach_dev);
      t1 = claim_space(ul_nodes);
      li1 = claim_element(ul_nodes, "LI", { class: true });
      var li1_nodes = children(li1);
      t2 = claim_text(li1_nodes, "Paste clipboard data using ");
      span0 = claim_element(li1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t3 = claim_text(span0_nodes, "Ctrl+V");
      span0_nodes.forEach(detach_dev);
      li1_nodes.forEach(detach_dev);
      t4 = claim_space(ul_nodes);
      li2 = claim_element(ul_nodes, "LI", { class: true });
      var li2_nodes = children(li2);
      t5 = claim_text(li2_nodes, "Create a new object by typing ");
      span1 = claim_element(li2_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t6 = claim_text(span1_nodes, "{");
      span1_nodes.forEach(detach_dev);
      li2_nodes.forEach(detach_dev);
      t7 = claim_space(ul_nodes);
      li3 = claim_element(ul_nodes, "LI", { class: true });
      var li3_nodes = children(li3);
      t8 = claim_text(li3_nodes, "Create a new array by typing ");
      span2 = claim_element(li3_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t9 = claim_text(span2_nodes, "[");
      span2_nodes.forEach(detach_dev);
      li3_nodes.forEach(detach_dev);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li0, "class", "svelte-cmvfqc");
      add_location(li0, file26, 11, 8, 230);
      attr_dev(span0, "class", "jse-bold svelte-cmvfqc");
      add_location(span0, file26, 12, 39, 302);
      attr_dev(li1, "class", "svelte-cmvfqc");
      add_location(li1, file26, 12, 8, 271);
      attr_dev(span1, "class", "jse-bold svelte-cmvfqc");
      add_location(span1, file26, 13, 42, 386);
      attr_dev(li2, "class", "svelte-cmvfqc");
      add_location(li2, file26, 13, 8, 352);
      attr_dev(span2, "class", "jse-bold svelte-cmvfqc");
      add_location(span2, file26, 14, 41, 471);
      attr_dev(li3, "class", "svelte-cmvfqc");
      add_location(li3, file26, 14, 8, 438);
      attr_dev(ul, "class", "svelte-cmvfqc");
      add_location(ul, file26, 10, 6, 217);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      append_hydration_dev(ul, li0);
      append_hydration_dev(li0, t0);
      append_hydration_dev(ul, t1);
      append_hydration_dev(ul, li1);
      append_hydration_dev(li1, t2);
      append_hydration_dev(li1, span0);
      append_hydration_dev(span0, t3);
      append_hydration_dev(ul, t4);
      append_hydration_dev(ul, li2);
      append_hydration_dev(li2, t5);
      append_hydration_dev(li2, span1);
      append_hydration_dev(span1, t6);
      append_hydration_dev(ul, t7);
      append_hydration_dev(ul, li3);
      append_hydration_dev(li3, t8);
      append_hydration_dev(li3, span2);
      append_hydration_dev(span2, t9);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(ul);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(10:4) {#if !readOnly}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let div2;
  let if_block = !ctx[0] && create_if_block15(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text("Empty document\n    ");
      if (if_block)
        if_block.c();
      t2 = space();
      div2 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, "Empty document\n    ");
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-space jse-before svelte-cmvfqc");
      add_location(div0, file26, 6, 2, 106);
      attr_dev(div1, "class", "jse-contents svelte-cmvfqc");
      add_location(div1, file26, 7, 2, 145);
      attr_dev(div2, "class", "jse-space jse-after svelte-cmvfqc");
      add_location(div2, file26, 18, 2, 541);
      attr_dev(div3, "class", "jse-welcome svelte-cmvfqc");
      add_location(div3, file26, 5, 0, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Welcome", slots, []);
  let { readOnly } = $$props;
  $$self.$$.on_mount.push(function() {
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console.warn("<Welcome> was created without expected prop 'readOnly'");
    }
  });
  const writable_props = ["readOnly"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Welcome> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("readOnly" in $$props2)
      $$invalidate(0, readOnly = $$props2.readOnly);
  };
  $$self.$capture_state = () => ({ readOnly });
  $$self.$inject_state = ($$props2) => {
    if ("readOnly" in $$props2)
      $$invalidate(0, readOnly = $$props2.readOnly);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [readOnly];
}
var Welcome = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, not_equal, { readOnly: 0 }, add_css23);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Welcome",
      options,
      id: create_fragment31.name
    });
  }
  get readOnly() {
    throw new Error("<Welcome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<Welcome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Welcome_default = Welcome;

// ../node_modules/svelte-jsoneditor/logic/sort.js
var import_natural_compare_lite = __toESM(require_natural_compare_lite(), 1);
function caseInsensitiveNaturalCompare(a, b) {
  const aLower = typeof a === "string" ? a.toLowerCase() : a;
  const bLower = typeof b === "string" ? b.toLowerCase() : b;
  return (0, import_natural_compare_lite.default)(aLower, bLower);
}
function sortObjectKeys(json2, rootPath = [], direction = 1) {
  const object = getIn(json2, rootPath);
  const keys = Object.keys(object);
  const sortedKeys = keys.slice();
  sortedKeys.sort((keyA, keyB) => {
    return direction * caseInsensitiveNaturalCompare(keyA, keyB);
  });
  const operations = [];
  for (let i = 0; i < sortedKeys.length; i++) {
    const key = sortedKeys[i];
    const path = compileJSONPointer(rootPath.concat(key));
    operations.push({
      op: "move",
      from: path,
      path
    });
  }
  return operations;
}
function sortArray(json2, rootPath = [], propertyPath = [], direction = 1) {
  const comparator = createObjectComparator(propertyPath, direction);
  const array = getIn(json2, rootPath);
  return [
    {
      op: "replace",
      path: compileJSONPointer(rootPath),
      value: array.slice(0).sort(comparator)
    }
  ];
}
function createObjectComparator(propertyPath, direction) {
  return function comparator(a, b) {
    const valueA = getIn(a, propertyPath);
    const valueB = getIn(b, propertyPath);
    if (valueA === void 0) {
      return direction;
    }
    if (valueB === void 0) {
      return -direction;
    }
    if (typeof valueA !== "string" && typeof valueB !== "string") {
      return valueA > valueB ? direction : valueA < valueB ? -direction : 0;
    }
    return direction * caseInsensitiveNaturalCompare(valueA, valueB);
  };
}

// ../node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBarDropdown.svelte
var file27 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBarDropdown.svelte";
function add_css24(target) {
  append_styles(target, "svelte-9uwoqd", ".jse-navigation-bar-dropdown.svelte-9uwoqd.svelte-9uwoqd{position:absolute;top:100%;left:0;z-index:3;background:var(--jse-navigation-bar-background);color:var(--jse-navigation-bar-dropdown-color);box-shadow:var(--jse-controls-box-shadow);display:flex;flex-direction:column;max-height:300px;overflow:auto;min-width:80px}.jse-navigation-bar-dropdown.svelte-9uwoqd button.jse-navigation-bar-dropdown-item.svelte-9uwoqd{font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);border:none;background:transparent;color:inherit;cursor:pointer;outline:none;text-align:left;white-space:nowrap;box-sizing:border-box;padding:calc(0.5 * var(--jse-padding)) 36px}.jse-navigation-bar-dropdown.svelte-9uwoqd button.jse-navigation-bar-dropdown-item.svelte-9uwoqd:focus,.jse-navigation-bar-dropdown.svelte-9uwoqd button.jse-navigation-bar-dropdown-item.svelte-9uwoqd:hover{background:var(--jse-navigation-bar-background-highlight)}.jse-navigation-bar-dropdown.svelte-9uwoqd button.jse-navigation-bar-dropdown-item.jse-selected.svelte-9uwoqd{background:var(--jse-navigation-bar-dropdown-color);color:var(--jse-navigation-bar-background)}.svelte-9uwoqd.svelte-9uwoqd{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmF2aWdhdGlvbkJhckRyb3Bkb3duLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrQ3lDLDRCQUFBLDRCQUFBLENBQUEsd2xDQWlDeEMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTmF2aWdhdGlvbkJhckRyb3Bkb3duLnN2ZWx0ZSJdfQ== */");
}
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block11(key_1, ctx) {
  let button;
  let t_value = truncate(ctx[4], MAX_ITEM_CHARACTERS) + "";
  let t;
  let button_title_value;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[3](ctx[4]);
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-navigation-bar-dropdown-item svelte-9uwoqd");
      attr_dev(button, "title", button_title_value = ctx[4]);
      toggle_class(button, "jse-selected", ctx[4] === ctx[1]);
      add_location(button, file27, 13, 4, 383);
      this.first = button;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", stop_propagation(click_handler), false, false, true);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t_value !== (t_value = truncate(ctx[4], MAX_ITEM_CHARACTERS) + ""))
        set_data_dev(t, t_value);
      if (dirty & 1 && button_title_value !== (button_title_value = ctx[4])) {
        attr_dev(button, "title", button_title_value);
      }
      if (dirty & 3) {
        toggle_class(button, "jse-selected", ctx[4] === ctx[1]);
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block11.name,
    type: "each",
    source: "(13:2) {#each limit(items, MAX_ITEMS) as item (item)}",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let button;
  let t;
  let button_title_value;
  const block = {
    c: function create() {
      button = element("button");
      t = text("...");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "...");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-navigation-bar-dropdown-item svelte-9uwoqd");
      attr_dev(button, "title", button_title_value = "Limited to " + MAX_ITEMS + " items");
      add_location(button, file27, 24, 4, 691);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(24:2) {#if items.length > MAX_ITEMS}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value = limit(ctx[0], MAX_ITEMS);
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[4];
  validate_each_keys(ctx, each_value, get_each_context11, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context11(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block11(key, child_ctx));
  }
  let if_block = ctx[0].length > MAX_ITEMS && create_if_block16(ctx);
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-navigation-bar-dropdown svelte-9uwoqd");
      add_location(div, file27, 11, 0, 288);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = limit(ctx2[0], MAX_ITEMS);
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context11, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block11, t, get_each_context11);
      }
      if (ctx2[0].length > MAX_ITEMS) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var MAX_ITEMS = 100;
var MAX_ITEM_CHARACTERS = 30;
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavigationBarDropdown", slots, []);
  let { items } = $$props;
  let { selectedItem } = $$props;
  let { onSelect } = $$props;
  $$self.$$.on_mount.push(function() {
    if (items === void 0 && !("items" in $$props || $$self.$$.bound[$$self.$$.props["items"]])) {
      console.warn("<NavigationBarDropdown> was created without expected prop 'items'");
    }
    if (selectedItem === void 0 && !("selectedItem" in $$props || $$self.$$.bound[$$self.$$.props["selectedItem"]])) {
      console.warn("<NavigationBarDropdown> was created without expected prop 'selectedItem'");
    }
    if (onSelect === void 0 && !("onSelect" in $$props || $$self.$$.bound[$$self.$$.props["onSelect"]])) {
      console.warn("<NavigationBarDropdown> was created without expected prop 'onSelect'");
    }
  });
  const writable_props = ["items", "selectedItem", "onSelect"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavigationBarDropdown> was created with unknown prop '${key}'`);
  });
  const click_handler = (item) => onSelect(item);
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("selectedItem" in $$props2)
      $$invalidate(1, selectedItem = $$props2.selectedItem);
    if ("onSelect" in $$props2)
      $$invalidate(2, onSelect = $$props2.onSelect);
  };
  $$self.$capture_state = () => ({
    limit,
    truncate,
    items,
    selectedItem,
    onSelect,
    MAX_ITEMS,
    MAX_ITEM_CHARACTERS
  });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("selectedItem" in $$props2)
      $$invalidate(1, selectedItem = $$props2.selectedItem);
    if ("onSelect" in $$props2)
      $$invalidate(2, onSelect = $$props2.onSelect);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [items, selectedItem, onSelect, click_handler];
}
var NavigationBarDropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, not_equal, { items: 0, selectedItem: 1, onSelect: 2 }, add_css24);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavigationBarDropdown",
      options,
      id: create_fragment32.name
    });
  }
  get items() {
    throw new Error("<NavigationBarDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<NavigationBarDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedItem() {
    throw new Error("<NavigationBarDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedItem(value) {
    throw new Error("<NavigationBarDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<NavigationBarDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<NavigationBarDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavigationBarDropdown_default = NavigationBarDropdown;

// ../node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBarItem.svelte
var file28 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBarItem.svelte";
function add_css25(target) {
  append_styles(target, "svelte-3px82n", ".jse-navigation-bar-item.svelte-3px82n.svelte-3px82n{position:relative;display:flex}.jse-navigation-bar-item.svelte-3px82n button.jse-navigation-bar-button.svelte-3px82n{font-family:inherit;font-size:inherit;padding:calc(0.5 * var(--jse-padding)) 2px;border:none;background:transparent;color:inherit;cursor:pointer;outline:none;min-width:2em;white-space:nowrap}.jse-navigation-bar-item.svelte-3px82n button.jse-navigation-bar-button.svelte-3px82n:focus,.jse-navigation-bar-item.svelte-3px82n button.jse-navigation-bar-button.svelte-3px82n:hover{background:var(--jse-panel-button-background-highlight);color:var(--jse-panel-button-color-highlight)}.jse-navigation-bar-item.svelte-3px82n button.jse-navigation-bar-button.jse-navigation-bar-arrow.svelte-3px82n{padding:2px var(--jse-padding) 0}.jse-navigation-bar-item.svelte-3px82n button.jse-navigation-bar-button.jse-navigation-bar-arrow.jse-open.svelte-3px82n{background:var(--jse-navigation-bar-background);color:var(--jse-navigation-bar-dropdown-color)}.jse-navigation-bar-item.svelte-3px82n.svelte-3px82n:last-child{padding-right:var(--jse-padding)}.svelte-3px82n.svelte-3px82n{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmF2aWdhdGlvbkJhckl0ZW0uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJEcUMsd0JBQUEsNEJBQUEsQ0FBQSx3akNBNkJwQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJOYXZpZ2F0aW9uQmFySXRlbS5zdmVsdGUiXX0= */");
}
function create_if_block17(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(ctx[2]);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, ctx[2]);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-navigation-bar-button svelte-3px82n");
      add_location(button, file28, 49, 4, 1487);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[9], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(49:2) {#if selectedItem !== undefined}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let div;
  let button;
  let icon;
  let t;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { data: faAngleRight },
    $$inline: true
  });
  let if_block = ctx[2] !== void 0 && create_if_block17(ctx);
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      create_component(icon.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-navigation-bar-button jse-navigation-bar-arrow svelte-3px82n");
      toggle_class(button, "jse-open", ctx[1]);
      add_location(button, file28, 40, 2, 1256);
      attr_dev(div, "class", "jse-navigation-bar-item svelte-3px82n");
      add_location(div, file28, 39, 0, 1183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      mount_component(icon, button, null);
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[10](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[4], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 2) {
        toggle_class(button, "jse-open", ctx2[1]);
      }
      if (ctx2[2] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block17(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(icon);
      if (if_block)
        if_block.d();
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let itemPath;
  let selectedItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavigationBarItem", slots, []);
  const { openAbsolutePopup, closeAbsolutePopup } = getContext("absolute-popup");
  let { path } = $$props;
  let { index } = $$props;
  let { onSelect } = $$props;
  let { getItems } = $$props;
  let refNavigationBarItem;
  let open = false;
  let popupId;
  function handleSelectItem(item) {
    closeAbsolutePopup(popupId);
    onSelect(itemPath.concat(item));
  }
  function openDropdown() {
    if (refNavigationBarItem) {
      $$invalidate(1, open = true);
      const props = {
        items: getItems(itemPath),
        selectedItem,
        onSelect: handleSelectItem
      };
      popupId = openAbsolutePopup(NavigationBarDropdown_default, props, {
        anchor: refNavigationBarItem,
        closeOnOuterClick: true,
        onClose: () => {
          $$invalidate(1, open = false);
        }
      });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<NavigationBarItem> was created without expected prop 'path'");
    }
    if (index === void 0 && !("index" in $$props || $$self.$$.bound[$$self.$$.props["index"]])) {
      console.warn("<NavigationBarItem> was created without expected prop 'index'");
    }
    if (onSelect === void 0 && !("onSelect" in $$props || $$self.$$.bound[$$self.$$.props["onSelect"]])) {
      console.warn("<NavigationBarItem> was created without expected prop 'onSelect'");
    }
    if (getItems === void 0 && !("getItems" in $$props || $$self.$$.bound[$$self.$$.props["getItems"]])) {
      console.warn("<NavigationBarItem> was created without expected prop 'getItems'");
    }
  });
  const writable_props = ["path", "index", "onSelect", "getItems"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavigationBarItem> was created with unknown prop '${key}'`);
  });
  const click_handler = () => handleSelectItem(selectedItem);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refNavigationBarItem = $$value;
      $$invalidate(0, refNavigationBarItem);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(5, path = $$props2.path);
    if ("index" in $$props2)
      $$invalidate(6, index = $$props2.index);
    if ("onSelect" in $$props2)
      $$invalidate(7, onSelect = $$props2.onSelect);
    if ("getItems" in $$props2)
      $$invalidate(8, getItems = $$props2.getItems);
  };
  $$self.$capture_state = () => ({
    Icon: Icon_default,
    faAngleRight,
    NavigationBarDropdown: NavigationBarDropdown_default,
    getContext,
    openAbsolutePopup,
    closeAbsolutePopup,
    path,
    index,
    onSelect,
    getItems,
    refNavigationBarItem,
    open,
    popupId,
    handleSelectItem,
    openDropdown,
    selectedItem,
    itemPath
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(5, path = $$props2.path);
    if ("index" in $$props2)
      $$invalidate(6, index = $$props2.index);
    if ("onSelect" in $$props2)
      $$invalidate(7, onSelect = $$props2.onSelect);
    if ("getItems" in $$props2)
      $$invalidate(8, getItems = $$props2.getItems);
    if ("refNavigationBarItem" in $$props2)
      $$invalidate(0, refNavigationBarItem = $$props2.refNavigationBarItem);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("popupId" in $$props2)
      popupId = $$props2.popupId;
    if ("selectedItem" in $$props2)
      $$invalidate(2, selectedItem = $$props2.selectedItem);
    if ("itemPath" in $$props2)
      itemPath = $$props2.itemPath;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 96) {
      $:
        itemPath = path.slice(0, index);
    }
    if ($$self.$$.dirty & 96) {
      $:
        $$invalidate(2, selectedItem = path[index]);
    }
  };
  return [
    refNavigationBarItem,
    open,
    selectedItem,
    handleSelectItem,
    openDropdown,
    path,
    index,
    onSelect,
    getItems,
    click_handler,
    div_binding
  ];
}
var NavigationBarItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance33,
      create_fragment33,
      not_equal,
      {
        path: 5,
        index: 6,
        onSelect: 7,
        getItems: 8
      },
      add_css25
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavigationBarItem",
      options,
      id: create_fragment33.name
    });
  }
  get path() {
    throw new Error("<NavigationBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<NavigationBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get index() {
    throw new Error("<NavigationBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<NavigationBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<NavigationBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<NavigationBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getItems() {
    throw new Error("<NavigationBarItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getItems(value) {
    throw new Error("<NavigationBarItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavigationBarItem_default = NavigationBarItem;

// ../node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBarPathEditor.svelte
var { Error: Error_12 } = globals;
var file29 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBarPathEditor.svelte";
function add_css26(target) {
  append_styles(target, "svelte-1bafmp6", ".jse-navigation-bar-path-editor.svelte-1bafmp6.svelte-1bafmp6{flex:1;display:flex;border:var(--jse-edit-outline);background:var(--jse-background-color)}.jse-navigation-bar-path-editor.svelte-1bafmp6 input.jse-navigation-bar-text.svelte-1bafmp6{flex:1;font-family:inherit;font-size:inherit;padding:0 5px 1px;background:var(--jse-background-color);color:var(--jse-text-color);border:none;outline:none}.jse-navigation-bar-path-editor.svelte-1bafmp6 button.svelte-1bafmp6{border:none;background:var(--jse-background-color);cursor:pointer;font-family:inherit;font-size:80%;color:inherit}.jse-navigation-bar-path-editor.svelte-1bafmp6 button.jse-navigation-bar-copy.copied.svelte-1bafmp6{color:var(--jse-message-success-background)}.jse-navigation-bar-path-editor.svelte-1bafmp6 button.jse-navigation-bar-validation-error.svelte-1bafmp6{color:var(--jse-error-color)}.jse-navigation-bar-path-editor.error.svelte-1bafmp6.svelte-1bafmp6{border-color:var(--jse-error-color)}.jse-navigation-bar-path-editor.error.svelte-1bafmp6 input.jse-navigation-bar-text.svelte-1bafmp6{color:var(--jse-error-color)}.jse-navigation-bar-path-editor.svelte-1bafmp6 .jse-copied-text.svelte-1bafmp6{background:var(--jse-message-success-background);color:var(--jse-message-success-color);position:relative;margin:2px;padding:0 5px;border-radius:3px}.svelte-1bafmp6.svelte-1bafmp6{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmF2aWdhdGlvbkJhclBhdGhFZGl0b3Iuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWlIMkMsK0JBQUEsOEJBQUEsQ0FBQSx5d0NBMkMxQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJOYXZpZ2F0aW9uQmFyUGF0aEVkaXRvci5zdmVsdGUiXX0= */");
}
function create_if_block_110(ctx) {
  let button;
  let icon;
  let tooltip_action;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: { data: faExclamationTriangle },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-navigation-bar-validation-error svelte-1bafmp6");
      add_location(button, file29, 88, 4, 2426);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(tooltip_action = tooltip.call(null, button, {
          text: ctx[3],
          ...ctx[4]
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 8)
        tooltip_action.update.call(null, {
          text: ctx2[3],
          ...ctx2[4]
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(88:2) {#if inputValidationError}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("Copied!");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "Copied!");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-copied-text svelte-1bafmp6");
      add_location(div, file29, 100, 4, 2693);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(100:2) {#if copied}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let div;
  let input;
  let t0;
  let t1;
  let t2;
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_110(ctx);
  let if_block1 = ctx[2] && create_if_block18(ctx);
  icon = new Icon_default({ props: { data: faCopy }, $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, class: true });
      t0 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t2 = claim_space(div_nodes);
      button = claim_element(div_nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      attr_dev(input, "class", "jse-navigation-bar-text svelte-1bafmp6");
      input.value = ctx[0];
      add_location(input, file29, 79, 2, 2208);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-navigation-bar-copy svelte-1bafmp6");
      attr_dev(button, "title", "Copy selected path to the clipboard");
      toggle_class(button, "copied", ctx[2]);
      add_location(button, file29, 102, 2, 2746);
      attr_dev(div, "class", "jse-navigation-bar-path-editor svelte-1bafmp6");
      toggle_class(div, "error", ctx[3]);
      add_location(div, file29, 78, 0, 2126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx[15](input);
      append_hydration_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t2);
      append_hydration_dev(div, button);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "keydown", stop_propagation(ctx[6]), false, false, true),
          listen_dev(input, "input", ctx[5], false, false, false),
          listen_dev(button, "click", ctx[7], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1 && input.value !== ctx2[0]) {
        prop_dev(input, "value", ctx2[0]);
      }
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_110(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block18(ctx2);
          if_block1.c();
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 4) {
        toggle_class(button, "copied", ctx2[2]);
      }
      if (!current || dirty & 8) {
        toggle_class(div, "error", ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var copiedDelay = 1e3;
function instance34($$self, $$props, $$invalidate) {
  let inputValidationError;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavigationBarPathEditor", slots, []);
  const absolutePopupContext = getContext("absolute-popup");
  let { path } = $$props;
  let { pathParser } = $$props;
  let { onChange } = $$props;
  let { onClose } = $$props;
  let { onError } = $$props;
  let { pathExists } = $$props;
  let inputRef;
  let inputPath;
  let validationActive = false;
  let copiedTimer = void 0;
  let copied = false;
  onMount(() => {
    focus3();
  });
  onDestroy(() => {
    clearTimeout(copiedTimer);
  });
  function focus3() {
    inputRef.focus();
  }
  function parseAndValidate(pathStr) {
    try {
      const path2 = pathParser.parse(pathStr);
      validatePathExists(path2);
      return { path: path2, error: void 0 };
    } catch (error) {
      return { path: void 0, error };
    }
  }
  function validatePathExists(path2) {
    if (!pathExists(path2)) {
      throw new Error("Path does not exist in current document");
    }
  }
  function handleInput(event) {
    $$invalidate(0, inputPath = event.currentTarget.value);
  }
  function handleKeyDown(event) {
    const combo = keyComboFromEvent(event);
    if (combo === "Escape") {
      onClose();
    }
    if (combo === "Enter") {
      $$invalidate(14, validationActive = true);
      const result = parseAndValidate(inputPath);
      if (result.path !== void 0) {
        onChange(result.path);
      } else {
        onError(result.error);
      }
    }
  }
  function handleCopy() {
    copyToClipBoard(inputPath);
    $$invalidate(2, copied = true);
    copiedTimer = setTimeout(() => $$invalidate(2, copied = false), copiedDelay);
    focus3();
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<NavigationBarPathEditor> was created without expected prop 'path'");
    }
    if (pathParser === void 0 && !("pathParser" in $$props || $$self.$$.bound[$$self.$$.props["pathParser"]])) {
      console.warn("<NavigationBarPathEditor> was created without expected prop 'pathParser'");
    }
    if (onChange === void 0 && !("onChange" in $$props || $$self.$$.bound[$$self.$$.props["onChange"]])) {
      console.warn("<NavigationBarPathEditor> was created without expected prop 'onChange'");
    }
    if (onClose === void 0 && !("onClose" in $$props || $$self.$$.bound[$$self.$$.props["onClose"]])) {
      console.warn("<NavigationBarPathEditor> was created without expected prop 'onClose'");
    }
    if (onError === void 0 && !("onError" in $$props || $$self.$$.bound[$$self.$$.props["onError"]])) {
      console.warn("<NavigationBarPathEditor> was created without expected prop 'onError'");
    }
    if (pathExists === void 0 && !("pathExists" in $$props || $$self.$$.bound[$$self.$$.props["pathExists"]])) {
      console.warn("<NavigationBarPathEditor> was created without expected prop 'pathExists'");
    }
  });
  const writable_props = ["path", "pathParser", "onChange", "onClose", "onError", "pathExists"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavigationBarPathEditor> was created with unknown prop '${key}'`);
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputRef = $$value;
      $$invalidate(1, inputRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(8, path = $$props2.path);
    if ("pathParser" in $$props2)
      $$invalidate(9, pathParser = $$props2.pathParser);
    if ("onChange" in $$props2)
      $$invalidate(10, onChange = $$props2.onChange);
    if ("onClose" in $$props2)
      $$invalidate(11, onClose = $$props2.onClose);
    if ("onError" in $$props2)
      $$invalidate(12, onError = $$props2.onError);
    if ("pathExists" in $$props2)
      $$invalidate(13, pathExists = $$props2.pathExists);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    onMount,
    copyToClipBoard,
    faCopy,
    faExclamationTriangle,
    Icon: Icon_default,
    keyComboFromEvent,
    tooltip,
    absolutePopupContext,
    path,
    pathParser,
    onChange,
    onClose,
    onError,
    pathExists,
    inputRef,
    inputPath,
    validationActive,
    copiedTimer,
    copied,
    copiedDelay,
    focus: focus3,
    parseAndValidate,
    validatePathExists,
    handleInput,
    handleKeyDown,
    handleCopy,
    inputValidationError
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(8, path = $$props2.path);
    if ("pathParser" in $$props2)
      $$invalidate(9, pathParser = $$props2.pathParser);
    if ("onChange" in $$props2)
      $$invalidate(10, onChange = $$props2.onChange);
    if ("onClose" in $$props2)
      $$invalidate(11, onClose = $$props2.onClose);
    if ("onError" in $$props2)
      $$invalidate(12, onError = $$props2.onError);
    if ("pathExists" in $$props2)
      $$invalidate(13, pathExists = $$props2.pathExists);
    if ("inputRef" in $$props2)
      $$invalidate(1, inputRef = $$props2.inputRef);
    if ("inputPath" in $$props2)
      $$invalidate(0, inputPath = $$props2.inputPath);
    if ("validationActive" in $$props2)
      $$invalidate(14, validationActive = $$props2.validationActive);
    if ("copiedTimer" in $$props2)
      copiedTimer = $$props2.copiedTimer;
    if ("copied" in $$props2)
      $$invalidate(2, copied = $$props2.copied);
    if ("inputValidationError" in $$props2)
      $$invalidate(3, inputValidationError = $$props2.inputValidationError);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 768) {
      $:
        $$invalidate(0, inputPath = pathParser.stringify(path));
    }
    if ($$self.$$.dirty & 16385) {
      $:
        $$invalidate(3, inputValidationError = validationActive ? parseAndValidate(inputPath).error : void 0);
    }
  };
  return [
    inputPath,
    inputRef,
    copied,
    inputValidationError,
    absolutePopupContext,
    handleInput,
    handleKeyDown,
    handleCopy,
    path,
    pathParser,
    onChange,
    onClose,
    onError,
    pathExists,
    validationActive,
    input_binding
  ];
}
var NavigationBarPathEditor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance34,
      create_fragment34,
      safe_not_equal,
      {
        path: 8,
        pathParser: 9,
        onChange: 10,
        onClose: 11,
        onError: 12,
        pathExists: 13
      },
      add_css26
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavigationBarPathEditor",
      options,
      id: create_fragment34.name
    });
  }
  get path() {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathParser() {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathParser(value) {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClose() {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClose(value) {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onError() {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onError(value) {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathExists() {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathExists(value) {
    throw new Error_12("<NavigationBarPathEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavigationBarPathEditor_default = NavigationBarPathEditor;

// ../node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBar.svelte
var { Object: Object_15 } = globals;
var file30 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/navigationBar/NavigationBar.svelte";
function add_css27(target) {
  append_styles(target, "svelte-1k8h8q4", ".jse-navigation-bar.svelte-1k8h8q4.svelte-1k8h8q4{font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);background:var(--jse-panel-background);color:var(--jse-panel-button-color);padding:0;margin:0;display:flex;overflow:auto;border-left:var(--jse-main-border);border-right:var(--jse-main-border)}.jse-navigation-bar.svelte-1k8h8q4 .jse-navigation-bar-edit.svelte-1k8h8q4{font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);padding:calc(0.5 * var(--jse-padding)) var(--jse-padding);color:var(--jse-panel-color-readonly);background:transparent;border:none;display:flex;cursor:pointer;outline:none;align-items:center}.jse-navigation-bar.svelte-1k8h8q4 .jse-navigation-bar-edit.flex.svelte-1k8h8q4{flex:1}.jse-navigation-bar.svelte-1k8h8q4 .jse-navigation-bar-edit.svelte-1k8h8q4:focus,.jse-navigation-bar.svelte-1k8h8q4 .jse-navigation-bar-edit.svelte-1k8h8q4:hover,.jse-navigation-bar.svelte-1k8h8q4 .jse-navigation-bar-edit.editing.svelte-1k8h8q4{background:var(--jse-panel-button-background-highlight);color:var(--jse-panel-button-color-highlight);transition:color 0.2s ease-in, background 0.2s ease-in}.jse-navigation-bar.svelte-1k8h8q4 .jse-navigation-bar-edit .jse-navigation-bar-space.svelte-1k8h8q4{flex:1;text-align:left}.svelte-1k8h8q4.svelte-1k8h8q4{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmF2aWdhdGlvbkJhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNkdpQyxtQkFBQSw4QkFBQSxDQUFBLHV1Q0FtQ2hDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk5hdmlnYXRpb25CYXIuc3ZlbHRlIl19 */");
}
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  child_ctx[22] = i;
  return child_ctx;
}
function create_else_block9(ctx) {
  let navigationbarpatheditor;
  let current;
  navigationbarpatheditor = new NavigationBarPathEditor_default({
    props: {
      path: ctx[3],
      onClose: ctx[12],
      onChange: ctx[13],
      onError: ctx[1],
      pathExists: ctx[9],
      pathParser: ctx[2]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navigationbarpatheditor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(navigationbarpatheditor.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(navigationbarpatheditor, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navigationbarpatheditor_changes = {};
      if (dirty & 8)
        navigationbarpatheditor_changes.path = ctx2[3];
      if (dirty & 2)
        navigationbarpatheditor_changes.onError = ctx2[1];
      if (dirty & 4)
        navigationbarpatheditor_changes.pathParser = ctx2[2];
      navigationbarpatheditor.$set(navigationbarpatheditor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navigationbarpatheditor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navigationbarpatheditor.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(navigationbarpatheditor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(81:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let if_block_anchor;
  let current;
  let each_value = ctx[3];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[22];
  validate_each_keys(ctx, each_value, get_each_context12, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context12(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block12(key, child_ctx));
  }
  let if_block = ctx[7] && create_if_block_111(ctx);
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1288) {
        each_value = ctx2[3];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context12, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block12, t, get_each_context12);
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_111(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(74:2) {#if !editing}",
    ctx
  });
  return block;
}
function create_each_block12(key_1, ctx) {
  let first;
  let navigationbaritem;
  let current;
  navigationbaritem = new NavigationBarItem_default({
    props: {
      getItems: ctx[8],
      path: ctx[3],
      index: ctx[22],
      onSelect: ctx[10]
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(navigationbaritem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(navigationbaritem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(navigationbaritem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const navigationbaritem_changes = {};
      if (dirty & 8)
        navigationbaritem_changes.path = ctx[3];
      if (dirty & 8)
        navigationbaritem_changes.index = ctx[22];
      navigationbaritem.$set(navigationbaritem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navigationbaritem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navigationbaritem.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(navigationbaritem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block12.name,
    type: "each",
    source: "(75:4) {#each path as item, index (index)}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let navigationbaritem;
  let current;
  navigationbaritem = new NavigationBarItem_default({
    props: {
      getItems: ctx[8],
      path: ctx[3],
      index: void 0,
      onSelect: ctx[10]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navigationbaritem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(navigationbaritem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(navigationbaritem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navigationbaritem_changes = {};
      if (dirty & 8)
        navigationbaritem_changes.path = ctx2[3];
      navigationbaritem.$set(navigationbaritem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navigationbaritem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navigationbaritem.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(navigationbaritem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(78:4) {#if hasNextItem}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t0;
  let button;
  let span;
  let t1_value = !isObjectOrArray(ctx[0]) && !ctx[6] ? "Navigation bar" : "\xA0";
  let t1;
  let t2;
  let icon;
  let button_title_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block19, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  icon = new Icon_default({
    props: {
      data: ctx[6] ? faClose : faEdit
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      t0 = space();
      button = element("button");
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      t0 = claim_space(div_nodes);
      button = claim_element(div_nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      t2 = claim_space(button_nodes);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "jse-navigation-bar-space svelte-1k8h8q4");
      add_location(span, file30, 100, 4, 3157);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-navigation-bar-edit svelte-1k8h8q4");
      attr_dev(button, "title", button_title_value = ctx[6] ? "Cancel editing the selected path" : "Edit the selected path");
      toggle_class(button, "flex", !ctx[6]);
      toggle_class(button, "editing", ctx[6]);
      add_location(button, file30, 91, 2, 2900);
      attr_dev(div, "class", "jse-navigation-bar svelte-1k8h8q4");
      add_location(div, file30, 72, 0, 2379);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t1);
      append_hydration_dev(button, t2);
      mount_component(icon, button, null);
      ctx[16](button);
      ctx[17](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[11], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t0);
      }
      if ((!current || dirty & 65) && t1_value !== (t1_value = !isObjectOrArray(ctx2[0]) && !ctx2[6] ? "Navigation bar" : "\xA0"))
        set_data_dev(t1, t1_value);
      const icon_changes = {};
      if (dirty & 64)
        icon_changes.data = ctx2[6] ? faClose : faEdit;
      icon.$set(icon_changes);
      if (!current || dirty & 64 && button_title_value !== (button_title_value = ctx2[6] ? "Cancel editing the selected path" : "Edit the selected path")) {
        attr_dev(button, "title", button_title_value);
      }
      if (!current || dirty & 64) {
        toggle_class(button, "flex", !ctx2[6]);
      }
      if (!current || dirty & 64) {
        toggle_class(button, "editing", ctx2[6]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      destroy_component(icon);
      ctx[16](null);
      ctx[17](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let path;
  let hasNextItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavigationBar", slots, []);
  const debug5 = createDebug("jsoneditor:NavigationBar");
  let { json: json2 } = $$props;
  let { documentState } = $$props;
  let { onSelect } = $$props;
  let { onError } = $$props;
  let { pathParser } = $$props;
  let refNavigationBar;
  let refEditButton;
  let editing = false;
  function scrollToLastItem() {
    setTimeout(() => {
      if (refNavigationBar && refNavigationBar.scrollTo) {
        const left = refNavigationBar.scrollWidth - refNavigationBar.clientWidth;
        if (left > 0) {
          debug5("scrollTo ", left);
          refNavigationBar.scrollTo({ left, behavior: "smooth" });
        }
      }
    });
  }
  function getItems(path2) {
    debug5("get items for path", path2);
    const node = getIn(json2, path2);
    if (Array.isArray(node)) {
      return range_default(0, node.length).map(String);
    } else if (isObject(node)) {
      const keys = Object.keys(node);
      const sortedKeys = keys.slice(0);
      sortedKeys.sort(caseInsensitiveNaturalCompare);
      return sortedKeys;
    } else {
      return [];
    }
  }
  function pathExists(path2) {
    return existsIn(json2, path2);
  }
  function handleSelect(path2) {
    debug5("select path", JSON.stringify(path2));
    onSelect(createMultiSelection(json2, path2, path2));
  }
  function toggleEditing() {
    $$invalidate(6, editing = !editing);
  }
  function handleCloseEditor() {
    $$invalidate(6, editing = false);
  }
  function handleChangePath(path2) {
    handleCloseEditor();
    handleSelect(path2);
  }
  $$self.$$.on_mount.push(function() {
    if (json2 === void 0 && !("json" in $$props || $$self.$$.bound[$$self.$$.props["json"]])) {
      console.warn("<NavigationBar> was created without expected prop 'json'");
    }
    if (documentState === void 0 && !("documentState" in $$props || $$self.$$.bound[$$self.$$.props["documentState"]])) {
      console.warn("<NavigationBar> was created without expected prop 'documentState'");
    }
    if (onSelect === void 0 && !("onSelect" in $$props || $$self.$$.bound[$$self.$$.props["onSelect"]])) {
      console.warn("<NavigationBar> was created without expected prop 'onSelect'");
    }
    if (onError === void 0 && !("onError" in $$props || $$self.$$.bound[$$self.$$.props["onError"]])) {
      console.warn("<NavigationBar> was created without expected prop 'onError'");
    }
    if (pathParser === void 0 && !("pathParser" in $$props || $$self.$$.bound[$$self.$$.props["pathParser"]])) {
      console.warn("<NavigationBar> was created without expected prop 'pathParser'");
    }
  });
  const writable_props = ["json", "documentState", "onSelect", "onError", "pathParser"];
  Object_15.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavigationBar> was created with unknown prop '${key}'`);
  });
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refEditButton = $$value;
      $$invalidate(5, refEditButton);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refNavigationBar = $$value;
      $$invalidate(4, refNavigationBar);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(0, json2 = $$props2.json);
    if ("documentState" in $$props2)
      $$invalidate(14, documentState = $$props2.documentState);
    if ("onSelect" in $$props2)
      $$invalidate(15, onSelect = $$props2.onSelect);
    if ("onError" in $$props2)
      $$invalidate(1, onError = $$props2.onError);
    if ("pathParser" in $$props2)
      $$invalidate(2, pathParser = $$props2.pathParser);
  };
  $$self.$capture_state = () => ({
    existsIn,
    getIn,
    range: range_default,
    isObject,
    isObjectOrArray,
    createMultiSelection,
    createDebug,
    caseInsensitiveNaturalCompare,
    Icon: Icon_default,
    faClose,
    faEdit,
    NavigationBarItem: NavigationBarItem_default,
    NavigationBarPathEditor: NavigationBarPathEditor_default,
    debug: debug5,
    json: json2,
    documentState,
    onSelect,
    onError,
    pathParser,
    refNavigationBar,
    refEditButton,
    editing,
    scrollToLastItem,
    getItems,
    pathExists,
    handleSelect,
    toggleEditing,
    handleCloseEditor,
    handleChangePath,
    path,
    hasNextItem
  });
  $$self.$inject_state = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(0, json2 = $$props2.json);
    if ("documentState" in $$props2)
      $$invalidate(14, documentState = $$props2.documentState);
    if ("onSelect" in $$props2)
      $$invalidate(15, onSelect = $$props2.onSelect);
    if ("onError" in $$props2)
      $$invalidate(1, onError = $$props2.onError);
    if ("pathParser" in $$props2)
      $$invalidate(2, pathParser = $$props2.pathParser);
    if ("refNavigationBar" in $$props2)
      $$invalidate(4, refNavigationBar = $$props2.refNavigationBar);
    if ("refEditButton" in $$props2)
      $$invalidate(5, refEditButton = $$props2.refEditButton);
    if ("editing" in $$props2)
      $$invalidate(6, editing = $$props2.editing);
    if ("path" in $$props2)
      $$invalidate(3, path = $$props2.path);
    if ("hasNextItem" in $$props2)
      $$invalidate(7, hasNextItem = $$props2.hasNextItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      $:
        $$invalidate(3, path = documentState.selection ? documentState.selection.focusPath : []);
    }
    if ($$self.$$.dirty & 9) {
      $:
        $$invalidate(7, hasNextItem = isObjectOrArray(getIn(json2, path)));
    }
    if ($$self.$$.dirty & 8) {
      $:
        scrollToLastItem(path);
    }
  };
  return [
    json2,
    onError,
    pathParser,
    path,
    refNavigationBar,
    refEditButton,
    editing,
    hasNextItem,
    getItems,
    pathExists,
    handleSelect,
    toggleEditing,
    handleCloseEditor,
    handleChangePath,
    documentState,
    onSelect,
    button_binding,
    div_binding
  ];
}
var NavigationBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance35,
      create_fragment35,
      not_equal,
      {
        json: 0,
        documentState: 14,
        onSelect: 15,
        onError: 1,
        pathParser: 2
      },
      add_css27
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavigationBar",
      options,
      id: create_fragment35.name
    });
  }
  get json() {
    throw new Error("<NavigationBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set json(value) {
    throw new Error("<NavigationBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get documentState() {
    throw new Error("<NavigationBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set documentState(value) {
    throw new Error("<NavigationBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<NavigationBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<NavigationBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onError() {
    throw new Error("<NavigationBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onError(value) {
    throw new Error("<NavigationBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathParser() {
    throw new Error("<NavigationBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathParser(value) {
    throw new Error("<NavigationBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavigationBar_default = NavigationBar;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/menu/SearchBox.svelte
var file31 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/menu/SearchBox.svelte";
function add_css28(target) {
  append_styles(target, "svelte-8auxqr", ".jse-search-box.svelte-8auxqr.svelte-8auxqr{border:var(--jse-panel-border);border-radius:3px;font-family:var(--jse-font-family);font-size:var(--jse-font-size);background:var(--jse-panel-background);color:var(--jse-panel-color-readonly);box-shadow:var(--jse-controls-box-shadow);display:inline-block;width:400px;max-width:100%;overflow:auto}.jse-search-box.svelte-8auxqr .jse-search-form.svelte-8auxqr{display:flex;align-items:stretch}.jse-search-box.svelte-8auxqr .jse-search-form button.svelte-8auxqr,.jse-search-box.svelte-8auxqr .jse-search-form input.svelte-8auxqr{font-family:inherit;font-size:inherit}.jse-search-box.svelte-8auxqr .jse-search-form button.svelte-8auxqr{display:block;text-align:center;border:none;padding:0 5px;margin:0;cursor:pointer;color:var(--jse-panel-button-color);background:var(--jse-panel-button-background)}.jse-search-box.svelte-8auxqr .jse-search-form button.svelte-8auxqr:hover{color:var(--jse-panel-button-color-highlight);background:var(--jse-panel-button-background-highlight)}.jse-search-box.svelte-8auxqr .jse-search-form input.svelte-8auxqr{color:var(--jse-panel-color);border:var(--jse-input-border);border-radius:3px;background:var(--jse-input-background);height:28px;padding:0 5px;margin:0;flex:1;outline:none}.jse-search-box.svelte-8auxqr .jse-search-form .jse-replace-toggle.svelte-8auxqr{padding:var(--jse-padding) calc(0.5 * var(--jse-padding));min-width:20px;background:var(--jse-panel-button-background-highlight)}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents.svelte-8auxqr{flex:1;display:flex;flex-direction:column;padding:calc(0.5 * var(--jse-padding));gap:calc(0.5 * var(--jse-padding))}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents .jse-search-section.svelte-8auxqr{flex:1;display:flex;align-items:center;position:relative;padding-left:32px}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents .jse-search-section .jse-search-icon.svelte-8auxqr{color:inherit;cursor:inherit;background:inherit;position:absolute;top:calc(0.5 * var(--jse-padding));left:calc(0.5 * var(--jse-padding))}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents .jse-search-section label.jse-search-input-label.svelte-8auxqr{flex:1;display:flex}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents .jse-search-section .jse-search-count.svelte-8auxqr{color:inherit;font-size:80%;visibility:hidden;padding:0 5px;min-width:36px;text-align:center}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents .jse-search-section .jse-search-count.jse-visible.svelte-8auxqr{visibility:visible}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents .jse-replace-section.svelte-8auxqr{padding-left:32px;flex:1;display:flex}.jse-search-box.svelte-8auxqr .jse-search-form .jse-search-contents .jse-replace-section button.svelte-8auxqr{width:auto}.svelte-8auxqr.svelte-8auxqr{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoQm94LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzTDZCLGVBQUEsNEJBQUEsQ0FBQSwweUZBZ0c1QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTZWFyY2hCb3guc3ZlbHRlIl19 */");
}
function create_if_block20(ctx) {
  let div4;
  let form;
  let t0;
  let div3;
  let div2;
  let div0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let label;
  let input;
  let initSearchInput_action;
  let t2;
  let div1;
  let t3_value = ctx[3] !== -1 ? `${ctx[3] + 1}/` : "";
  let t3;
  let t4;
  let t5;
  let button0;
  let icon0;
  let t6;
  let button1;
  let icon1;
  let t7;
  let button2;
  let icon2;
  let t8;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[4] && create_if_block_36(ctx);
  const if_block_creators = [create_if_block_29, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  icon0 = new Icon_default({
    props: { data: faChevronDown },
    $$inline: true
  });
  icon1 = new Icon_default({
    props: { data: faChevronUp },
    $$inline: true
  });
  icon2 = new Icon_default({ props: { data: faTimes }, $$inline: true });
  let if_block2 = ctx[0] && !ctx[4] && create_if_block_112(ctx);
  const block = {
    c: function create() {
      div4 = element("div");
      form = element("form");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      if_block1.c();
      t1 = space();
      label = element("label");
      input = element("input");
      t2 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = text(ctx[10]);
      t5 = space();
      button0 = element("button");
      create_component(icon0.$$.fragment);
      t6 = space();
      button1 = element("button");
      create_component(icon1.$$.fragment);
      t7 = space();
      button2 = element("button");
      create_component(icon2.$$.fragment);
      t8 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      form = claim_element(div4_nodes, "FORM", { class: true });
      var form_nodes = children(form);
      if (if_block0)
        if_block0.l(form_nodes);
      t0 = claim_space(form_nodes);
      div3 = claim_element(form_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      label = claim_element(div2_nodes, "LABEL", { class: true, about: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", {
        class: true,
        title: true,
        type: true,
        placeholder: true
      });
      label_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t3 = claim_text(div1_nodes, t3_value);
      t4 = claim_text(div1_nodes, ctx[10]);
      div1_nodes.forEach(detach_dev);
      t5 = claim_space(div2_nodes);
      button0 = claim_element(div2_nodes, "BUTTON", { type: true, class: true, title: true });
      var button0_nodes = children(button0);
      claim_component(icon0.$$.fragment, button0_nodes);
      button0_nodes.forEach(detach_dev);
      t6 = claim_space(div2_nodes);
      button1 = claim_element(div2_nodes, "BUTTON", { type: true, class: true, title: true });
      var button1_nodes = children(button1);
      claim_component(icon1.$$.fragment, button1_nodes);
      button1_nodes.forEach(detach_dev);
      t7 = claim_space(div2_nodes);
      button2 = claim_element(div2_nodes, "BUTTON", { type: true, class: true, title: true });
      var button2_nodes = children(button2);
      claim_component(icon2.$$.fragment, button2_nodes);
      button2_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t8 = claim_space(div3_nodes);
      if (if_block2)
        if_block2.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-search-icon svelte-8auxqr");
      add_location(div0, file31, 113, 10, 3214);
      attr_dev(input, "class", "jse-search-input svelte-8auxqr");
      attr_dev(input, "title", "Enter text to search");
      attr_dev(input, "type", "text");
      attr_dev(input, "placeholder", "Find");
      add_location(input, file31, 121, 12, 3501);
      attr_dev(label, "class", "jse-search-input-label svelte-8auxqr");
      attr_dev(label, "about", "jse-search input");
      add_location(label, file31, 120, 10, 3425);
      attr_dev(div1, "class", "jse-search-count svelte-8auxqr");
      toggle_class(div1, "jse-visible", ctx[8] !== "");
      add_location(div1, file31, 130, 10, 3759);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "jse-search-next svelte-8auxqr");
      attr_dev(button0, "title", "Go to next search result (Enter)");
      add_location(button0, file31, 133, 10, 3933);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", "jse-search-previous svelte-8auxqr");
      attr_dev(button1, "title", "Go to previous search result (Shift+Enter)");
      add_location(button1, file31, 141, 10, 4178);
      attr_dev(button2, "type", "button");
      attr_dev(button2, "class", "jse-search-clear svelte-8auxqr");
      attr_dev(button2, "title", "Close search box (Esc)");
      add_location(button2, file31, 149, 10, 4439);
      attr_dev(div2, "class", "jse-search-section svelte-8auxqr");
      add_location(div2, file31, 112, 8, 3171);
      attr_dev(div3, "class", "jse-search-contents svelte-8auxqr");
      add_location(div3, file31, 111, 6, 3129);
      attr_dev(form, "class", "jse-search-form svelte-8auxqr");
      add_location(form, file31, 100, 4, 2731);
      attr_dev(div4, "class", "jse-search-box svelte-8auxqr");
      add_location(div4, file31, 99, 2, 2698);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, form);
      if (if_block0)
        if_block0.m(form, null);
      append_hydration_dev(form, t0);
      append_hydration_dev(form, div3);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, label);
      append_hydration_dev(label, input);
      set_input_value(input, ctx[8]);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, t4);
      append_hydration_dev(div2, t5);
      append_hydration_dev(div2, button0);
      mount_component(icon0, button0, null);
      append_hydration_dev(div2, t6);
      append_hydration_dev(div2, button1);
      mount_component(icon1, button1, null);
      append_hydration_dev(div2, t7);
      append_hydration_dev(div2, button2);
      mount_component(icon2, button2, null);
      append_hydration_dev(div3, t8);
      if (if_block2)
        if_block2.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[21]),
          action_destroyer(initSearchInput_action = initSearchInput.call(null, input)),
          listen_dev(button0, "click", ctx[22], false, false, false),
          listen_dev(button1, "click", ctx[23], false, false, false),
          listen_dev(button2, "click", ctx[24], false, false, false),
          listen_dev(form, "submit", ctx[12], false, false, false),
          listen_dev(form, "keydown", ctx[13], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_36(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(form, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      if (dirty & 256 && input.value !== ctx2[8]) {
        set_input_value(input, ctx2[8]);
      }
      if ((!current || dirty & 8) && t3_value !== (t3_value = ctx2[3] !== -1 ? `${ctx2[3] + 1}/` : ""))
        set_data_dev(t3, t3_value);
      if (!current || dirty & 1024)
        set_data_dev(t4, ctx2[10]);
      if (!current || dirty & 256) {
        toggle_class(div1, "jse-visible", ctx2[8] !== "");
      }
      if (ctx2[0] && !ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_112(ctx2);
          if_block2.c();
          if_block2.m(div3, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div4);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(99:0) {#if show}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: {
      data: ctx[0] ? faCaretDown : faCaretRight
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-replace-toggle svelte-8auxqr");
      attr_dev(button, "title", "Toggle visibility of replace options (Ctrl+H)");
      add_location(button, file31, 102, 8, 2844);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[11], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & 1)
        icon_changes.data = ctx2[0] ? faCaretDown : faCaretRight;
      icon.$set(icon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(102:6) {#if !readOnly}",
    ctx
  });
  return block;
}
function create_else_block10(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faSearch },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(117:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faCircleNotch, spin: true },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(115:12) {#if searching}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let div;
  let input;
  let t0;
  let button0;
  let t1;
  let t2;
  let button1;
  let t3;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      button0 = element("button");
      t1 = text("Replace");
      t2 = space();
      button1 = element("button");
      t3 = text("All");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        class: true,
        title: true,
        type: true,
        placeholder: true
      });
      t0 = claim_space(div_nodes);
      button0 = claim_element(div_nodes, "BUTTON", { type: true, title: true, class: true });
      var button0_nodes = children(button0);
      t1 = claim_text(button0_nodes, "Replace");
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      button1 = claim_element(div_nodes, "BUTTON", { type: true, title: true, class: true });
      var button1_nodes = children(button1);
      t3 = claim_text(button1_nodes, "All");
      button1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "jse-replace-input svelte-8auxqr");
      attr_dev(input, "title", "Enter replacement text");
      attr_dev(input, "type", "text");
      attr_dev(input, "placeholder", "Replace");
      add_location(input, file31, 160, 12, 4770);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "title", "Replace current occurrence (Ctrl+Enter)");
      attr_dev(button0, "class", "svelte-8auxqr");
      add_location(button0, file31, 167, 12, 4990);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "title", "Replace all occurrences");
      attr_dev(button1, "class", "svelte-8auxqr");
      add_location(button1, file31, 172, 12, 5169);
      attr_dev(div, "class", "jse-replace-section svelte-8auxqr");
      add_location(div, file31, 159, 10, 4724);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      set_input_value(input, ctx[9]);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, button0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(div, t2);
      append_hydration_dev(div, button1);
      append_hydration_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[25]),
          listen_dev(button0, "click", ctx[14], false, false, false),
          listen_dev(button1, "click", ctx[15], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 512 && input.value !== ctx2[9]) {
        set_input_value(input, ctx2[9]);
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(159:8) {#if showReplace && !readOnly}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block20(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function initSearchInput(element2) {
  element2.select();
}
function instance36($$self, $$props, $$invalidate) {
  let formattedResultCount;
  let onChangeDebounced;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SearchBox", slots, []);
  let { show = false } = $$props;
  let { searching } = $$props;
  let { resultCount = 0 } = $$props;
  let { activeIndex = 0 } = $$props;
  let { showReplace = false } = $$props;
  let { readOnly = false } = $$props;
  let { onChange = noop_default } = $$props;
  let { onPrevious = noop_default } = $$props;
  let { onNext = noop_default } = $$props;
  let { onReplace = noop_default } = $$props;
  let { onReplaceAll = noop_default } = $$props;
  let { onClose = noop_default } = $$props;
  let text2 = "";
  let previousText = "";
  let replaceText2 = "";
  function initShow() {
    if (text2 !== "") {
      onChange(text2);
    }
  }
  function toggleShowReplace() {
    $$invalidate(0, showReplace = !showReplace && !readOnly);
  }
  function handleSubmit(event) {
    event.preventDefault();
    const pendingChanges = text2 !== previousText;
    if (pendingChanges) {
      previousText = text2;
      onChangeDebounced.cancel();
      onChange(text2);
    } else {
      onNext();
    }
  }
  function handleKeyDown(event) {
    event.stopPropagation();
    const combo = keyComboFromEvent(event);
    if (combo === "Enter") {
      event.preventDefault();
      onNext();
    }
    if (combo === "Shift+Enter") {
      event.preventDefault();
      onPrevious();
    }
    if (combo === "Ctrl+Enter" || combo === "Command+Enter") {
      event.preventDefault();
      if (showReplace) {
        handleReplace();
      } else {
        onNext();
      }
    }
    if (combo === "Ctrl+H") {
      event.preventDefault();
      toggleShowReplace();
    }
    if (combo === "Escape") {
      event.preventDefault();
      onClose();
    }
  }
  function handleReplace() {
    if (readOnly) {
      return;
    }
    onReplace(text2, replaceText2);
  }
  function handleReplaceAll() {
    if (readOnly) {
      return;
    }
    onReplaceAll(text2, replaceText2);
  }
  $$self.$$.on_mount.push(function() {
    if (searching === void 0 && !("searching" in $$props || $$self.$$.bound[$$self.$$.props["searching"]])) {
      console.warn("<SearchBox> was created without expected prop 'searching'");
    }
  });
  const writable_props = [
    "show",
    "searching",
    "resultCount",
    "activeIndex",
    "showReplace",
    "readOnly",
    "onChange",
    "onPrevious",
    "onNext",
    "onReplace",
    "onReplaceAll",
    "onClose"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SearchBox> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    text2 = this.value;
    $$invalidate(8, text2);
  }
  const click_handler = () => onNext();
  const click_handler_1 = () => onPrevious();
  const click_handler_2 = () => onClose();
  function input_input_handler_1() {
    replaceText2 = this.value;
    $$invalidate(9, replaceText2);
  }
  $$self.$$set = ($$props2) => {
    if ("show" in $$props2)
      $$invalidate(1, show = $$props2.show);
    if ("searching" in $$props2)
      $$invalidate(2, searching = $$props2.searching);
    if ("resultCount" in $$props2)
      $$invalidate(16, resultCount = $$props2.resultCount);
    if ("activeIndex" in $$props2)
      $$invalidate(3, activeIndex = $$props2.activeIndex);
    if ("showReplace" in $$props2)
      $$invalidate(0, showReplace = $$props2.showReplace);
    if ("readOnly" in $$props2)
      $$invalidate(4, readOnly = $$props2.readOnly);
    if ("onChange" in $$props2)
      $$invalidate(17, onChange = $$props2.onChange);
    if ("onPrevious" in $$props2)
      $$invalidate(5, onPrevious = $$props2.onPrevious);
    if ("onNext" in $$props2)
      $$invalidate(6, onNext = $$props2.onNext);
    if ("onReplace" in $$props2)
      $$invalidate(18, onReplace = $$props2.onReplace);
    if ("onReplaceAll" in $$props2)
      $$invalidate(19, onReplaceAll = $$props2.onReplaceAll);
    if ("onClose" in $$props2)
      $$invalidate(7, onClose = $$props2.onClose);
  };
  $$self.$capture_state = () => ({
    debounce: debounce_default,
    noop: noop_default,
    Icon: Icon_default,
    faCaretDown,
    faCaretRight,
    faChevronDown,
    faChevronUp,
    faCircleNotch,
    faSearch,
    faTimes,
    DEBOUNCE_DELAY,
    MAX_SEARCH_RESULTS,
    keyComboFromEvent,
    show,
    searching,
    resultCount,
    activeIndex,
    showReplace,
    readOnly,
    onChange,
    onPrevious,
    onNext,
    onReplace,
    onReplaceAll,
    onClose,
    text: text2,
    previousText,
    replaceText: replaceText2,
    initShow,
    toggleShowReplace,
    handleSubmit,
    handleKeyDown,
    handleReplace,
    handleReplaceAll,
    initSearchInput,
    onChangeDebounced,
    formattedResultCount
  });
  $$self.$inject_state = ($$props2) => {
    if ("show" in $$props2)
      $$invalidate(1, show = $$props2.show);
    if ("searching" in $$props2)
      $$invalidate(2, searching = $$props2.searching);
    if ("resultCount" in $$props2)
      $$invalidate(16, resultCount = $$props2.resultCount);
    if ("activeIndex" in $$props2)
      $$invalidate(3, activeIndex = $$props2.activeIndex);
    if ("showReplace" in $$props2)
      $$invalidate(0, showReplace = $$props2.showReplace);
    if ("readOnly" in $$props2)
      $$invalidate(4, readOnly = $$props2.readOnly);
    if ("onChange" in $$props2)
      $$invalidate(17, onChange = $$props2.onChange);
    if ("onPrevious" in $$props2)
      $$invalidate(5, onPrevious = $$props2.onPrevious);
    if ("onNext" in $$props2)
      $$invalidate(6, onNext = $$props2.onNext);
    if ("onReplace" in $$props2)
      $$invalidate(18, onReplace = $$props2.onReplace);
    if ("onReplaceAll" in $$props2)
      $$invalidate(19, onReplaceAll = $$props2.onReplaceAll);
    if ("onClose" in $$props2)
      $$invalidate(7, onClose = $$props2.onClose);
    if ("text" in $$props2)
      $$invalidate(8, text2 = $$props2.text);
    if ("previousText" in $$props2)
      previousText = $$props2.previousText;
    if ("replaceText" in $$props2)
      $$invalidate(9, replaceText2 = $$props2.replaceText);
    if ("onChangeDebounced" in $$props2)
      $$invalidate(20, onChangeDebounced = $$props2.onChangeDebounced);
    if ("formattedResultCount" in $$props2)
      $$invalidate(10, formattedResultCount = $$props2.formattedResultCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 65536) {
      $:
        $$invalidate(10, formattedResultCount = resultCount >= MAX_SEARCH_RESULTS ? `${MAX_SEARCH_RESULTS - 1}+` : String(resultCount));
    }
    if ($$self.$$.dirty & 131072) {
      $:
        $$invalidate(20, onChangeDebounced = debounce_default(onChange, DEBOUNCE_DELAY));
    }
    if ($$self.$$.dirty & 1048832) {
      $:
        onChangeDebounced(text2);
    }
    if ($$self.$$.dirty & 2) {
      $:
        if (show) {
          initShow();
        }
    }
  };
  return [
    showReplace,
    show,
    searching,
    activeIndex,
    readOnly,
    onPrevious,
    onNext,
    onClose,
    text2,
    replaceText2,
    formattedResultCount,
    toggleShowReplace,
    handleSubmit,
    handleKeyDown,
    handleReplace,
    handleReplaceAll,
    resultCount,
    onChange,
    onReplace,
    onReplaceAll,
    onChangeDebounced,
    input_input_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    input_input_handler_1
  ];
}
var SearchBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance36,
      create_fragment36,
      not_equal,
      {
        show: 1,
        searching: 2,
        resultCount: 16,
        activeIndex: 3,
        showReplace: 0,
        readOnly: 4,
        onChange: 17,
        onPrevious: 5,
        onNext: 6,
        onReplace: 18,
        onReplaceAll: 19,
        onClose: 7
      },
      add_css28
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SearchBox",
      options,
      id: create_fragment36.name
    });
  }
  get show() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searching() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searching(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resultCount() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resultCount(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showReplace() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showReplace(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPrevious() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPrevious(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onNext() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onNext(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onReplace() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onReplace(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onReplaceAll() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onReplaceAll(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClose() {
    throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClose(value) {
    throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SearchBox_default = SearchBox;

// ../node_modules/svelte-jsoneditor/components/modes/treemode/TreeMode.svelte
var { Error: Error_13, window: window_13 } = globals;
var file32 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modes/treemode/TreeMode.svelte";
function add_css29(target) {
  append_styles(target, "svelte-mjwruf", ".jse-tree-mode.svelte-mjwruf.svelte-mjwruf{flex:1;display:flex;flex-direction:column;position:relative;background:var(--jse-background-color);min-width:0;min-height:0;font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);color:var(--jse-text-color);line-height:var(--jse-line-height)}.jse-tree-mode.svelte-mjwruf .jse-hidden-input-label.svelte-mjwruf{position:fixed;right:0;top:0;width:0;height:0}.jse-tree-mode.svelte-mjwruf .jse-hidden-input-label .jse-hidden-input.svelte-mjwruf{width:0;height:0;padding:0;border:0;outline:none}.jse-tree-mode.svelte-mjwruf .jse-search-box-container.svelte-mjwruf{position:relative;height:0;top:var(--jse-padding);margin-right:calc(var(--jse-padding) + 20px);margin-left:var(--jse-padding);text-align:right;z-index:3}.jse-tree-mode.no-main-menu.svelte-mjwruf.svelte-mjwruf{border-top:var(--jse-main-border)}.jse-tree-mode.svelte-mjwruf .jse-contents.svelte-mjwruf{border-left:var(--jse-main-border);border-right:var(--jse-main-border);flex:1;overflow:auto;position:relative;padding:2px;display:flex;flex-direction:column}.jse-tree-mode.svelte-mjwruf .jse-contents.svelte-mjwruf:last-child{border-bottom:var(--jse-main-border)}.jse-tree-mode.svelte-mjwruf .jse-contents .jse-loading-space.svelte-mjwruf{flex:1}.jse-tree-mode.svelte-mjwruf .jse-contents .jse-loading.svelte-mjwruf{flex:2;text-align:center;color:var(--jse-panel-color-readonly);box-sizing:border-box;font-family:var(--jse-font-family);font-size:var(--jse-font-size)}.jse-tree-mode.svelte-mjwruf .jse-preview.svelte-mjwruf{flex:1;color:var(--jse-panel-color-readonly);overflow:auto;white-space:pre-wrap;padding:2px}.svelte-mjwruf.svelte-mjwruf{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJlZU1vZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWsyRDRCLGNBQUEsNEJBQUEsQ0FBQSx1bERBcUUzQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUcmVlTW9kZS5zdmVsdGUiXX0= */");
}
function create_if_block_62(ctx) {
  let treemenu;
  let updating_showSearch;
  let current;
  function treemenu_showSearch_binding(value) {
    ctx[73](value);
  }
  let treemenu_props = {
    json: ctx[9],
    selection: ctx[15].selection,
    readOnly: ctx[0],
    historyState: ctx[21],
    onExpandAll: ctx[39],
    onCollapseAll: ctx[40],
    onUndo: ctx[35],
    onRedo: ctx[36],
    onSort: ctx[37],
    onTransform: ctx[38],
    onContextMenu: ctx[44],
    onCopy: ctx[33],
    onRenderMenu: ctx[6]
  };
  if (ctx[18] !== void 0) {
    treemenu_props.showSearch = ctx[18];
  }
  treemenu = new TreeMenu_default({ props: treemenu_props, $$inline: true });
  binding_callbacks.push(() => bind(treemenu, "showSearch", treemenu_showSearch_binding));
  const block = {
    c: function create() {
      create_component(treemenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treemenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treemenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treemenu_changes = {};
      if (dirty[0] & 512)
        treemenu_changes.json = ctx2[9];
      if (dirty[0] & 32768)
        treemenu_changes.selection = ctx2[15].selection;
      if (dirty[0] & 1)
        treemenu_changes.readOnly = ctx2[0];
      if (dirty[0] & 2097152)
        treemenu_changes.historyState = ctx2[21];
      if (dirty[0] & 64)
        treemenu_changes.onRenderMenu = ctx2[6];
      if (!updating_showSearch && dirty[0] & 262144) {
        updating_showSearch = true;
        treemenu_changes.showSearch = ctx2[18];
        add_flush_callback(() => updating_showSearch = false);
      }
      treemenu.$set(treemenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treemenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treemenu.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(treemenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(1743:2) {#if mainMenuBar}",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let navigationbar;
  let current;
  navigationbar = new NavigationBar_default({
    props: {
      json: ctx[9],
      documentState: ctx[15],
      onSelect: ctx[47],
      onError: ctx[4],
      pathParser: ctx[3]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navigationbar.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(navigationbar.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(navigationbar, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navigationbar_changes = {};
      if (dirty[0] & 512)
        navigationbar_changes.json = ctx2[9];
      if (dirty[0] & 32768)
        navigationbar_changes.documentState = ctx2[15];
      if (dirty[0] & 16)
        navigationbar_changes.onError = ctx2[4];
      if (dirty[0] & 8)
        navigationbar_changes.pathParser = ctx2[3];
      navigationbar.$set(navigationbar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navigationbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navigationbar.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(navigationbar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(1762:2) {#if navigationBar}",
    ctx
  });
  return block;
}
function create_else_block_22(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text("loading...");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, "loading...");
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-loading-space svelte-mjwruf");
      add_location(div0, file32, 1884, 6, 69249);
      attr_dev(div1, "class", "jse-loading svelte-mjwruf");
      add_location(div1, file32, 1885, 6, 69289);
      attr_dev(div2, "class", "jse-contents svelte-mjwruf");
      add_location(div2, file32, 1883, 4, 69216);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_22.name,
    type: "else",
    source: "(1883:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let label;
  let input;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_113, create_else_block_13];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[9] === void 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t = space();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      input = claim_element(label_nodes, "INPUT", { type: true, tabindex: true, class: true });
      label_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      input.readOnly = "readonly";
      attr_dev(input, "tabindex", "-1");
      attr_dev(input, "class", "jse-hidden-input svelte-mjwruf");
      add_location(input, file32, 1773, 6, 65795);
      attr_dev(label, "class", "jse-hidden-input-label svelte-mjwruf");
      add_location(label, file32, 1772, 4, 65750);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, input);
      ctx[74](input);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(input, "paste", ctx[34], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(label);
      ctx[74](null);
      if (detaching)
        detach_dev(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(1772:2) {#if !isSSR}",
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  var _a, _b, _c, _d;
  let div0;
  let searchbox;
  let t0;
  let div1;
  let jsonnode;
  let div1_data_jsoneditor_scrollable_contents_value;
  let t1;
  let t2;
  let t3;
  let validationerrorsoverview;
  let current;
  searchbox = new SearchBox_default({
    props: {
      show: ctx[18],
      resultCount: ((_b = (_a = ctx[16]) == null ? void 0 : _a.items) == null ? void 0 : _b.length) || 0,
      activeIndex: ((_c = ctx[16]) == null ? void 0 : _c.activeIndex) || 0,
      showReplace: ctx[19],
      searching: ctx[20],
      readOnly: ctx[0],
      onChange: ctx[26],
      onNext: ctx[27],
      onPrevious: ctx[28],
      onReplace: ctx[29],
      onReplaceAll: ctx[30],
      onClose: ctx[31]
    },
    $$inline: true
  });
  jsonnode = new JSONNode_default({
    props: {
      value: ctx[9],
      path: ctx[25],
      expandedMap: ctx[15].expandedMap,
      enforceStringMap: ctx[15].enforceStringMap,
      visibleSectionsMap: ctx[15].visibleSectionsMap,
      validationErrorsMap: ctx[23],
      searchResultItemsMap: (_d = ctx[16]) == null ? void 0 : _d.itemsMap,
      selection: ctx[15].selection,
      context: ctx[12],
      onDragSelectionStart: noop_default
    },
    $$inline: true
  });
  let if_block0 = ctx[17] && create_if_block_43(ctx);
  let if_block1 = ctx[22] && create_if_block_37(ctx);
  validationerrorsoverview = new ValidationErrorsOverview_default({
    props: {
      validationErrors: ctx[11],
      selectError: ctx[32]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div0 = element("div");
      create_component(searchbox.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(jsonnode.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      create_component(validationerrorsoverview.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(searchbox.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-jsoneditor-scrollable-contents": true
      });
      var div1_nodes = children(div1);
      claim_component(jsonnode.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t2 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t3 = claim_space(nodes);
      claim_component(validationerrorsoverview.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-search-box-container svelte-mjwruf");
      add_location(div0, file32, 1804, 6, 66629);
      attr_dev(div1, "class", "jse-contents svelte-mjwruf");
      attr_dev(div1, "data-jsoneditor-scrollable-contents", div1_data_jsoneditor_scrollable_contents_value = true);
      add_location(div1, file32, 1820, 6, 67170);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      mount_component(searchbox, div0, null);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div1, anchor);
      mount_component(jsonnode, div1, null);
      ctx[75](div1);
      insert_hydration_dev(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(validationerrorsoverview, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2, _c2, _d2;
      const searchbox_changes = {};
      if (dirty[0] & 262144)
        searchbox_changes.show = ctx2[18];
      if (dirty[0] & 65536)
        searchbox_changes.resultCount = ((_b2 = (_a2 = ctx2[16]) == null ? void 0 : _a2.items) == null ? void 0 : _b2.length) || 0;
      if (dirty[0] & 65536)
        searchbox_changes.activeIndex = ((_c2 = ctx2[16]) == null ? void 0 : _c2.activeIndex) || 0;
      if (dirty[0] & 524288)
        searchbox_changes.showReplace = ctx2[19];
      if (dirty[0] & 1048576)
        searchbox_changes.searching = ctx2[20];
      if (dirty[0] & 1)
        searchbox_changes.readOnly = ctx2[0];
      searchbox.$set(searchbox_changes);
      const jsonnode_changes = {};
      if (dirty[0] & 512)
        jsonnode_changes.value = ctx2[9];
      if (dirty[0] & 32768)
        jsonnode_changes.expandedMap = ctx2[15].expandedMap;
      if (dirty[0] & 32768)
        jsonnode_changes.enforceStringMap = ctx2[15].enforceStringMap;
      if (dirty[0] & 32768)
        jsonnode_changes.visibleSectionsMap = ctx2[15].visibleSectionsMap;
      if (dirty[0] & 8388608)
        jsonnode_changes.validationErrorsMap = ctx2[23];
      if (dirty[0] & 65536)
        jsonnode_changes.searchResultItemsMap = (_d2 = ctx2[16]) == null ? void 0 : _d2.itemsMap;
      if (dirty[0] & 32768)
        jsonnode_changes.selection = ctx2[15].selection;
      if (dirty[0] & 4096)
        jsonnode_changes.context = ctx2[12];
      jsonnode.$set(jsonnode_changes);
      if (ctx2[17]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_43(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[22]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4194304) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_37(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const validationerrorsoverview_changes = {};
      if (dirty[0] & 2048)
        validationerrorsoverview_changes.validationErrors = ctx2[11];
      validationerrorsoverview.$set(validationerrorsoverview_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchbox.$$.fragment, local);
      transition_in(jsonnode.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(validationerrorsoverview.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchbox.$$.fragment, local);
      transition_out(jsonnode.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(validationerrorsoverview.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div0);
      destroy_component(searchbox);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div1);
      destroy_component(jsonnode);
      ctx[75](null);
      if (detaching)
        detach_dev(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(validationerrorsoverview, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(1804:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_210, create_else_block11];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[10] === "" || ctx2[10] === void 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(1783:4) {#if json === undefined}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let message;
  let current;
  message = new Message_default({
    props: {
      type: "info",
      message: `You pasted a JSON ${Array.isArray(ctx[17].contents) ? "array" : "object"} as text`,
      actions: [
        {
          icon: faWrench,
          text: "Paste as JSON instead",
          onMouseDown: ctx[45]
        },
        {
          text: "Leave as is",
          onClick: ctx[46]
        }
      ]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty[0] & 131072)
        message_changes.message = `You pasted a JSON ${Array.isArray(ctx2[17].contents) ? "array" : "object"} as text`;
      message.$set(message_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(message, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(1836:6) {#if pastedJson}",
    ctx
  });
  return block;
}
function create_if_block_37(ctx) {
  let message;
  let current;
  message = new Message_default({
    props: {
      type: "success",
      message: "The loaded JSON document was invalid but is successfully repaired.",
      actions: !ctx[0] ? [
        {
          icon: faCheck,
          text: "Ok",
          onClick: ctx[7]
        },
        {
          icon: faCode,
          text: "Repair manually instead",
          onClick: ctx[5]
        }
      ] : []
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty[0] & 33)
        message_changes.actions = !ctx2[0] ? [
          {
            icon: faCheck,
            text: "Ok",
            onClick: ctx2[7]
          },
          {
            icon: faCode,
            text: "Repair manually instead",
            onClick: ctx2[5]
          }
        ] : [];
      message.$set(message_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(message, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: "(1860:6) {#if textIsRepaired}",
    ctx
  });
  return block;
}
function create_else_block11(ctx) {
  let message;
  let t0;
  let div;
  let t1_value = truncate(ctx[10], MAX_CHARACTERS_TEXT_PREVIEW) + "";
  let t1;
  let current;
  message = new Message_default({
    props: {
      type: "error",
      message: "The loaded JSON document is invalid and could not be repaired automatically.",
      actions: !ctx[0] ? [
        {
          icon: faCode,
          text: "Repair manually",
          onClick: ctx[5]
        }
      ] : []
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-preview svelte-mjwruf");
      add_location(div, file32, 1799, 8, 66502);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty[0] & 33)
        message_changes.actions = !ctx2[0] ? [
          {
            icon: faCode,
            text: "Repair manually",
            onClick: ctx2[5]
          }
        ] : [];
      message.$set(message_changes);
      if ((!current || dirty[0] & 1024) && t1_value !== (t1_value = truncate(ctx2[10], MAX_CHARACTERS_TEXT_PREVIEW) + ""))
        set_data_dev(t1, t1_value);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(message, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(1786:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let welcome;
  let current;
  welcome = new Welcome_default({
    props: { readOnly: ctx[0] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(welcome.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(welcome.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(welcome, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const welcome_changes = {};
      if (dirty[0] & 1)
        welcome_changes.readOnly = ctx2[0];
      welcome.$set(welcome_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(welcome.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(welcome.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(welcome, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(1784:6) {#if text === '' || text === undefined}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let div;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block2;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1] && create_if_block_62(ctx);
  let if_block1 = ctx[2] && create_if_block_53(ctx);
  const if_block_creators = [create_if_block21, create_else_block_22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[24])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-tree-mode svelte-mjwruf");
      toggle_class(div, "no-main-menu", !ctx[1]);
      add_location(div, file32, 1734, 0, 64907);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      ctx[76](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window_13, "mousedown", ctx[48], false, false, false),
          listen_dev(div, "keydown", ctx[41], false, false, false),
          listen_dev(div, "mousedown", ctx[42], false, false, false),
          listen_dev(div, "contextmenu", ctx[43], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_62(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_53(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if_block2.p(ctx2, dirty);
      if (!current || dirty[0] & 2) {
        toggle_class(div, "no-main-menu", !ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      ctx[76](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function expandMinimal(path) {
  return path.length === 0 ? true : path.length === 1 && path[0] === "0";
}
function expandAll() {
  return true;
}
function instance37($$self, $$props, $$invalidate) {
  let textIsUnrepairable;
  let autoScrollHandler;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeMode", slots, []);
  const debug5 = createDebug("jsoneditor:TreeMode");
  const isSSR = typeof window === "undefined";
  debug5("isSSR:", isSSR);
  const { open } = getContext("simple-modal");
  const sortModalId = uniqueId_default();
  const transformModalId = uniqueId_default();
  const { openAbsolutePopup, closeAbsolutePopup } = getContext("absolute-popup");
  let refContents;
  let refHiddenInput;
  let refJsonEditor;
  let hasFocus = false;
  const jump = createJump();
  let { readOnly } = $$props;
  let { externalContent } = $$props;
  let { mainMenuBar } = $$props;
  let { navigationBar } = $$props;
  let { escapeControlCharacters } = $$props;
  let { escapeUnicodeCharacters } = $$props;
  let { parser } = $$props;
  let { validator } = $$props;
  let { validationParser } = $$props;
  let { pathParser } = $$props;
  let { indentation } = $$props;
  let { onError } = $$props;
  let { onChange } = $$props;
  let { onRenderValue } = $$props;
  let { onRequestRepair } = $$props;
  let { onRenderMenu } = $$props;
  let { onClassName } = $$props;
  let { onFocus } = $$props;
  let { onBlur } = $$props;
  let { onSortModal } = $$props;
  let { onTransformModal } = $$props;
  let modalOpen = false;
  createFocusTracker({
    onMount,
    onDestroy,
    getWindow: () => getWindow(refJsonEditor),
    hasFocus: () => modalOpen && document.hasFocus() || activeElementIsChildOf(refJsonEditor),
    onFocus: () => {
      hasFocus = true;
      if (onFocus) {
        onFocus();
      }
    },
    onBlur: () => {
      hasFocus = false;
      if (onBlur) {
        onBlur();
      }
    }
  });
  let json2;
  let text2;
  const rootPath = [];
  let parseError = void 0;
  function updateSelection(selection) {
    debug5("updateSelection", selection);
    const updatedSelection = typeof selection === "function" ? selection(documentState.selection) : selection;
    if (!isEqual_default(updatedSelection, documentState.selection)) {
      $$invalidate(15, documentState = {
        ...documentState,
        selection: updatedSelection
      });
    }
  }
  let documentStateInitialized = false;
  let documentState = createDocumentState();
  let searchResult;
  let normalization;
  let pastedJson;
  function getDefaultExpand(json3) {
    return isLargeContent({ json: json3 }, MAX_DOCUMENT_SIZE_EXPAND_ALL) ? expandMinimal : expandAll;
  }
  let showSearch = false;
  let showReplace = false;
  let searching = false;
  let searchText = "";
  async function handleSearchText(text3) {
    debug5("search text updated", text3);
    $$invalidate(72, searchText = text3);
    await tick();
    await focusActiveSearchResult();
  }
  async function handleNextSearchResult() {
    $$invalidate(16, searchResult = searchResult ? searchNext(searchResult) : void 0);
    await focusActiveSearchResult();
  }
  async function handlePreviousSearchResult() {
    $$invalidate(16, searchResult = searchResult ? searchPrevious(searchResult) : void 0);
    await focusActiveSearchResult();
  }
  async function handleReplace(text3, replacementText) {
    const activeItem = searchResult == null ? void 0 : searchResult.activeItem;
    debug5("handleReplace", { replacementText, activeItem });
    if (!activeItem) {
      return;
    }
    const { operations, newSelection } = createSearchAndReplaceOperations(json2, documentState, replacementText, activeItem, parser);
    handlePatch(operations, (patchedJson, patchedState) => ({
      state: { ...patchedState, selection: newSelection }
    }));
    await tick();
    await focusActiveSearchResult();
  }
  async function handleReplaceAll(text3, replacementText) {
    debug5("handleReplaceAll", { text: text3, replacementText });
    const { operations, newSelection } = createSearchAndReplaceAllOperations(json2, documentState, text3, replacementText, parser);
    handlePatch(operations, (patchedJson, patchedState) => ({
      state: { ...patchedState, selection: newSelection }
    }));
    await tick();
    await focusActiveSearchResult();
  }
  function clearSearchResult() {
    $$invalidate(18, showSearch = false);
    $$invalidate(19, showReplace = false);
    handleSearchText("");
    focus3();
  }
  async function focusActiveSearchResult() {
    const activeItem = searchResult == null ? void 0 : searchResult.activeItem;
    debug5("focusActiveSearchResult", searchResult);
    if (activeItem) {
      const path = activeItem.path;
      $$invalidate(15, documentState = {
        ...expandPath(json2, documentState, path),
        selection: void 0
      });
      await tick();
      await scrollTo(path);
    }
  }
  function applySearch() {
    if (searchText === "") {
      debug5("clearing search result");
      if (searchResult !== void 0) {
        $$invalidate(16, searchResult = void 0);
      }
      return;
    }
    $$invalidate(20, searching = true);
    setTimeout(() => {
      debug5("searching...", searchText);
      const newResultItems = search2(searchText, json2, documentState, MAX_SEARCH_RESULTS);
      $$invalidate(16, searchResult = updateSearchResult(json2, newResultItems, searchResult));
      $$invalidate(20, searching = false);
    });
  }
  function handleSelectValidationError(error) {
    debug5("select validation error", error);
    updateSelection(createValueSelection(error.path, false));
    scrollTo(error.path);
  }
  const history = createHistory({
    onChange: (state) => {
      $$invalidate(21, historyState = state);
    }
  });
  let historyState = history.getState();
  function expand(callback = () => true) {
    debug5("expand");
    const cleanDocumentState = {
      ...documentState,
      expandedMap: {},
      visibleSectionsMap: {}
    };
    $$invalidate(15, documentState = expandWithCallback(json2, cleanDocumentState, rootPath, callback));
  }
  const applySearchThrottled = throttle_default(applySearch, SEARCH_UPDATE_THROTTLE);
  let textIsRepaired = false;
  let validationErrors = [];
  let validationErrorsMap;
  const memoizedValidate = memoizeOne(validateJSON);
  function updateValidationErrors(json3, validator2, parser2, validationParser2) {
    measure(
      () => {
        let newValidationErrors;
        try {
          newValidationErrors = memoizedValidate(json3, validator2, parser2, validationParser2);
        } catch (err) {
          newValidationErrors = [
            {
              path: [],
              message: "Failed to validate: " + err.message,
              severity: ValidationSeverity.warning
            }
          ];
        }
        if (!isEqual_default(newValidationErrors, validationErrors)) {
          debug5("validationErrors changed:", newValidationErrors);
          $$invalidate(11, validationErrors = newValidationErrors);
        }
      },
      (duration) => debug5(`validationErrors updated in ${duration} ms`)
    );
  }
  function validate() {
    debug5("validate");
    if (parseError) {
      return {
        parseError,
        isRepairable: false
      };
    }
    updateValidationErrors(json2, validator, parser, validationParser);
    return { validationErrors };
  }
  function getJson() {
    return json2;
  }
  function getDocumentState() {
    return documentState;
  }
  function applyExternalContent(updatedContent) {
    if (updatedContent.json !== void 0) {
      applyExternalJson(updatedContent.json);
    }
    if (updatedContent.text !== void 0) {
      applyExternalText(updatedContent.text);
    }
  }
  function applyExternalJson(updatedJson) {
    if (updatedJson === void 0) {
      return;
    }
    const isChanged = !isEqual_default(json2, updatedJson);
    debug5("update external json", {
      isChanged,
      currentlyText: json2 === void 0
    });
    if (!isChanged) {
      return;
    }
    const previousContent = { json: json2, text: text2 };
    const previousState = documentState;
    const previousJson = json2;
    const previousText = text2;
    const previousTextIsRepaired = textIsRepaired;
    $$invalidate(9, json2 = updatedJson);
    expandWhenNotInitialized(json2);
    $$invalidate(10, text2 = void 0);
    $$invalidate(22, textIsRepaired = false);
    resetSelectionWhenNotExisting(json2);
    addHistoryItem({
      previousJson,
      previousState,
      previousText,
      previousTextIsRepaired
    });
    const patchResult = null;
    emitOnChange(previousContent, patchResult);
  }
  function applyExternalText(updatedText) {
    if (updatedText === void 0 || externalContent.json !== void 0) {
      return;
    }
    const isChanged = updatedText !== text2;
    debug5("update external text", { isChanged });
    if (!isChanged) {
      return;
    }
    const previousContent = { json: json2, text: text2 };
    const previousJson = json2;
    const previousState = documentState;
    const previousText = text2;
    const previousTextIsRepaired = textIsRepaired;
    try {
      $$invalidate(9, json2 = parser.parse(updatedText));
      expandWhenNotInitialized(json2);
      $$invalidate(10, text2 = updatedText);
      $$invalidate(22, textIsRepaired = false);
      parseError = void 0;
      resetSelectionWhenNotExisting(json2);
    } catch (err) {
      try {
        $$invalidate(9, json2 = parser.parse(jsonrepair(updatedText)));
        expandWhenNotInitialized(json2);
        $$invalidate(10, text2 = updatedText);
        $$invalidate(22, textIsRepaired = true);
        parseError = void 0;
        resetSelectionWhenNotExisting(json2);
      } catch (repairError) {
        $$invalidate(9, json2 = void 0);
        $$invalidate(10, text2 = externalContent.text);
        $$invalidate(22, textIsRepaired = false);
        parseError = normalizeJsonParseError(text2, err.message || err.toString());
        resetSelectionWhenNotExisting(json2);
      }
    }
    addHistoryItem({
      previousJson,
      previousState,
      previousText,
      previousTextIsRepaired
    });
    const patchResult = null;
    emitOnChange(previousContent, patchResult);
  }
  function expandWhenNotInitialized(json3) {
    if (!documentStateInitialized) {
      documentStateInitialized = true;
      $$invalidate(15, documentState = expandWithCallback(json3, documentState, rootPath, getDefaultExpand(json3)));
    }
  }
  function resetSelectionWhenNotExisting(json3) {
    if (documentState.selection === void 0) {
      return;
    }
    if (documentState.selection && existsIn(json3, documentState.selection.anchorPath) && existsIn(json3, documentState.selection.focusPath)) {
      return;
    }
    debug5("resetting selection: path does not exist anymore", documentState.selection);
    $$invalidate(15, documentState = {
      ...documentState,
      selection: getInitialSelection(json3, documentState)
    });
  }
  function addHistoryItem({ previousJson, previousState, previousText, previousTextIsRepaired }) {
    if (previousJson === void 0 && previousText === void 0) {
      return;
    }
    if (json2 !== void 0) {
      if (previousJson !== void 0) {
        history.add({
          undo: {
            patch: [
              {
                op: "replace",
                path: "",
                value: previousJson
              }
            ],
            state: removeEditModeFromSelection(previousState),
            json: void 0,
            text: previousText,
            textIsRepaired: previousTextIsRepaired
          },
          redo: {
            patch: [{ op: "replace", path: "", value: json2 }],
            state: removeEditModeFromSelection(documentState),
            json: void 0,
            text: text2,
            textIsRepaired
          }
        });
      } else {
        history.add({
          undo: {
            patch: void 0,
            json: void 0,
            text: previousText,
            state: removeEditModeFromSelection(previousState),
            textIsRepaired: previousTextIsRepaired
          },
          redo: {
            patch: void 0,
            json: json2,
            state: removeEditModeFromSelection(documentState),
            text: text2,
            textIsRepaired
          }
        });
      }
    } else {
      if (previousJson !== void 0) {
        history.add({
          undo: {
            patch: void 0,
            json: previousJson,
            state: removeEditModeFromSelection(previousState),
            text: previousText,
            textIsRepaired: previousTextIsRepaired
          },
          redo: {
            patch: void 0,
            json: void 0,
            text: text2,
            textIsRepaired,
            state: removeEditModeFromSelection(documentState)
          }
        });
      } else {
      }
    }
  }
  function createDefaultSelection() {
    debug5("createDefaultSelection");
    $$invalidate(15, documentState = {
      ...documentState,
      selection: createMultiSelection(json2 || {}, [], [])
    });
  }
  function patch(operations, afterPatch) {
    debug5("patch", operations, afterPatch);
    if (json2 === void 0) {
      throw new Error("Cannot apply patch: no JSON");
    }
    const previousContent = { json: json2, text: text2 };
    const previousJson = json2;
    const previousState = documentState;
    const previousText = text2;
    const previousTextIsRepaired = textIsRepaired;
    const undo2 = revertJSONPatchWithMoveOperations(json2, operations);
    const patched = documentStatePatch(json2, documentState, operations);
    const updatedSelection = createSelectionFromOperations(json2, operations);
    const patchedDocumentState = updateSelectionInDocumentState(patched.documentState, updatedSelection, false);
    debug5("patch updatedSelection", updatedSelection);
    const callback = typeof afterPatch === "function" ? afterPatch(patched.json, patchedDocumentState) : void 0;
    $$invalidate(9, json2 = callback && callback.json !== void 0 ? callback.json : patched.json);
    const newState = callback && callback.state !== void 0 ? callback.state : patchedDocumentState;
    $$invalidate(15, documentState = newState);
    $$invalidate(10, text2 = void 0);
    $$invalidate(22, textIsRepaired = false);
    resetSelectionWhenNotExisting(json2);
    history.add({
      undo: {
        patch: undo2,
        json: void 0,
        text: previousText,
        state: removeEditModeFromSelection(previousState),
        textIsRepaired: previousTextIsRepaired
      },
      redo: {
        patch: operations,
        json: void 0,
        state: removeEditModeFromSelection(newState),
        text: text2,
        textIsRepaired
      }
    });
    const patchResult = {
      json: json2,
      previousJson,
      undo: undo2,
      redo: operations
    };
    emitOnChange(previousContent, patchResult);
    return patchResult;
  }
  function hasSelectionContents(selection) {
    return isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection);
  }
  function handleEditKey() {
    if (readOnly || !documentState.selection) {
      return;
    }
    updateSelection(createKeySelection(documentState.selection.focusPath, true));
  }
  function handleEditValue() {
    if (readOnly || !documentState.selection) {
      return;
    }
    updateSelection(createValueSelection(documentState.selection.focusPath, true));
  }
  function handleToggleEnforceString() {
    if (readOnly || !isValueSelection(documentState.selection)) {
      return;
    }
    const path = documentState.selection.focusPath;
    const pointer = compileJSONPointer(path);
    const value = getIn(json2, path);
    const enforceString = !getEnforceString(value, documentState.enforceStringMap, pointer, parser);
    const updatedValue = enforceString ? String(value) : stringConvert(String(value), parser);
    debug5("handleToggleEnforceString", { enforceString, value, updatedValue });
    handlePatch(
      [
        {
          op: "replace",
          path: compileJSONPointer(path),
          value: updatedValue
        }
      ],
      (patchedJson, patchedState) => {
        return {
          state: setEnforceString(patchedState, pointer, enforceString)
        };
      }
    );
  }
  function acceptAutoRepair() {
    if (textIsRepaired && json2 !== void 0) {
      handleReplaceJson(json2);
    }
    return { json: json2, text: text2 };
  }
  async function handleCut(indent = true) {
    if (readOnly || !hasSelectionContents(documentState.selection)) {
      return;
    }
    const cutIndentation = indent ? indentation : null;
    const clipboard = selectionToPartialJson(json2, documentState.selection, cutIndentation, parser);
    if (clipboard == null) {
      return;
    }
    debug5("cut", {
      selection: documentState.selection,
      clipboard,
      indent
    });
    await copyToClipBoard(clipboard);
    const { operations, newSelection } = createRemoveOperations(json2, documentState.selection);
    handlePatch(operations, (patchedJson, patchedState) => ({
      state: { ...patchedState, selection: newSelection }
    }));
  }
  async function handleCopy(indent = true) {
    const copyIndentation = indent ? indentation : null;
    const clipboard = selectionToPartialJson(json2, documentState.selection, copyIndentation, parser);
    if (clipboard == null) {
      return;
    }
    debug5("copy", { clipboard, indent });
    await copyToClipBoard(clipboard);
  }
  function handlePaste(event) {
    event.preventDefault();
    if (readOnly) {
      return;
    }
    const clipboardText = event.clipboardData.getData("text/plain");
    try {
      doPaste(clipboardText);
    } catch (err) {
      openRepairModal(clipboardText, (repairedText) => {
        debug5("repaired pasted text: ", repairedText);
        doPaste(repairedText);
      });
    }
  }
  function handlePasteFromMenu() {
    open(
      CopyPasteModal_default,
      {},
      {
        ...SIMPLE_MODAL_OPTIONS,
        styleWindow: { width: "450px" }
      },
      { onClose: () => focus3() }
    );
  }
  function doPaste(clipboardText) {
    if (json2 !== void 0) {
      if (!documentState.selection) {
        createDefaultSelection();
      }
      const operations = insert(json2, documentState.selection, clipboardText, parser);
      debug5("paste", {
        clipboardText,
        operations,
        selection: documentState.selection
      });
      handlePatch(operations, (patchedJson, patchedState) => {
        let updatedState = patchedState;
        operations.filter((operation) => (isJSONPatchAdd(operation) || isJSONPatchReplace(operation)) && isObjectOrArray(operation.value)).forEach((operation) => {
          const path = parsePath(json2, operation.path);
          updatedState = expandRecursive(patchedJson, updatedState, path);
        });
        return { state: updatedState };
      });
    } else {
      debug5("paste text", { clipboardText });
      handleChangeText(clipboardText, (patchedJson, patchedState) => {
        if (patchedJson) {
          const path = [];
          return {
            state: expandRecursive(patchedJson, patchedState, path)
          };
        }
      });
    }
  }
  function openRepairModal(text3, onApply) {
    open(
      JSONRepairModal_default,
      {
        text: text3,
        onParse: parsePartialJson,
        onRepair: repairPartialJson,
        onApply,
        onRenderMenu
      },
      {
        ...SIMPLE_MODAL_OPTIONS,
        styleWindow: { width: "600px", height: "500px" },
        styleContent: { padding: 0, height: "100%" }
      },
      { onClose: () => focus3() }
    );
  }
  function handleRemove() {
    if (readOnly || !documentState.selection) {
      return;
    }
    const removeSelection = isKeySelection(documentState.selection) || isValueSelection(documentState.selection) ? createMultiSelection(json2, documentState.selection.anchorPath, documentState.selection.focusPath) : documentState.selection;
    if (isEmpty_default(documentState.selection.focusPath)) {
      debug5("remove root", { selection: documentState.selection });
      onChange({ text: "", json: void 0 }, { text: text2, json: json2 }, {
        contentErrors: validate(),
        patchResult: null
      });
    } else {
      const { operations, newSelection } = createRemoveOperations(json2, removeSelection);
      debug5("remove", {
        operations,
        selection: documentState.selection,
        newSelection
      });
      handlePatch(operations, (patchedJson, patchedState) => ({
        state: { ...patchedState, selection: newSelection }
      }));
    }
  }
  function handleDuplicate() {
    if (readOnly || !hasSelectionContents(documentState.selection) || isEmpty_default(documentState.selection.focusPath)) {
      return;
    }
    debug5("duplicate", { selection: documentState.selection });
    const operations = duplicate(json2, getSelectionPaths(documentState.selection));
    handlePatch(operations);
  }
  function handleExtract() {
    if (readOnly || !documentState.selection || !isMultiSelection(documentState.selection) && !isValueSelection(documentState.selection) || isEmpty_default(documentState.selection.focusPath)) {
      return;
    }
    debug5("extract", { selection: documentState.selection });
    const operations = extract(json2, documentState.selection);
    handlePatch(operations, (patchedJson, patchedState) => {
      if (isObjectOrArray(patchedJson)) {
        const path = [];
        return {
          state: expandRecursive(patchedJson, patchedState, path)
        };
      }
    });
  }
  function handleInsert(type) {
    if (readOnly || !documentState.selection) {
      return;
    }
    const newValue = createNewValue(json2, documentState.selection, type);
    if (json2 !== void 0) {
      const data = parser.stringify(newValue);
      const operations = insert(json2, documentState.selection, data, parser);
      debug5("handleInsert", { type, operations, newValue, data });
      const operation = last_default(operations.filter((operation2) => operation2.op === "add" || operation2.op === "replace"));
      handlePatch(operations, (patchedJson, patchedState) => {
        if (operation) {
          const path = parsePath(patchedJson, operation.path);
          if (isObjectOrArray(newValue)) {
            return {
              state: {
                ...expandWithCallback(patchedJson, patchedState, path, expandAll),
                selection: createInsideSelection(path)
              }
            };
          }
          if (newValue === "") {
            const parent = !isEmpty_default(path) ? getIn(patchedJson, initial_default(path)) : null;
            debug5("test A", path, createInsideSelection(path));
            return {
              state: expandPath(
                patchedJson,
                {
                  ...documentState,
                  selection: isObject(parent) ? createKeySelection(path, true) : createValueSelection(path, true)
                },
                path
              )
            };
          }
          return void 0;
        }
      });
      debug5("after patch");
      if (operation) {
        if (newValue === "") {
          tick().then(() => {
            setTimeout(() => insertActiveElementContents("", true));
          });
        }
      }
    } else {
      debug5("handleInsert", { type, newValue });
      const path = [];
      handleReplaceJson(newValue, (patchedJson, patchedState) => ({
        state: {
          ...expandRecursive(patchedJson, patchedState, path),
          selection: createInsideSelection(path)
        }
      }));
    }
  }
  function handleInsertFromContextMenu(type) {
    if (isKeySelection(documentState.selection)) {
      updateSelection(createValueSelection(documentState.selection.focusPath, false));
    }
    handleInsert(type);
  }
  function handleConvert(type) {
    if (readOnly || !documentState.selection) {
      return;
    }
    if (!canConvert(documentState.selection)) {
      onError(new Error(`Cannot convert current selection to ${type}`));
      return;
    }
    try {
      const path = documentState.selection.anchorPath;
      const currentValue = getIn(json2, path);
      const convertedValue = convertValue(currentValue, type, parser);
      if (convertedValue === currentValue) {
        return;
      }
      const operations = [
        {
          op: "replace",
          path: compileJSONPointer(path),
          value: convertedValue
        }
      ];
      debug5("handleConvert", {
        selection: documentState.selection,
        path,
        type,
        operations
      });
      handlePatch(operations, (patchedJson, patchedState) => {
        return {
          state: expandRecursive(patchedJson, patchedState, documentState.selection.focusPath)
        };
      });
    } catch (err) {
      onError(err);
    }
  }
  function handleInsertBefore() {
    const selectionBefore = getSelectionUp(json2, documentState, false);
    const parentPath = initial_default(documentState.selection.focusPath);
    if (!isEmpty_default(selectionBefore.focusPath) && isEqual_default(parentPath, initial_default(selectionBefore.focusPath))) {
      updateSelection(createAfterSelection(selectionBefore.focusPath));
    } else {
      updateSelection(createInsideSelection(parentPath));
    }
    debug5("insert before", {
      selection: documentState.selection,
      selectionBefore,
      parentPath
    });
    tick().then(handleContextMenu);
  }
  function handleInsertAfter() {
    const path = isMultiSelection(documentState.selection) ? last_default(documentState.selection.paths) : documentState.selection.focusPath;
    debug5("insert after", path);
    updateSelection(createAfterSelection(path));
    tick().then(handleContextMenu);
  }
  function insertActiveElementContents(char, replaceContents) {
    const activeElement = getWindow(refJsonEditor).document.activeElement;
    if (activeElement.isContentEditable) {
      activeElement.textContent = replaceContents ? char : activeElement.textContent + char;
      setCursorToEnd(activeElement);
    }
  }
  async function handleInsertCharacter(char) {
    if (readOnly || !documentState.selection) {
      return;
    }
    if (isKeySelection(documentState.selection)) {
      const replaceContents = !documentState.selection.edit;
      updateSelection({ ...documentState.selection, edit: true });
      await tick();
      setTimeout(() => insertActiveElementContents(char, replaceContents));
      return;
    }
    if (char === "{") {
      handleInsert("object");
    } else if (char === "[") {
      handleInsert("array");
    } else {
      if (isValueSelection(documentState.selection)) {
        if (!isObjectOrArray(getIn(json2, documentState.selection.focusPath))) {
          const replaceContents = !documentState.selection.edit;
          updateSelection({ ...documentState.selection, edit: true });
          await tick();
          setTimeout(() => insertActiveElementContents(char, replaceContents));
        } else {
        }
      } else {
        await handleInsertValueWithCharacter(char);
      }
    }
  }
  async function handleInsertValueWithCharacter(char) {
    if (readOnly || !documentState.selection) {
      return;
    }
    handleInsert("value");
    const replaceContents = !isEditingSelection(documentState.selection);
    const path = documentState.selection.focusPath;
    const parent = getIn(json2, initial_default(path));
    if (Array.isArray(parent) || !parent || isValueSelection(documentState.selection)) {
      updateSelection(createValueSelection(path, true));
    } else {
      updateSelection(createKeySelection(path, true));
    }
    await tick();
    setTimeout(() => insertActiveElementContents(char, replaceContents));
  }
  function handleUndo() {
    if (readOnly) {
      return;
    }
    if (!history.getState().canUndo) {
      return;
    }
    const item = history.undo();
    if (!item) {
      return;
    }
    const previousContent = { json: json2, text: text2 };
    $$invalidate(9, json2 = item.undo.patch ? immutableJSONPatch(json2, item.undo.patch) : item.undo.json);
    $$invalidate(15, documentState = item.undo.state);
    $$invalidate(10, text2 = item.undo.text);
    $$invalidate(22, textIsRepaired = item.undo.textIsRepaired);
    debug5("undo", { item, json: json2, documentState });
    const patchResult = {
      json: json2,
      previousJson: previousContent.json,
      redo: item.undo.patch,
      undo: item.redo.patch
    };
    emitOnChange(previousContent, patchResult);
    focus3();
    if (documentState.selection) {
      scrollTo(documentState.selection.focusPath, false);
    }
  }
  function handleRedo() {
    if (readOnly) {
      return;
    }
    if (!history.getState().canRedo) {
      return;
    }
    const item = history.redo();
    if (!item) {
      return;
    }
    const previousContent = { json: json2, text: text2 };
    $$invalidate(9, json2 = item.redo.patch ? immutableJSONPatch(json2, item.redo.patch) : item.redo.json);
    $$invalidate(15, documentState = item.redo.state);
    $$invalidate(10, text2 = item.redo.text);
    $$invalidate(22, textIsRepaired = item.redo.textIsRepaired);
    debug5("redo", { item, json: json2, documentState });
    const patchResult = {
      json: json2,
      previousJson: previousContent.json,
      redo: item.redo.patch,
      undo: item.undo.patch
    };
    emitOnChange(previousContent, patchResult);
    focus3();
    if (documentState.selection) {
      scrollTo(documentState.selection.focusPath, false);
    }
  }
  function openSortModal(selectedPath) {
    if (readOnly) {
      return;
    }
    modalOpen = true;
    onSortModal({
      id: sortModalId,
      json: json2,
      selectedPath,
      onSort: async (operations) => {
        debug5("onSort", selectedPath, operations);
        handlePatch(operations, (patchedJson, patchedState) => ({
          state: {
            ...expandRecursive(patchedJson, patchedState, selectedPath),
            selection: createValueSelection(selectedPath, false)
          }
        }));
      },
      onClose: () => {
        modalOpen = false;
        focus3();
      }
    });
  }
  function handleSortSelection() {
    if (!documentState.selection) {
      return;
    }
    const selectedPath = findRootPath(json2, documentState.selection);
    openSortModal(selectedPath);
  }
  function handleSortAll() {
    const selectedPath = [];
    openSortModal(selectedPath);
  }
  function openTransformModal({ id: id2, selectedPath, onTransform, onClose }) {
    modalOpen = true;
    onTransformModal({
      id: id2 || transformModalId,
      json: json2,
      selectedPath,
      onTransform: onTransform ? (operations) => {
        onTransform({
          operations,
          json: json2,
          transformedJson: immutableJSONPatch(json2, operations)
        });
      } : (operations) => {
        debug5("onTransform", selectedPath, operations);
        handlePatch(operations, (patchedJson, patchedState) => ({
          state: {
            ...expandRecursive(patchedJson, patchedState, selectedPath),
            selection: createValueSelection(selectedPath, false)
          }
        }));
      },
      onClose: () => {
        modalOpen = false;
        focus3();
        if (onClose) {
          onClose();
        }
      }
    });
  }
  function handleTransformSelection() {
    if (!documentState.selection) {
      return;
    }
    const selectedPath = findRootPath(json2, documentState.selection);
    openTransformModal({ selectedPath });
  }
  function handleTransformAll() {
    openTransformModal({ selectedPath: [] });
  }
  async function scrollTo(path, scrollToWhenVisible = true) {
    $$invalidate(15, documentState = expandPath(json2, documentState, initial_default(path)));
    await tick();
    const elem = findElement(path);
    if (elem) {
      debug5("scrollTo", { path, elem, refContents });
      const viewPortRect = refContents.getBoundingClientRect();
      const elemRect = elem.getBoundingClientRect();
      if (!scrollToWhenVisible) {
        if (elemRect.bottom > viewPortRect.top && elemRect.top < viewPortRect.bottom) {
          return;
        }
      }
      const offset = -(viewPortRect.height / 4);
      jump(elem, {
        container: refContents,
        offset,
        duration: SCROLL_DURATION
      });
    }
  }
  function findElement(path) {
    return refContents ? refContents.querySelector(`div[data-path="${encodeDataPath(path)}"]`) : null;
  }
  function scrollIntoView(path) {
    const elem = findElement(path);
    if (!elem || !refContents) {
      return;
    }
    const viewPortRect = refContents.getBoundingClientRect();
    const elemRect = elem.getBoundingClientRect();
    const margin = 20;
    const elemHeight = isObjectOrArray(getIn(json2, path)) ? margin : elemRect.height;
    if (elemRect.top < viewPortRect.top + margin) {
      jump(elem, {
        container: refContents,
        offset: -margin,
        duration: 0
      });
    } else if (elemRect.top + elemHeight > viewPortRect.bottom - margin) {
      jump(elem, {
        container: refContents,
        offset: -(viewPortRect.height - elemHeight - margin),
        duration: 0
      });
    }
  }
  function emitOnChange(previousContent, patchResult) {
    if (previousContent.json === void 0 && (previousContent == null ? void 0 : previousContent.text) === void 0) {
      return;
    }
    if (text2 !== void 0) {
      onChange({ text: text2, json: void 0 }, previousContent, { contentErrors: validate(), patchResult });
    } else if (json2 !== void 0) {
      onChange({ text: void 0, json: json2 }, previousContent, { contentErrors: validate(), patchResult });
    }
  }
  function handlePatch(operations, afterPatch) {
    if (readOnly) {
      return;
    }
    debug5("handlePatch", operations, afterPatch);
    const patchResult = patch(operations, afterPatch);
    $$invalidate(17, pastedJson = void 0);
    return patchResult;
  }
  function handleReplaceJson(updatedJson, afterPatch) {
    const previousState = documentState;
    const previousJson = json2;
    const previousText = text2;
    const previousContent = { json: json2, text: text2 };
    const previousTextIsRepaired = textIsRepaired;
    const updatedState = expandWithCallback(json2, documentState, rootPath, expandMinimal);
    const callback = typeof afterPatch === "function" ? afterPatch(updatedJson, updatedState) : void 0;
    $$invalidate(9, json2 = callback && callback.json !== void 0 ? callback.json : updatedJson);
    $$invalidate(15, documentState = callback && callback.state !== void 0 ? callback.state : updatedState);
    $$invalidate(10, text2 = void 0);
    $$invalidate(22, textIsRepaired = false);
    resetSelectionWhenNotExisting(json2);
    addHistoryItem({
      previousJson,
      previousState,
      previousText,
      previousTextIsRepaired
    });
    const patchResult = null;
    emitOnChange(previousContent, patchResult);
  }
  function handleChangeText(updatedText, afterPatch) {
    debug5("handleChangeText");
    const previousState = documentState;
    const previousJson = json2;
    const previousText = text2;
    const previousContent = { json: json2, text: text2 };
    const previousTextIsRepaired = textIsRepaired;
    try {
      $$invalidate(9, json2 = parser.parse(updatedText));
      $$invalidate(15, documentState = expandWithCallback(json2, documentState, rootPath, expandMinimal));
      $$invalidate(10, text2 = void 0);
      $$invalidate(22, textIsRepaired = false);
    } catch (err) {
      try {
        $$invalidate(9, json2 = parser.parse(jsonrepair(updatedText)));
        $$invalidate(15, documentState = expandWithCallback(json2, documentState, rootPath, expandMinimal));
        $$invalidate(10, text2 = updatedText);
        $$invalidate(22, textIsRepaired = true);
      } catch (err2) {
        $$invalidate(9, json2 = void 0);
        $$invalidate(15, documentState = createDocumentState({ json: json2, expand: expandMinimal }));
        $$invalidate(10, text2 = updatedText);
        $$invalidate(22, textIsRepaired = false);
      }
    }
    if (typeof afterPatch === "function") {
      const callback = afterPatch(json2, documentState);
      $$invalidate(9, json2 = callback && callback.json ? callback.json : json2);
      $$invalidate(15, documentState = callback && callback.state ? callback.state : documentState);
    }
    resetSelectionWhenNotExisting(json2);
    addHistoryItem({
      previousJson,
      previousState,
      previousText,
      previousTextIsRepaired
    });
    const patchResult = null;
    emitOnChange(previousContent, patchResult);
  }
  function expandRecursive(json3, documentState2, path) {
    const expandContents = getIn(json3, path);
    const expandAllRecursive = !isLargeContent({ json: expandContents }, MAX_DOCUMENT_SIZE_EXPAND_ALL);
    const expandCallback = expandAllRecursive ? expandAll : expandMinimal;
    return expandWithCallback(json3, documentState2, path, expandCallback);
  }
  function handleExpand(path, expanded, recursive = false) {
    debug5("expand", { path, expanded, recursive });
    if (expanded) {
      if (recursive) {
        $$invalidate(15, documentState = expandWithCallback(json2, documentState, path, expandAll));
      } else {
        $$invalidate(15, documentState = expandSingleItem(documentState, path));
      }
    } else {
      $$invalidate(15, documentState = collapsePath(documentState, path));
    }
    if (documentState.selection && !expanded) {
      if (isSelectionInsidePath(documentState.selection, path)) {
        updateSelection(void 0);
      }
    }
    setTimeout(() => {
      if (!activeElementIsChildOf(refJsonEditor)) {
        focus3();
      }
    });
  }
  function handleExpandAll() {
    handleExpand([], true, true);
  }
  function handleCollapseAll() {
    handleExpand([], false, true);
  }
  function openFind(findAndReplace) {
    debug5("openFind", { findAndReplace });
    $$invalidate(18, showSearch = false);
    $$invalidate(19, showReplace = false);
    tick().then(() => {
      $$invalidate(18, showSearch = true);
      $$invalidate(19, showReplace = findAndReplace);
    });
  }
  function handleExpandSection(path, section) {
    debug5("handleExpandSection", path, section);
    const pointer = compileJSONPointer(path);
    $$invalidate(15, documentState = expandSection(json2, documentState, pointer, section));
  }
  function handlePasteJson(newPastedJson) {
    debug5("pasted json as text", newPastedJson);
    $$invalidate(17, pastedJson = newPastedJson);
  }
  function handleKeyDown(event) {
    const combo = keyComboFromEvent(event).replace(/^Command\+/, "Ctrl+");
    const keepAnchorPath = event.shiftKey;
    debug5("keydown", { combo, key: event.key });
    if (combo === "Ctrl+X") {
      event.preventDefault();
      handleCut(true);
    }
    if (combo === "Ctrl+Shift+X") {
      event.preventDefault();
      handleCut(false);
    }
    if (combo === "Ctrl+C") {
      event.preventDefault();
      handleCopy(true);
    }
    if (combo === "Ctrl+Shift+C") {
      event.preventDefault();
      handleCopy(false);
    }
    if (combo === "Ctrl+D") {
      event.preventDefault();
      handleDuplicate();
    }
    if (combo === "Delete" || combo === "Backspace") {
      event.preventDefault();
      handleRemove();
    }
    if (combo === "Insert") {
      event.preventDefault();
      handleInsert("structure");
    }
    if (combo === "Ctrl+A") {
      event.preventDefault();
      updateSelection(selectAll());
    }
    if (combo === "Ctrl+Q") {
      handleContextMenu(event);
    }
    if (combo === "Up" || combo === "Shift+Up") {
      event.preventDefault();
      const newSelection = documentState.selection ? getSelectionUp(json2, documentState, keepAnchorPath, true) || documentState.selection : getInitialSelection(json2, documentState);
      updateSelection(newSelection);
      scrollIntoView(newSelection.focusPath);
    }
    if (combo === "Down" || combo === "Shift+Down") {
      event.preventDefault();
      const newSelection = documentState.selection ? getSelectionDown(json2, documentState, keepAnchorPath, true) || documentState.selection : getInitialSelection(json2, documentState);
      updateSelection(newSelection);
      scrollIntoView(newSelection.focusPath);
    }
    if (combo === "Left" || combo === "Shift+Left") {
      event.preventDefault();
      const newSelection = documentState.selection ? getSelectionLeft(json2, documentState, keepAnchorPath, !readOnly) || documentState.selection : getInitialSelection(json2, documentState);
      updateSelection(newSelection);
      scrollIntoView(newSelection.focusPath);
    }
    if (combo === "Right" || combo === "Shift+Right") {
      event.preventDefault();
      const newSelection = documentState.selection ? getSelectionRight(json2, documentState, keepAnchorPath, !readOnly) || documentState.selection : getInitialSelection(json2, documentState);
      updateSelection(newSelection);
      scrollIntoView(newSelection.focusPath);
    }
    if (combo === "Enter" && documentState.selection) {
      if (!readOnly && isMultiSelection(documentState.selection) && documentState.selection.paths.length === 1) {
        const path = documentState.selection.focusPath;
        const parent = getIn(json2, initial_default(path));
        if (Array.isArray(parent)) {
          updateSelection(createValueSelection(path, false));
        }
      }
      if (!readOnly && isKeySelection(documentState.selection)) {
        event.preventDefault();
        updateSelection({ ...documentState.selection, edit: true });
      }
      if (isValueSelection(documentState.selection)) {
        event.preventDefault();
        const value = getIn(json2, documentState.selection.focusPath);
        if (isObjectOrArray(value)) {
          handleExpand(documentState.selection.focusPath, true);
        } else {
          if (!readOnly) {
            updateSelection({ ...documentState.selection, edit: true });
          }
        }
      }
    }
    const normalizedCombo = combo.replace(/^Shift\+/, "").replace(/^Numpad_/, "");
    if (normalizedCombo.length === 1 && documentState.selection) {
      event.preventDefault();
      handleInsertCharacter(event.key);
      return;
    }
    if (combo === "Enter" && (isAfterSelection(documentState.selection) || isInsideSelection(documentState.selection))) {
      event.preventDefault();
      handleInsertCharacter("");
      return;
    }
    if (combo === "Ctrl+Enter" && isValueSelection(documentState.selection)) {
      const value = getIn(json2, documentState.selection.focusPath);
      if (isUrl(value)) {
        window.open(String(value), "_blank");
      }
    }
    if (combo === "Escape" && documentState.selection) {
      event.preventDefault();
      updateSelection(void 0);
    }
    if (combo === "Ctrl+F") {
      event.preventDefault();
      openFind(false);
    }
    if (combo === "Ctrl+H") {
      event.preventDefault();
      openFind(true);
    }
    if (combo === "Ctrl+Z") {
      event.preventDefault();
      const activeElement = document.activeElement;
      if (activeElement && activeElement.blur && activeElement.focus) {
        activeElement.blur();
        setTimeout(() => {
          handleUndo();
          setTimeout(() => activeElement.select());
        });
      } else {
        handleUndo();
      }
    }
    if (combo === "Ctrl+Shift+Z") {
      event.preventDefault();
      const activeElement = document.activeElement;
      if (activeElement && activeElement.blur && activeElement.focus) {
        activeElement.blur();
        setTimeout(() => {
          handleRedo();
          setTimeout(() => activeElement.select());
        });
      } else {
        handleRedo();
      }
    }
  }
  function handleMouseDown2(event) {
    debug5("handleMouseDown", event);
    setTimeout(() => {
      setTimeout(() => {
        if (!hasFocus && !isChildOfNodeName(event.target, "BUTTON")) {
          focus3();
          if (!documentState.selection && json2 === void 0 && (text2 === "" || text2 === void 0)) {
            createDefaultSelection();
          }
        }
      });
    });
  }
  function openContextMenu({ anchor, left, top, width, height, offsetTop, offsetLeft, showTip }) {
    const props = {
      json: json2,
      documentState,
      parser,
      showTip,
      onEditKey: handleEditKey,
      onEditValue: handleEditValue,
      onToggleEnforceString: handleToggleEnforceString,
      onCut: handleCut,
      onCopy: handleCopy,
      onPaste: handlePasteFromMenu,
      onRemove: handleRemove,
      onDuplicate: handleDuplicate,
      onExtract: handleExtract,
      onInsertBefore: handleInsertBefore,
      onInsert: handleInsertFromContextMenu,
      onConvert: handleConvert,
      onInsertAfter: handleInsertAfter,
      onSort: handleSortSelection,
      onTransform: handleTransformSelection,
      onCloseContextMenu() {
        closeAbsolutePopup(popupId);
        focus3();
      }
    };
    modalOpen = true;
    const popupId = openAbsolutePopup(ContextMenu_default, props, {
      left,
      top,
      offsetTop,
      offsetLeft,
      width,
      height,
      anchor,
      closeOnOuterClick: true,
      onClose: () => {
        modalOpen = false;
        focus3();
      }
    });
  }
  function handleContextMenu(event) {
    if (readOnly || isEditingSelection(documentState.selection)) {
      return;
    }
    if (event) {
      event.stopPropagation();
      event.preventDefault();
    }
    if (event && event.type === "contextmenu" && event.target !== refHiddenInput) {
      openContextMenu({
        left: event.clientX,
        top: event.clientY,
        width: CONTEXT_MENU_WIDTH,
        height: CONTEXT_MENU_HEIGHT,
        showTip: false
      });
    } else {
      const anchor = refContents == null ? void 0 : refContents.querySelector(".jse-context-menu-button.jse-selected");
      if (anchor) {
        openContextMenu({
          anchor,
          offsetTop: 2,
          width: CONTEXT_MENU_WIDTH,
          height: CONTEXT_MENU_HEIGHT,
          showTip: false
        });
      } else {
        const rect = refContents == null ? void 0 : refContents.getBoundingClientRect();
        if (rect) {
          openContextMenu({
            top: rect.top + 2,
            left: rect.left + 2,
            width: CONTEXT_MENU_WIDTH,
            height: CONTEXT_MENU_HEIGHT,
            showTip: false
          });
        }
      }
    }
    return false;
  }
  function handleContextMenuFromTreeMenu(event) {
    if (readOnly) {
      return;
    }
    openContextMenu({
      anchor: findParentWithNodeName(event.target, "BUTTON"),
      offsetTop: 0,
      width: CONTEXT_MENU_WIDTH,
      height: CONTEXT_MENU_HEIGHT,
      showTip: true
    });
  }
  async function handleParsePastedJson() {
    debug5("apply pasted json", pastedJson);
    const { path, contents } = pastedJson;
    updateSelection(createValueSelection(path, false));
    await tick();
    const operations = [
      {
        op: "replace",
        path: compileJSONPointer(path),
        value: contents
      }
    ];
    handlePatch(operations, (patchedJson, patchedState) => {
      return {
        state: expandRecursive(patchedJson, patchedState, path)
      };
    });
  }
  function handleClearPastedJson() {
    debug5("clear pasted json");
    $$invalidate(17, pastedJson = void 0);
  }
  function handleNavigationBarSelect(newSelection) {
    updateSelection(newSelection);
    focus3();
    scrollTo(newSelection.focusPath);
  }
  function focus3() {
    debug5("focus");
    if (refHiddenInput) {
      refHiddenInput.focus();
      refHiddenInput.select();
    }
  }
  function handleWindowMouseDown(event) {
    const outsideEditor = !isChildOf(event.target, (element2) => element2 === refJsonEditor);
    if (outsideEditor) {
      if (isEditingSelection(documentState.selection)) {
        debug5("click outside the editor, stop edit mode");
        updateSelection((selection) => {
          if (isKeySelection(selection)) {
            return { ...selection, edit: false };
          } else if (isValueSelection(selection)) {
            return { ...selection, edit: false };
          } else {
            return selection;
          }
        });
        if (hasFocus && refHiddenInput) {
          refHiddenInput.focus();
          refHiddenInput.blur();
        }
        tick().then(() => {
          setTimeout(() => {
            if (refHiddenInput) {
              refHiddenInput.blur();
            }
          });
        });
      }
    }
  }
  function handleDrag(event) {
    if (autoScrollHandler) {
      autoScrollHandler.onDrag(event);
    }
  }
  function handleDragEnd() {
    if (autoScrollHandler) {
      autoScrollHandler.onDragEnd();
    }
  }
  let context;
  $$self.$$.on_mount.push(function() {
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console.warn("<TreeMode> was created without expected prop 'readOnly'");
    }
    if (externalContent === void 0 && !("externalContent" in $$props || $$self.$$.bound[$$self.$$.props["externalContent"]])) {
      console.warn("<TreeMode> was created without expected prop 'externalContent'");
    }
    if (mainMenuBar === void 0 && !("mainMenuBar" in $$props || $$self.$$.bound[$$self.$$.props["mainMenuBar"]])) {
      console.warn("<TreeMode> was created without expected prop 'mainMenuBar'");
    }
    if (navigationBar === void 0 && !("navigationBar" in $$props || $$self.$$.bound[$$self.$$.props["navigationBar"]])) {
      console.warn("<TreeMode> was created without expected prop 'navigationBar'");
    }
    if (escapeControlCharacters === void 0 && !("escapeControlCharacters" in $$props || $$self.$$.bound[$$self.$$.props["escapeControlCharacters"]])) {
      console.warn("<TreeMode> was created without expected prop 'escapeControlCharacters'");
    }
    if (escapeUnicodeCharacters === void 0 && !("escapeUnicodeCharacters" in $$props || $$self.$$.bound[$$self.$$.props["escapeUnicodeCharacters"]])) {
      console.warn("<TreeMode> was created without expected prop 'escapeUnicodeCharacters'");
    }
    if (parser === void 0 && !("parser" in $$props || $$self.$$.bound[$$self.$$.props["parser"]])) {
      console.warn("<TreeMode> was created without expected prop 'parser'");
    }
    if (validator === void 0 && !("validator" in $$props || $$self.$$.bound[$$self.$$.props["validator"]])) {
      console.warn("<TreeMode> was created without expected prop 'validator'");
    }
    if (validationParser === void 0 && !("validationParser" in $$props || $$self.$$.bound[$$self.$$.props["validationParser"]])) {
      console.warn("<TreeMode> was created without expected prop 'validationParser'");
    }
    if (pathParser === void 0 && !("pathParser" in $$props || $$self.$$.bound[$$self.$$.props["pathParser"]])) {
      console.warn("<TreeMode> was created without expected prop 'pathParser'");
    }
    if (indentation === void 0 && !("indentation" in $$props || $$self.$$.bound[$$self.$$.props["indentation"]])) {
      console.warn("<TreeMode> was created without expected prop 'indentation'");
    }
    if (onError === void 0 && !("onError" in $$props || $$self.$$.bound[$$self.$$.props["onError"]])) {
      console.warn("<TreeMode> was created without expected prop 'onError'");
    }
    if (onChange === void 0 && !("onChange" in $$props || $$self.$$.bound[$$self.$$.props["onChange"]])) {
      console.warn("<TreeMode> was created without expected prop 'onChange'");
    }
    if (onRenderValue === void 0 && !("onRenderValue" in $$props || $$self.$$.bound[$$self.$$.props["onRenderValue"]])) {
      console.warn("<TreeMode> was created without expected prop 'onRenderValue'");
    }
    if (onRequestRepair === void 0 && !("onRequestRepair" in $$props || $$self.$$.bound[$$self.$$.props["onRequestRepair"]])) {
      console.warn("<TreeMode> was created without expected prop 'onRequestRepair'");
    }
    if (onRenderMenu === void 0 && !("onRenderMenu" in $$props || $$self.$$.bound[$$self.$$.props["onRenderMenu"]])) {
      console.warn("<TreeMode> was created without expected prop 'onRenderMenu'");
    }
    if (onClassName === void 0 && !("onClassName" in $$props || $$self.$$.bound[$$self.$$.props["onClassName"]])) {
      console.warn("<TreeMode> was created without expected prop 'onClassName'");
    }
    if (onFocus === void 0 && !("onFocus" in $$props || $$self.$$.bound[$$self.$$.props["onFocus"]])) {
      console.warn("<TreeMode> was created without expected prop 'onFocus'");
    }
    if (onBlur === void 0 && !("onBlur" in $$props || $$self.$$.bound[$$self.$$.props["onBlur"]])) {
      console.warn("<TreeMode> was created without expected prop 'onBlur'");
    }
    if (onSortModal === void 0 && !("onSortModal" in $$props || $$self.$$.bound[$$self.$$.props["onSortModal"]])) {
      console.warn("<TreeMode> was created without expected prop 'onSortModal'");
    }
    if (onTransformModal === void 0 && !("onTransformModal" in $$props || $$self.$$.bound[$$self.$$.props["onTransformModal"]])) {
      console.warn("<TreeMode> was created without expected prop 'onTransformModal'");
    }
  });
  const writable_props = [
    "readOnly",
    "externalContent",
    "mainMenuBar",
    "navigationBar",
    "escapeControlCharacters",
    "escapeUnicodeCharacters",
    "parser",
    "validator",
    "validationParser",
    "pathParser",
    "indentation",
    "onError",
    "onChange",
    "onRenderValue",
    "onRequestRepair",
    "onRenderMenu",
    "onClassName",
    "onFocus",
    "onBlur",
    "onSortModal",
    "onTransformModal"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TreeMode> was created with unknown prop '${key}'`);
  });
  function treemenu_showSearch_binding(value) {
    showSearch = value;
    $$invalidate(18, showSearch);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refHiddenInput = $$value;
      $$invalidate(13, refHiddenInput);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refContents = $$value;
      $$invalidate(8, refContents);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refJsonEditor = $$value;
      $$invalidate(14, refJsonEditor);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("readOnly" in $$props2)
      $$invalidate(0, readOnly = $$props2.readOnly);
    if ("externalContent" in $$props2)
      $$invalidate(49, externalContent = $$props2.externalContent);
    if ("mainMenuBar" in $$props2)
      $$invalidate(1, mainMenuBar = $$props2.mainMenuBar);
    if ("navigationBar" in $$props2)
      $$invalidate(2, navigationBar = $$props2.navigationBar);
    if ("escapeControlCharacters" in $$props2)
      $$invalidate(50, escapeControlCharacters = $$props2.escapeControlCharacters);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(51, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(52, parser = $$props2.parser);
    if ("validator" in $$props2)
      $$invalidate(53, validator = $$props2.validator);
    if ("validationParser" in $$props2)
      $$invalidate(54, validationParser = $$props2.validationParser);
    if ("pathParser" in $$props2)
      $$invalidate(3, pathParser = $$props2.pathParser);
    if ("indentation" in $$props2)
      $$invalidate(55, indentation = $$props2.indentation);
    if ("onError" in $$props2)
      $$invalidate(4, onError = $$props2.onError);
    if ("onChange" in $$props2)
      $$invalidate(56, onChange = $$props2.onChange);
    if ("onRenderValue" in $$props2)
      $$invalidate(57, onRenderValue = $$props2.onRenderValue);
    if ("onRequestRepair" in $$props2)
      $$invalidate(5, onRequestRepair = $$props2.onRequestRepair);
    if ("onRenderMenu" in $$props2)
      $$invalidate(6, onRenderMenu = $$props2.onRenderMenu);
    if ("onClassName" in $$props2)
      $$invalidate(58, onClassName = $$props2.onClassName);
    if ("onFocus" in $$props2)
      $$invalidate(59, onFocus = $$props2.onFocus);
    if ("onBlur" in $$props2)
      $$invalidate(60, onBlur = $$props2.onBlur);
    if ("onSortModal" in $$props2)
      $$invalidate(61, onSortModal = $$props2.onSortModal);
    if ("onTransformModal" in $$props2)
      $$invalidate(62, onTransformModal = $$props2.onTransformModal);
  };
  $$self.$capture_state = () => ({
    createAutoScrollHandler,
    faCheck,
    faCode,
    faWrench,
    createDebug,
    compileJSONPointer,
    existsIn,
    getIn,
    immutableJSONPatch,
    isJSONPatchAdd,
    isJSONPatchReplace,
    parsePath,
    jsonrepair,
    initial: initial_default,
    isEmpty: isEmpty_default,
    isEqual: isEqual_default,
    last: last_default,
    noop: noop_default,
    throttle: throttle_default,
    uniqueId: uniqueId_default,
    getContext,
    onDestroy,
    onMount,
    tick,
    createJump,
    CONTEXT_MENU_HEIGHT,
    CONTEXT_MENU_WIDTH,
    MAX_DOCUMENT_SIZE_EXPAND_ALL,
    MAX_SEARCH_RESULTS,
    SCROLL_DURATION,
    SEARCH_UPDATE_THROTTLE,
    SIMPLE_MODAL_OPTIONS,
    collapsePath,
    createDocumentState,
    documentStatePatch,
    expandPath,
    expandSection,
    expandSingleItem,
    expandWithCallback,
    getEnforceString,
    setEnforceString,
    createHistory,
    createNewValue,
    createRemoveOperations,
    duplicate,
    extract,
    insert,
    revertJSONPatchWithMoveOperations,
    createSearchAndReplaceAllOperations,
    createSearchAndReplaceOperations,
    search: search2,
    searchNext,
    searchPrevious,
    updateSearchResult,
    canConvert,
    createAfterSelection,
    createInsideSelection,
    createKeySelection,
    createMultiSelection,
    createSelectionFromOperations,
    createValueSelection,
    findRootPath,
    getInitialSelection,
    getSelectionDown,
    getSelectionLeft,
    getSelectionPaths,
    getSelectionRight,
    getSelectionUp,
    isEditingSelection,
    isMultiSelection,
    isSelectionInsidePath,
    isValueSelection,
    removeEditModeFromSelection,
    selectAll,
    selectionToPartialJson,
    updateSelectionInDocumentState,
    mapValidationErrors,
    validateJSON,
    activeElementIsChildOf,
    createNormalizationFunctions,
    encodeDataPath,
    findParentWithNodeName,
    getWindow,
    isChildOf,
    isChildOfNodeName,
    setCursorToEnd,
    convertValue,
    isLargeContent,
    normalizeJsonParseError,
    parsePartialJson,
    repairPartialJson,
    keyComboFromEvent,
    isObject,
    isObjectOrArray,
    isUrl,
    stringConvert,
    copyToClipboard: copyToClipBoard,
    createFocusTracker,
    Message: Message_default,
    ValidationErrorsOverview: ValidationErrorsOverview_default,
    CopyPasteModal: CopyPasteModal_default,
    JSONRepairModal: JSONRepairModal_default,
    ContextMenu: ContextMenu_default,
    JSONNode: JSONNode_default,
    TreeMenu: TreeMenu_default,
    Welcome: Welcome_default,
    NavigationBar: NavigationBar_default,
    SearchBox: SearchBox_default,
    ValidationSeverity,
    isAfterSelection,
    isInsideSelection,
    isKeySelection,
    truncate,
    MAX_CHARACTERS_TEXT_PREVIEW,
    memoizeOne,
    measure,
    debug: debug5,
    isSSR,
    open,
    sortModalId,
    transformModalId,
    openAbsolutePopup,
    closeAbsolutePopup,
    refContents,
    refHiddenInput,
    refJsonEditor,
    hasFocus,
    jump,
    readOnly,
    externalContent,
    mainMenuBar,
    navigationBar,
    escapeControlCharacters,
    escapeUnicodeCharacters,
    parser,
    validator,
    validationParser,
    pathParser,
    indentation,
    onError,
    onChange,
    onRenderValue,
    onRequestRepair,
    onRenderMenu,
    onClassName,
    onFocus,
    onBlur,
    onSortModal,
    onTransformModal,
    modalOpen,
    json: json2,
    text: text2,
    rootPath,
    parseError,
    updateSelection,
    documentStateInitialized,
    documentState,
    searchResult,
    normalization,
    pastedJson,
    expandMinimal,
    expandAll,
    getDefaultExpand,
    showSearch,
    showReplace,
    searching,
    searchText,
    handleSearchText,
    handleNextSearchResult,
    handlePreviousSearchResult,
    handleReplace,
    handleReplaceAll,
    clearSearchResult,
    focusActiveSearchResult,
    applySearch,
    handleSelectValidationError,
    history,
    historyState,
    expand,
    applySearchThrottled,
    textIsRepaired,
    validationErrors,
    validationErrorsMap,
    memoizedValidate,
    updateValidationErrors,
    validate,
    getJson,
    getDocumentState,
    applyExternalContent,
    applyExternalJson,
    applyExternalText,
    expandWhenNotInitialized,
    resetSelectionWhenNotExisting,
    addHistoryItem,
    createDefaultSelection,
    patch,
    hasSelectionContents,
    handleEditKey,
    handleEditValue,
    handleToggleEnforceString,
    acceptAutoRepair,
    handleCut,
    handleCopy,
    handlePaste,
    handlePasteFromMenu,
    doPaste,
    openRepairModal,
    handleRemove,
    handleDuplicate,
    handleExtract,
    handleInsert,
    handleInsertFromContextMenu,
    handleConvert,
    handleInsertBefore,
    handleInsertAfter,
    insertActiveElementContents,
    handleInsertCharacter,
    handleInsertValueWithCharacter,
    handleUndo,
    handleRedo,
    openSortModal,
    handleSortSelection,
    handleSortAll,
    openTransformModal,
    handleTransformSelection,
    handleTransformAll,
    scrollTo,
    findElement,
    scrollIntoView,
    emitOnChange,
    handlePatch,
    handleReplaceJson,
    handleChangeText,
    expandRecursive,
    handleExpand,
    handleExpandAll,
    handleCollapseAll,
    openFind,
    handleExpandSection,
    handlePasteJson,
    handleKeyDown,
    handleMouseDown: handleMouseDown2,
    openContextMenu,
    handleContextMenu,
    handleContextMenuFromTreeMenu,
    handleParsePastedJson,
    handleClearPastedJson,
    handleNavigationBarSelect,
    focus: focus3,
    handleWindowMouseDown,
    handleDrag,
    handleDragEnd,
    context,
    autoScrollHandler,
    textIsUnrepairable
  });
  $$self.$inject_state = ($$props2) => {
    if ("refContents" in $$props2)
      $$invalidate(8, refContents = $$props2.refContents);
    if ("refHiddenInput" in $$props2)
      $$invalidate(13, refHiddenInput = $$props2.refHiddenInput);
    if ("refJsonEditor" in $$props2)
      $$invalidate(14, refJsonEditor = $$props2.refJsonEditor);
    if ("hasFocus" in $$props2)
      hasFocus = $$props2.hasFocus;
    if ("readOnly" in $$props2)
      $$invalidate(0, readOnly = $$props2.readOnly);
    if ("externalContent" in $$props2)
      $$invalidate(49, externalContent = $$props2.externalContent);
    if ("mainMenuBar" in $$props2)
      $$invalidate(1, mainMenuBar = $$props2.mainMenuBar);
    if ("navigationBar" in $$props2)
      $$invalidate(2, navigationBar = $$props2.navigationBar);
    if ("escapeControlCharacters" in $$props2)
      $$invalidate(50, escapeControlCharacters = $$props2.escapeControlCharacters);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(51, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(52, parser = $$props2.parser);
    if ("validator" in $$props2)
      $$invalidate(53, validator = $$props2.validator);
    if ("validationParser" in $$props2)
      $$invalidate(54, validationParser = $$props2.validationParser);
    if ("pathParser" in $$props2)
      $$invalidate(3, pathParser = $$props2.pathParser);
    if ("indentation" in $$props2)
      $$invalidate(55, indentation = $$props2.indentation);
    if ("onError" in $$props2)
      $$invalidate(4, onError = $$props2.onError);
    if ("onChange" in $$props2)
      $$invalidate(56, onChange = $$props2.onChange);
    if ("onRenderValue" in $$props2)
      $$invalidate(57, onRenderValue = $$props2.onRenderValue);
    if ("onRequestRepair" in $$props2)
      $$invalidate(5, onRequestRepair = $$props2.onRequestRepair);
    if ("onRenderMenu" in $$props2)
      $$invalidate(6, onRenderMenu = $$props2.onRenderMenu);
    if ("onClassName" in $$props2)
      $$invalidate(58, onClassName = $$props2.onClassName);
    if ("onFocus" in $$props2)
      $$invalidate(59, onFocus = $$props2.onFocus);
    if ("onBlur" in $$props2)
      $$invalidate(60, onBlur = $$props2.onBlur);
    if ("onSortModal" in $$props2)
      $$invalidate(61, onSortModal = $$props2.onSortModal);
    if ("onTransformModal" in $$props2)
      $$invalidate(62, onTransformModal = $$props2.onTransformModal);
    if ("modalOpen" in $$props2)
      modalOpen = $$props2.modalOpen;
    if ("json" in $$props2)
      $$invalidate(9, json2 = $$props2.json);
    if ("text" in $$props2)
      $$invalidate(10, text2 = $$props2.text);
    if ("parseError" in $$props2)
      parseError = $$props2.parseError;
    if ("documentStateInitialized" in $$props2)
      documentStateInitialized = $$props2.documentStateInitialized;
    if ("documentState" in $$props2)
      $$invalidate(15, documentState = $$props2.documentState);
    if ("searchResult" in $$props2)
      $$invalidate(16, searchResult = $$props2.searchResult);
    if ("normalization" in $$props2)
      $$invalidate(71, normalization = $$props2.normalization);
    if ("pastedJson" in $$props2)
      $$invalidate(17, pastedJson = $$props2.pastedJson);
    if ("showSearch" in $$props2)
      $$invalidate(18, showSearch = $$props2.showSearch);
    if ("showReplace" in $$props2)
      $$invalidate(19, showReplace = $$props2.showReplace);
    if ("searching" in $$props2)
      $$invalidate(20, searching = $$props2.searching);
    if ("searchText" in $$props2)
      $$invalidate(72, searchText = $$props2.searchText);
    if ("historyState" in $$props2)
      $$invalidate(21, historyState = $$props2.historyState);
    if ("textIsRepaired" in $$props2)
      $$invalidate(22, textIsRepaired = $$props2.textIsRepaired);
    if ("validationErrors" in $$props2)
      $$invalidate(11, validationErrors = $$props2.validationErrors);
    if ("validationErrorsMap" in $$props2)
      $$invalidate(23, validationErrorsMap = $$props2.validationErrorsMap);
    if ("context" in $$props2)
      $$invalidate(12, context = $$props2.context);
    if ("autoScrollHandler" in $$props2)
      autoScrollHandler = $$props2.autoScrollHandler;
    if ("textIsUnrepairable" in $$props2)
      textIsUnrepairable = $$props2.textIsUnrepairable;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 1572864) {
      $:
        $$invalidate(71, normalization = createNormalizationFunctions({
          escapeControlCharacters,
          escapeUnicodeCharacters
        }));
    }
    if ($$self.$$.dirty[1] & 262144) {
      $:
        applyExternalContent(externalContent);
    }
    if ($$self.$$.dirty[0] & 512 | $$self.$$.dirty[2] & 1024) {
      $:
        applySearchThrottled(searchText, json2);
    }
    if ($$self.$$.dirty[0] & 1536) {
      $:
        textIsUnrepairable = text2 !== void 0 && json2 === void 0;
    }
    if ($$self.$$.dirty[0] & 512 | $$self.$$.dirty[1] & 14680064) {
      $:
        updateValidationErrors(json2, validator, parser, validationParser);
    }
    if ($$self.$$.dirty[0] & 2048) {
      $:
        $$invalidate(23, validationErrorsMap = mapValidationErrors(validationErrors));
    }
    if ($$self.$$.dirty[0] & 256) {
      $:
        autoScrollHandler = refContents ? createAutoScrollHandler(refContents) : void 0;
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 203423744 | $$self.$$.dirty[2] & 512) {
      $:
        $$invalidate(12, context = {
          readOnly,
          parser,
          normalization,
          getJson,
          getDocumentState,
          findElement,
          focus: focus3,
          onPatch: handlePatch,
          onInsert: handleInsert,
          onExpand: handleExpand,
          onSelect: updateSelection,
          onFind: openFind,
          onExpandSection: handleExpandSection,
          onPasteJson: handlePasteJson,
          onRenderValue,
          onContextMenu: openContextMenu,
          onClassName: onClassName || (() => void 0),
          onDrag: handleDrag,
          onDragEnd: handleDragEnd
        });
    }
    if ($$self.$$.dirty[0] & 4096) {
      $:
        debug5("context changed", context);
    }
  };
  return [
    readOnly,
    mainMenuBar,
    navigationBar,
    pathParser,
    onError,
    onRequestRepair,
    onRenderMenu,
    acceptAutoRepair,
    refContents,
    json2,
    text2,
    validationErrors,
    context,
    refHiddenInput,
    refJsonEditor,
    documentState,
    searchResult,
    pastedJson,
    showSearch,
    showReplace,
    searching,
    historyState,
    textIsRepaired,
    validationErrorsMap,
    isSSR,
    rootPath,
    handleSearchText,
    handleNextSearchResult,
    handlePreviousSearchResult,
    handleReplace,
    handleReplaceAll,
    clearSearchResult,
    handleSelectValidationError,
    handleCopy,
    handlePaste,
    handleUndo,
    handleRedo,
    handleSortAll,
    handleTransformAll,
    handleExpandAll,
    handleCollapseAll,
    handleKeyDown,
    handleMouseDown2,
    handleContextMenu,
    handleContextMenuFromTreeMenu,
    handleParsePastedJson,
    handleClearPastedJson,
    handleNavigationBarSelect,
    handleWindowMouseDown,
    externalContent,
    escapeControlCharacters,
    escapeUnicodeCharacters,
    parser,
    validator,
    validationParser,
    indentation,
    onChange,
    onRenderValue,
    onClassName,
    onFocus,
    onBlur,
    onSortModal,
    onTransformModal,
    expand,
    validate,
    getJson,
    patch,
    openTransformModal,
    scrollTo,
    findElement,
    focus3,
    normalization,
    searchText,
    treemenu_showSearch_binding,
    input_binding,
    div1_binding,
    div_binding
  ];
}
var TreeMode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance37,
      create_fragment37,
      not_equal,
      {
        readOnly: 0,
        externalContent: 49,
        mainMenuBar: 1,
        navigationBar: 2,
        escapeControlCharacters: 50,
        escapeUnicodeCharacters: 51,
        parser: 52,
        validator: 53,
        validationParser: 54,
        pathParser: 3,
        indentation: 55,
        onError: 4,
        onChange: 56,
        onRenderValue: 57,
        onRequestRepair: 5,
        onRenderMenu: 6,
        onClassName: 58,
        onFocus: 59,
        onBlur: 60,
        onSortModal: 61,
        onTransformModal: 62,
        expand: 63,
        validate: 64,
        getJson: 65,
        patch: 66,
        acceptAutoRepair: 7,
        openTransformModal: 67,
        scrollTo: 68,
        findElement: 69,
        focus: 70
      },
      add_css29,
      [-1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeMode",
      options,
      id: create_fragment37.name
    });
  }
  get readOnly() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get externalContent() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set externalContent(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mainMenuBar() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mainMenuBar(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navigationBar() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navigationBar(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeControlCharacters() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeControlCharacters(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeUnicodeCharacters() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeUnicodeCharacters(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validator() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validator(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationParser() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationParser(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathParser() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathParser(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indentation() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indentation(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onError() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onError(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderValue() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderValue(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRequestRepair() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRequestRepair(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderMenu() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderMenu(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClassName() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClassName(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFocus() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFocus(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBlur() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBlur(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSortModal() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSortModal(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTransformModal() {
    throw new Error_13("<TreeMode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTransformModal(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    return this.$$.ctx[63];
  }
  set expand(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validate() {
    return this.$$.ctx[64];
  }
  set validate(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getJson() {
    return this.$$.ctx[65];
  }
  set getJson(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patch() {
    return this.$$.ctx[66];
  }
  set patch(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get acceptAutoRepair() {
    return this.$$.ctx[7];
  }
  set acceptAutoRepair(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openTransformModal() {
    return this.$$.ctx[67];
  }
  set openTransformModal(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollTo() {
    return this.$$.ctx[68];
  }
  set scrollTo(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get findElement() {
    return this.$$.ctx[69];
  }
  set findElement(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[70];
  }
  set focus(value) {
    throw new Error_13("<TreeMode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeMode_default = TreeMode;

// ../node_modules/svelte-jsoneditor/plugins/query/javascriptQueryLanguage.js
var description = `
<p>
  Enter a JavaScript function to filter, sort, or transform the data.
</p>
`;
var javascriptQueryLanguage = {
  id: "javascript",
  name: "JavaScript",
  description,
  createQuery,
  executeQuery
};
function createQuery(json2, queryOptions) {
  const { filter, sort, projection } = queryOptions;
  const queryParts = [];
  if (filter && filter.path && filter.relation && filter.value) {
    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`;
    const filterValue = parseString(filter.value);
    const filterValueStr = typeof filterValue === "string" ? `'${filter.value}'` : isInteger(filter.value) && !Number.isSafeInteger(filterValue) ? `${filter.value}n` : filter.value;
    queryParts.push(`  data = data.filter(${actualValueGetter} ${filter.relation} ${filterValueStr})
`);
  }
  if (sort && sort.path && sort.direction) {
    if (sort.direction === "desc") {
      queryParts.push(`  data = data.slice().sort((a, b) => {
    // sort descending
    const valueA = a${createPropertySelector(sort.path)}
    const valueB = b${createPropertySelector(sort.path)}
    return valueA > valueB ? -1 : valueA < valueB ? 1 : 0
  })
`);
    } else {
      queryParts.push(`  data = data.slice().sort((a, b) => {
    // sort ascending
    const valueA = a${createPropertySelector(sort.path)}
    const valueB = b${createPropertySelector(sort.path)}
    return valueA > valueB ? 1 : valueA < valueB ? -1 : 0
  })
`);
    }
  }
  if (projection && projection.paths) {
    if (projection.paths.length > 1) {
      const paths = projection.paths.map((path) => {
        const name = path[path.length - 1] || "item";
        const item = `item${createPropertySelector(path)}`;
        return `    ${JSON.stringify(name)}: ${item}`;
      });
      queryParts.push(`  data = data.map(item => ({
${paths.join(",\n")}})
  )
`);
    } else {
      const item = `item${createPropertySelector(projection.paths[0])}`;
      queryParts.push(`  data = data.map(item => ${item})
`);
    }
  }
  queryParts.push("  return data\n");
  return `function query (data) {
${queryParts.join("")}}`;
}
function executeQuery(json2, query) {
  const queryFn = new Function('"use strict";\n\n' + query + `

if (typeof query !== "function") {
  throw new Error("Cannot execute query: expecting a function named 'query' but is undefined")
}

return query;
`)();
  const output = queryFn(json2);
  return output !== void 0 ? output : null;
}

// ../node_modules/svelte-jsoneditor/plugins/value/components/BooleanToggle.svelte
var file33 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/plugins/value/components/BooleanToggle.svelte";
function add_css30(target) {
  append_styles(target, "svelte-9s78x6", ".jse-boolean-toggle.svelte-9s78x6{color:var(--jse-value-color-boolean);position:relative;padding-left:calc(0.5 * var(--jse-padding));padding-top:1px;height:var(--jse-line-height)}.jse-boolean-toggle.svelte-9s78x6:not(.jse-readonly){cursor:pointer}.svelte-9s78x6{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQm9vbGVhblRvZ2dsZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUNrQyxtQkFBbUIsY0FBQyxDQUFBLEFBQ3BELEtBQUssQ0FBRSxJQUFJLHlCQUF5QixDQUFDLENBQ3JDLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFlBQVksQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUM1QyxXQUFXLENBQUUsR0FBRyxDQUNoQixNQUFNLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxBQUNoQyxDQUFBLEFBRUEsaUNBQW1CLEtBQUssYUFBYSxDQUFDLEFBQUMsQ0FBQSxBQUNyQyxNQUFNLENBQUUsT0FBTyxBQUNqQixDQUFBLEFBQUEsY0FBQSxFQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJvb2xlYW5Ub2dnbGUuc3ZlbHRlIl19 */");
}
function create_fragment38(ctx) {
  let div;
  let icon;
  let div_title_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: {
      data: ctx[0] === true ? faCheckSquare : faSquare
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, title: true });
      var div_nodes = children(div);
      claim_component(icon.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-boolean-toggle svelte-9s78x6");
      attr_dev(div, "title", div_title_value = !ctx[1] ? "Click to toggle this boolean value" : `Boolean value ${ctx[0]}`);
      toggle_class(div, "jse-readonly", ctx[1]);
      add_location(div, file33, 26, 0, 617);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "mousedown", ctx[2], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const icon_changes = {};
      if (dirty & 1)
        icon_changes.data = ctx2[0] === true ? faCheckSquare : faSquare;
      icon.$set(icon_changes);
      if (!current || dirty & 3 && div_title_value !== (div_title_value = !ctx2[1] ? "Click to toggle this boolean value" : `Boolean value ${ctx2[0]}`)) {
        attr_dev(div, "title", div_title_value);
      }
      if (!current || dirty & 2) {
        toggle_class(div, "jse-readonly", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BooleanToggle", slots, []);
  let { path } = $$props;
  let { value } = $$props;
  let { readOnly } = $$props;
  let { onPatch } = $$props;
  let { focus: focus3 } = $$props;
  function toggleBooleanValue(event) {
    event.stopPropagation();
    if (readOnly) {
      return;
    }
    onPatch([
      {
        op: "replace",
        path: compileJSONPointer(path),
        value: !value
      }
    ]);
    setTimeout(focus3);
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<BooleanToggle> was created without expected prop 'path'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<BooleanToggle> was created without expected prop 'value'");
    }
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console.warn("<BooleanToggle> was created without expected prop 'readOnly'");
    }
    if (onPatch === void 0 && !("onPatch" in $$props || $$self.$$.bound[$$self.$$.props["onPatch"]])) {
      console.warn("<BooleanToggle> was created without expected prop 'onPatch'");
    }
    if (focus3 === void 0 && !("focus" in $$props || $$self.$$.bound[$$self.$$.props["focus"]])) {
      console.warn("<BooleanToggle> was created without expected prop 'focus'");
    }
  });
  const writable_props = ["path", "value", "readOnly", "onPatch", "focus"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BooleanToggle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(3, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onPatch" in $$props2)
      $$invalidate(4, onPatch = $$props2.onPatch);
    if ("focus" in $$props2)
      $$invalidate(5, focus3 = $$props2.focus);
  };
  $$self.$capture_state = () => ({
    faCheckSquare,
    faSquare,
    compileJSONPointer,
    Icon: Icon_default,
    path,
    value,
    readOnly,
    onPatch,
    focus: focus3,
    toggleBooleanValue
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(3, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onPatch" in $$props2)
      $$invalidate(4, onPatch = $$props2.onPatch);
    if ("focus" in $$props2)
      $$invalidate(5, focus3 = $$props2.focus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, readOnly, toggleBooleanValue, path, onPatch, focus3];
}
var BooleanToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance38,
      create_fragment38,
      not_equal,
      {
        path: 3,
        value: 0,
        readOnly: 1,
        onPatch: 4,
        focus: 5
      },
      add_css30
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BooleanToggle",
      options,
      id: create_fragment38.name
    });
  }
  get path() {
    throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPatch() {
    throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPatch(value) {
    throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    throw new Error("<BooleanToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focus(value) {
    throw new Error("<BooleanToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BooleanToggle_default = BooleanToggle;

// ../node_modules/svelte-jsoneditor/components/controls/ColorPickerPopup.svelte
var file34 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/ColorPickerPopup.svelte";
function add_css31(target) {
  append_styles(target, "svelte-heyltp", ".jse-color-picker-popup.svelte-heyltp .picker_wrapper.popup,.jse-color-picker-popup.svelte-heyltp .picker_wrapper.popup .picker_arrow::before,.jse-color-picker-popup.svelte-heyltp .picker_wrapper.popup .picker_arrow::after{background:var(--jse-color-picker-background);line-height:normal}.jse-color-picker-popup.svelte-heyltp .picker_slider,.jse-color-picker-popup.svelte-heyltp .picker_sl,.jse-color-picker-popup.svelte-heyltp .picker_editor input,.jse-color-picker-popup.svelte-heyltp .picker_sample,.jse-color-picker-popup.svelte-heyltp .picker_done button{box-shadow:var(--jse-color-picker-border-box-shadow)}.jse-color-picker-popup.svelte-heyltp .picker_editor input{background:var(--jse-background-color);color:var(--jse-text-color)}.jse-color-picker-popup.svelte-heyltp .picker_done button{background:var(--jse-button-background);color:var(--jse-button-color)}.jse-color-picker-popup.svelte-heyltp .picker_done button:hover{background:var(--jse-button-background-highlight)}.svelte-heyltp{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sb3JQaWNrZXJQb3B1cC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaUNvQyxxQ0FBQSxDQUFBLEFBQUEscUJBQUEsQUFBQSwwNkJBdUJuQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDb2xvclBpY2tlclBvcHVwLnN2ZWx0ZSJdfQ== */");
}
function create_fragment39(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-color-picker-popup svelte-heyltp");
      add_location(div, file34, 31, 0, 899);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[4](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[4](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ColorPickerPopup", slots, []);
  let { color } = $$props;
  let { onChange } = $$props;
  let { showOnTop } = $$props;
  let ref;
  let colorPicker;
  onMount(async () => {
    const VanillaPicker = (await import("./vanilla-picker.js")).default;
    colorPicker = new VanillaPicker({
      parent: ref,
      color,
      popup: showOnTop ? "top" : "bottom",
      onDone(color2) {
        const alpha = color2.rgba[3];
        const hex = alpha === 1 ? color2.hex.substring(0, 7) : color2.hex;
        onChange(hex);
      }
    });
    colorPicker.show();
  });
  onDestroy(() => {
    if (colorPicker) {
      colorPicker.destroy();
    }
  });
  $$self.$$.on_mount.push(function() {
    if (color === void 0 && !("color" in $$props || $$self.$$.bound[$$self.$$.props["color"]])) {
      console.warn("<ColorPickerPopup> was created without expected prop 'color'");
    }
    if (onChange === void 0 && !("onChange" in $$props || $$self.$$.bound[$$self.$$.props["onChange"]])) {
      console.warn("<ColorPickerPopup> was created without expected prop 'onChange'");
    }
    if (showOnTop === void 0 && !("showOnTop" in $$props || $$self.$$.bound[$$self.$$.props["showOnTop"]])) {
      console.warn("<ColorPickerPopup> was created without expected prop 'showOnTop'");
    }
  });
  const writable_props = ["color", "onChange", "showOnTop"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ColorPickerPopup> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("showOnTop" in $$props2)
      $$invalidate(3, showOnTop = $$props2.showOnTop);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    color,
    onChange,
    showOnTop,
    ref,
    colorPicker
  });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("showOnTop" in $$props2)
      $$invalidate(3, showOnTop = $$props2.showOnTop);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("colorPicker" in $$props2)
      colorPicker = $$props2.colorPicker;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, color, onChange, showOnTop, div_binding];
}
var ColorPickerPopup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { color: 1, onChange: 2, showOnTop: 3 }, add_css31);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ColorPickerPopup",
      options,
      id: create_fragment39.name
    });
  }
  get color() {
    throw new Error("<ColorPickerPopup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ColorPickerPopup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<ColorPickerPopup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<ColorPickerPopup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showOnTop() {
    throw new Error("<ColorPickerPopup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showOnTop(value) {
    throw new Error("<ColorPickerPopup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ColorPickerPopup_default = ColorPickerPopup;

// ../node_modules/svelte-jsoneditor/plugins/value/components/ColorPicker.svelte
var file35 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/plugins/value/components/ColorPicker.svelte";
function add_css32(target) {
  append_styles(target, "svelte-el52d1", ".jse-color-picker-button.svelte-el52d1{font-size:var(--jse-font-size-mono);width:var(--jse-color-picker-button-size);height:var(--jse-color-picker-button-size);box-sizing:border-box;padding:0;margin:2px;border:1px solid var(--jse-text-color);border-radius:2px;background:inherit;outline:none}.jse-color-picker-button.svelte-el52d1:not(.jse-readonly){cursor:pointer}.svelte-el52d1{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sb3JQaWNrZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQStEZ0Msd0JBQXdCLGNBQUMsQ0FBQSxBQUN2RCxTQUFTLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxDQUNwQyxLQUFLLENBQUUsSUFBSSw4QkFBOEIsQ0FBQyxDQUMxQyxNQUFNLENBQUUsSUFBSSw4QkFBOEIsQ0FBQyxDQUMzQyxVQUFVLENBQUUsVUFBVSxDQUN0QixPQUFPLENBQUUsQ0FBQyxDQUNWLE1BQU0sQ0FBRSxHQUFHLENBQ1gsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUN2QyxhQUFhLENBQUUsR0FBRyxDQUNsQixVQUFVLENBQUUsT0FBTyxDQUNuQixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFFQSxzQ0FBd0IsS0FBSyxhQUFhLENBQUMsQUFBQyxDQUFBLEFBQzFDLE1BQU0sQ0FBRSxPQUFPLEFBQ2pCLENBQUEsQUFBQSxjQUFBLEVBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ29sb3JQaWNrZXIuc3ZlbHRlIl19 */");
}
function create_fragment40(ctx) {
  let button;
  let button_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        style: true,
        title: true
      });
      children(button).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-color-picker-button svelte-el52d1");
      set_style(button, "background", ctx[2]);
      attr_dev(button, "title", button_title_value = !ctx[1] ? "Click to open a color picker" : `Color ${ctx[0]}`);
      toggle_class(button, "jse-readonly", ctx[1]);
      add_location(button, file35, 54, 0, 1536);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[3], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 4) {
        set_style(button, "background", ctx2[2]);
      }
      if (dirty & 3 && button_title_value !== (button_title_value = !ctx2[1] ? "Click to open a color picker" : `Color ${ctx2[0]}`)) {
        attr_dev(button, "title", button_title_value);
      }
      if (dirty & 2) {
        toggle_class(button, "jse-readonly", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let color;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ColorPicker", slots, []);
  const { openAbsolutePopup } = getContext("absolute-popup");
  let { path } = $$props;
  let { value } = $$props;
  let { readOnly } = $$props;
  let { onPatch } = $$props;
  let { focus: focus3 } = $$props;
  function onChange(color2) {
    onPatch([
      {
        op: "replace",
        path: compileJSONPointer(path),
        value: color2
      }
    ]);
    onClose();
  }
  function onClose() {
    focus3();
  }
  function openColorPicker(event) {
    if (readOnly) {
      return;
    }
    const height = 300;
    const top = event.target.getBoundingClientRect().top;
    const windowHeight = getWindow(event.target).innerHeight;
    const showOnTop = windowHeight - top < height && top > height;
    const props = { color: value, onChange, showOnTop };
    openAbsolutePopup(ColorPickerPopup_default, props, {
      anchor: event.target,
      closeOnOuterClick: true,
      onClose,
      offsetTop: 18,
      offsetLeft: -8,
      height
    });
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<ColorPicker> was created without expected prop 'path'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<ColorPicker> was created without expected prop 'value'");
    }
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console.warn("<ColorPicker> was created without expected prop 'readOnly'");
    }
    if (onPatch === void 0 && !("onPatch" in $$props || $$self.$$.bound[$$self.$$.props["onPatch"]])) {
      console.warn("<ColorPicker> was created without expected prop 'onPatch'");
    }
    if (focus3 === void 0 && !("focus" in $$props || $$self.$$.bound[$$self.$$.props["focus"]])) {
      console.warn("<ColorPicker> was created without expected prop 'focus'");
    }
  });
  const writable_props = ["path", "value", "readOnly", "onPatch", "focus"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ColorPicker> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(4, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onPatch" in $$props2)
      $$invalidate(5, onPatch = $$props2.onPatch);
    if ("focus" in $$props2)
      $$invalidate(6, focus3 = $$props2.focus);
  };
  $$self.$capture_state = () => ({
    getColorCSS,
    getWindow,
    compileJSONPointer,
    getContext,
    ColorPickerPopup: ColorPickerPopup_default,
    openAbsolutePopup,
    path,
    value,
    readOnly,
    onPatch,
    focus: focus3,
    onChange,
    onClose,
    openColorPicker,
    color
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(4, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readOnly" in $$props2)
      $$invalidate(1, readOnly = $$props2.readOnly);
    if ("onPatch" in $$props2)
      $$invalidate(5, onPatch = $$props2.onPatch);
    if ("focus" in $$props2)
      $$invalidate(6, focus3 = $$props2.focus);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(2, color = getColorCSS(value));
    }
  };
  return [value, readOnly, color, openColorPicker, path, onPatch, focus3];
}
var ColorPicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance40,
      create_fragment40,
      not_equal,
      {
        path: 4,
        value: 0,
        readOnly: 1,
        onPatch: 5,
        focus: 6
      },
      add_css32
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ColorPicker",
      options,
      id: create_fragment40.name
    });
  }
  get path() {
    throw new Error("<ColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<ColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<ColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<ColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPatch() {
    throw new Error("<ColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPatch(value) {
    throw new Error("<ColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    throw new Error("<ColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focus(value) {
    throw new Error("<ColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ColorPicker_default = ColorPicker;

// ../node_modules/svelte-jsoneditor/plugins/value/components/utils/getValueClass.js
var import_classnames4 = __toESM(require_classnames(), 1);
function getValueClass(value, parser) {
  const type = valueType(value, parser);
  return (0, import_classnames4.default)("jse-value", "jse-" + type, {
    "jse-url": isUrl(value),
    "jse-empty": typeof value === "string" && value.length === 0
  });
}

// ../node_modules/svelte-jsoneditor/plugins/value/components/EditableValue.svelte
function create_fragment41(ctx) {
  let editablediv;
  let current;
  editablediv = new EditableDiv_default({
    props: {
      value: ctx[1].escapeValue(ctx[0]),
      onChange: ctx[3],
      onCancel: ctx[4],
      onPaste: ctx[5],
      onFind: ctx[2],
      onValueClass: ctx[6]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(editablediv.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(editablediv.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(editablediv, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const editablediv_changes = {};
      if (dirty & 3)
        editablediv_changes.value = ctx2[1].escapeValue(ctx2[0]);
      if (dirty & 4)
        editablediv_changes.onFind = ctx2[2];
      editablediv.$set(editablediv_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(editablediv.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(editablediv.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(editablediv, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EditableValue", slots, []);
  let { path } = $$props;
  let { value } = $$props;
  let { parser } = $$props;
  let { normalization } = $$props;
  let { enforceString } = $$props;
  let { onPatch } = $$props;
  let { onPasteJson } = $$props;
  let { onSelect } = $$props;
  let { onFind } = $$props;
  let { focus: focus3 } = $$props;
  function convert(value2) {
    return enforceString ? value2 : stringConvert(value2, parser);
  }
  function handleChangeValue(newValue, updateSelection) {
    onPatch(
      [
        {
          op: "replace",
          path: compileJSONPointer(path),
          value: convert(normalization.unescapeValue(newValue))
        }
      ],
      (patchedJson, patchedState) => {
        const selection = updateSelection === UPDATE_SELECTION.NEXT_INSIDE ? getSelectionNextInside(patchedJson, patchedState, path) || patchedState.selection : createValueSelection(path, false);
        return { state: { ...patchedState, selection } };
      }
    );
    if (updateSelection !== UPDATE_SELECTION.SELF) {
      focus3();
    }
  }
  function handleCancelChange() {
    onSelect(createValueSelection(path, false));
    focus3();
  }
  function handlePaste(pastedText) {
    try {
      const pastedJson = parser.parse(pastedText);
      if (isObjectOrArray(pastedJson)) {
        onPasteJson({ path, contents: pastedJson });
      }
    } catch (err) {
    }
  }
  function handleOnValueClass(value2) {
    return getValueClass(convert(normalization.unescapeValue(value2)), parser);
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<EditableValue> was created without expected prop 'path'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<EditableValue> was created without expected prop 'value'");
    }
    if (parser === void 0 && !("parser" in $$props || $$self.$$.bound[$$self.$$.props["parser"]])) {
      console.warn("<EditableValue> was created without expected prop 'parser'");
    }
    if (normalization === void 0 && !("normalization" in $$props || $$self.$$.bound[$$self.$$.props["normalization"]])) {
      console.warn("<EditableValue> was created without expected prop 'normalization'");
    }
    if (enforceString === void 0 && !("enforceString" in $$props || $$self.$$.bound[$$self.$$.props["enforceString"]])) {
      console.warn("<EditableValue> was created without expected prop 'enforceString'");
    }
    if (onPatch === void 0 && !("onPatch" in $$props || $$self.$$.bound[$$self.$$.props["onPatch"]])) {
      console.warn("<EditableValue> was created without expected prop 'onPatch'");
    }
    if (onPasteJson === void 0 && !("onPasteJson" in $$props || $$self.$$.bound[$$self.$$.props["onPasteJson"]])) {
      console.warn("<EditableValue> was created without expected prop 'onPasteJson'");
    }
    if (onSelect === void 0 && !("onSelect" in $$props || $$self.$$.bound[$$self.$$.props["onSelect"]])) {
      console.warn("<EditableValue> was created without expected prop 'onSelect'");
    }
    if (onFind === void 0 && !("onFind" in $$props || $$self.$$.bound[$$self.$$.props["onFind"]])) {
      console.warn("<EditableValue> was created without expected prop 'onFind'");
    }
    if (focus3 === void 0 && !("focus" in $$props || $$self.$$.bound[$$self.$$.props["focus"]])) {
      console.warn("<EditableValue> was created without expected prop 'focus'");
    }
  });
  const writable_props = [
    "path",
    "value",
    "parser",
    "normalization",
    "enforceString",
    "onPatch",
    "onPasteJson",
    "onSelect",
    "onFind",
    "focus"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EditableValue> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(7, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("parser" in $$props2)
      $$invalidate(8, parser = $$props2.parser);
    if ("normalization" in $$props2)
      $$invalidate(1, normalization = $$props2.normalization);
    if ("enforceString" in $$props2)
      $$invalidate(9, enforceString = $$props2.enforceString);
    if ("onPatch" in $$props2)
      $$invalidate(10, onPatch = $$props2.onPatch);
    if ("onPasteJson" in $$props2)
      $$invalidate(11, onPasteJson = $$props2.onPasteJson);
    if ("onSelect" in $$props2)
      $$invalidate(12, onSelect = $$props2.onSelect);
    if ("onFind" in $$props2)
      $$invalidate(2, onFind = $$props2.onFind);
    if ("focus" in $$props2)
      $$invalidate(13, focus3 = $$props2.focus);
  };
  $$self.$capture_state = () => ({
    compileJSONPointer,
    isObjectOrArray,
    stringConvert,
    createValueSelection,
    getSelectionNextInside,
    getValueClass,
    EditableDiv: EditableDiv_default,
    UPDATE_SELECTION,
    path,
    value,
    parser,
    normalization,
    enforceString,
    onPatch,
    onPasteJson,
    onSelect,
    onFind,
    focus: focus3,
    convert,
    handleChangeValue,
    handleCancelChange,
    handlePaste,
    handleOnValueClass
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(7, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("parser" in $$props2)
      $$invalidate(8, parser = $$props2.parser);
    if ("normalization" in $$props2)
      $$invalidate(1, normalization = $$props2.normalization);
    if ("enforceString" in $$props2)
      $$invalidate(9, enforceString = $$props2.enforceString);
    if ("onPatch" in $$props2)
      $$invalidate(10, onPatch = $$props2.onPatch);
    if ("onPasteJson" in $$props2)
      $$invalidate(11, onPasteJson = $$props2.onPasteJson);
    if ("onSelect" in $$props2)
      $$invalidate(12, onSelect = $$props2.onSelect);
    if ("onFind" in $$props2)
      $$invalidate(2, onFind = $$props2.onFind);
    if ("focus" in $$props2)
      $$invalidate(13, focus3 = $$props2.focus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    normalization,
    onFind,
    handleChangeValue,
    handleCancelChange,
    handlePaste,
    handleOnValueClass,
    path,
    parser,
    enforceString,
    onPatch,
    onPasteJson,
    onSelect,
    focus3
  ];
}
var EditableValue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, not_equal, {
      path: 7,
      value: 0,
      parser: 8,
      normalization: 1,
      enforceString: 9,
      onPatch: 10,
      onPasteJson: 11,
      onSelect: 12,
      onFind: 2,
      focus: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EditableValue",
      options,
      id: create_fragment41.name
    });
  }
  get path() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get normalization() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set normalization(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enforceString() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enforceString(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPatch() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPatch(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPasteJson() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPasteJson(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFind() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFind(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    throw new Error("<EditableValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focus(value) {
    throw new Error("<EditableValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EditableValue_default = EditableValue;

// ../node_modules/svelte-jsoneditor/plugins/value/components/ReadonlyValue.svelte
var file36 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/plugins/value/components/ReadonlyValue.svelte";
function add_css33(target) {
  append_styles(target, "svelte-1sgglt3", '.jse-value.jse-string.svelte-1sgglt3{color:var(--jse-value-color-string)}.jse-value.jse-object.svelte-1sgglt3,.jse-value.jse-array.svelte-1sgglt3{min-width:16px;color:var(--jse-delimiter-color)}.jse-value.jse-number.svelte-1sgglt3{color:var(--jse-value-color-number)}.jse-value.jse-boolean.svelte-1sgglt3{color:var(--jse-value-color-boolean)}.jse-value.jse-null.svelte-1sgglt3{color:var(--jse-value-color-null)}.jse-value.jse-invalid.svelte-1sgglt3{color:var(--jse-text-color)}.jse-value.jse-url.svelte-1sgglt3{color:var(--jse-value-color-url);text-decoration:underline}.jse-value.svelte-1sgglt3{min-width:2em;padding:0 5px;box-sizing:border-box;outline:none;border-radius:1px;vertical-align:top;word-break:normal;overflow-wrap:anywhere;white-space:pre-wrap}.jse-value.svelte-1sgglt3:hover{background:var(--jse-hover-background-color)}.jse-value.jse-empty.svelte-1sgglt3{min-width:4em;outline:1px dotted var(--jse-tag-background);-moz-outline-radius:2px}.jse-value.jse-empty.svelte-1sgglt3::after{pointer-events:none;color:var(--jse-tag-background);content:"value"}.svelte-1sgglt3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVhZG9ubHlWYWx1ZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNkNpQyxVQUFBLFdBQUEsZUFBQSxDQUFBLHFoQ0ErQ2hDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlJlYWRvbmx5VmFsdWUuc3ZlbHRlIl19 */');
}
function create_else_block12(ctx) {
  let t_value = addNewLineSuffix(ctx[1].escapeValue(ctx[0])) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3 && t_value !== (t_value = addNewLineSuffix(ctx2[1].escapeValue(ctx2[0])) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(41:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let searchresulthighlighter;
  let current;
  searchresulthighlighter = new SearchResultHighlighter_default({
    props: {
      text: ctx[1].escapeValue(ctx[0]),
      searchResultItems: ctx[3]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(searchresulthighlighter.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(searchresulthighlighter.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(searchresulthighlighter, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const searchresulthighlighter_changes = {};
      if (dirty & 3)
        searchresulthighlighter_changes.text = ctx2[1].escapeValue(ctx2[0]);
      if (dirty & 8)
        searchresulthighlighter_changes.searchResultItems = ctx2[3];
      searchresulthighlighter.$set(searchresulthighlighter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchresulthighlighter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchresulthighlighter.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(searchresulthighlighter, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(39:2) {#if searchResultItems}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_title_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block22, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-type": true,
        class: true,
        title: true
      });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-type", "selectable-value");
      attr_dev(div, "class", div_class_value = null_to_empty(getValueClass(ctx[0], ctx[2])) + " svelte-1sgglt3");
      attr_dev(div, "title", div_title_value = ctx[4] ? "Ctrl+Click or Ctrl+Enter to open url in new window" : null);
      add_location(div, file36, 31, 0, 1034);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[5], false, false, false),
          listen_dev(div, "dblclick", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & 5 && div_class_value !== (div_class_value = null_to_empty(getValueClass(ctx2[0], ctx2[2])) + " svelte-1sgglt3")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 16 && div_title_value !== (div_title_value = ctx2[4] ? "Ctrl+Click or Ctrl+Enter to open url in new window" : null)) {
        attr_dev(div, "title", div_title_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let valueIsUrl;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ReadonlyValue", slots, []);
  let { path } = $$props;
  let { value } = $$props;
  let { readOnly } = $$props;
  let { normalization } = $$props;
  let { parser } = $$props;
  let { onSelect } = $$props;
  let { searchResultItems } = $$props;
  function handleValueClick(event) {
    if (typeof value === "string" && valueIsUrl && event.ctrlKey) {
      event.preventDefault();
      event.stopPropagation();
      window.open(value, "_blank");
    }
  }
  function handleValueDoubleClick(event) {
    if (!readOnly) {
      event.preventDefault();
      onSelect(createValueSelection(path, true));
    }
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<ReadonlyValue> was created without expected prop 'path'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<ReadonlyValue> was created without expected prop 'value'");
    }
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console.warn("<ReadonlyValue> was created without expected prop 'readOnly'");
    }
    if (normalization === void 0 && !("normalization" in $$props || $$self.$$.bound[$$self.$$.props["normalization"]])) {
      console.warn("<ReadonlyValue> was created without expected prop 'normalization'");
    }
    if (parser === void 0 && !("parser" in $$props || $$self.$$.bound[$$self.$$.props["parser"]])) {
      console.warn("<ReadonlyValue> was created without expected prop 'parser'");
    }
    if (onSelect === void 0 && !("onSelect" in $$props || $$self.$$.bound[$$self.$$.props["onSelect"]])) {
      console.warn("<ReadonlyValue> was created without expected prop 'onSelect'");
    }
    if (searchResultItems === void 0 && !("searchResultItems" in $$props || $$self.$$.bound[$$self.$$.props["searchResultItems"]])) {
      console.warn("<ReadonlyValue> was created without expected prop 'searchResultItems'");
    }
  });
  const writable_props = [
    "path",
    "value",
    "readOnly",
    "normalization",
    "parser",
    "onSelect",
    "searchResultItems"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ReadonlyValue> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(7, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readOnly" in $$props2)
      $$invalidate(8, readOnly = $$props2.readOnly);
    if ("normalization" in $$props2)
      $$invalidate(1, normalization = $$props2.normalization);
    if ("parser" in $$props2)
      $$invalidate(2, parser = $$props2.parser);
    if ("onSelect" in $$props2)
      $$invalidate(9, onSelect = $$props2.onSelect);
    if ("searchResultItems" in $$props2)
      $$invalidate(3, searchResultItems = $$props2.searchResultItems);
  };
  $$self.$capture_state = () => ({
    isUrl,
    createValueSelection,
    SearchResultHighlighter: SearchResultHighlighter_default,
    getValueClass,
    addNewLineSuffix,
    path,
    value,
    readOnly,
    normalization,
    parser,
    onSelect,
    searchResultItems,
    handleValueClick,
    handleValueDoubleClick,
    valueIsUrl
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(7, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readOnly" in $$props2)
      $$invalidate(8, readOnly = $$props2.readOnly);
    if ("normalization" in $$props2)
      $$invalidate(1, normalization = $$props2.normalization);
    if ("parser" in $$props2)
      $$invalidate(2, parser = $$props2.parser);
    if ("onSelect" in $$props2)
      $$invalidate(9, onSelect = $$props2.onSelect);
    if ("searchResultItems" in $$props2)
      $$invalidate(3, searchResultItems = $$props2.searchResultItems);
    if ("valueIsUrl" in $$props2)
      $$invalidate(4, valueIsUrl = $$props2.valueIsUrl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(4, valueIsUrl = isUrl(value));
    }
  };
  return [
    value,
    normalization,
    parser,
    searchResultItems,
    valueIsUrl,
    handleValueClick,
    handleValueDoubleClick,
    path,
    readOnly,
    onSelect
  ];
}
var ReadonlyValue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance42,
      create_fragment42,
      not_equal,
      {
        path: 7,
        value: 0,
        readOnly: 8,
        normalization: 1,
        parser: 2,
        onSelect: 9,
        searchResultItems: 3
      },
      add_css33
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ReadonlyValue",
      options,
      id: create_fragment42.name
    });
  }
  get path() {
    throw new Error("<ReadonlyValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<ReadonlyValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ReadonlyValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ReadonlyValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<ReadonlyValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<ReadonlyValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get normalization() {
    throw new Error("<ReadonlyValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set normalization(value) {
    throw new Error("<ReadonlyValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<ReadonlyValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<ReadonlyValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<ReadonlyValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<ReadonlyValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchResultItems() {
    throw new Error("<ReadonlyValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchResultItems(value) {
    throw new Error("<ReadonlyValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ReadonlyValue_default = ReadonlyValue;

// ../node_modules/svelte-jsoneditor/plugins/value/components/TimestampTag.svelte
var file37 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/plugins/value/components/TimestampTag.svelte";
function add_css34(target) {
  append_styles(target, "svelte-zarr19", ".jse-timestamp.svelte-zarr19{padding:0;margin:0;height:var(--jse-line-height);color:var(--jse-value-color-number);border-radius:3px}.svelte-zarr19{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGltZXN0YW1wVGFnLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFlaUMsY0FBYyxjQUFDLENBQUEsQUFDOUMsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxDQUNULE1BQU0sQ0FBRSxJQUFJLGlCQUFpQixDQUFDLENBQzlCLEtBQUssQ0FBRSxJQUFJLHdCQUF3QixDQUFDLENBQ3BDLGFBQWEsQ0FBRSxHQUFHLEFBQ3BCLENBQUEsQUFBQSxjQUFBLEVBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGltZXN0YW1wVGFnLnN2ZWx0ZSJdfQ== */");
}
function create_fragment43(ctx) {
  let div;
  let icon;
  let tooltip_action;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faClock }, $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(icon.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-timestamp svelte-zarr19");
      add_location(div, file37, 11, 0, 396);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(tooltip_action = tooltip.call(null, div, {
          text: ctx[0],
          ...ctx[1]
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 1)
        tooltip_action.update.call(null, {
          text: ctx2[0],
          ...ctx2[1]
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let text2;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimestampTag", slots, []);
  const absolutePopupContext = getContext("absolute-popup");
  let { value } = $$props;
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<TimestampTag> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TimestampTag> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    Icon: Icon_default,
    faClock,
    getContext,
    tooltip,
    absolutePopupContext,
    value,
    text: text2
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, text2 = `Time: ${new Date(value).toString()}`);
    }
  };
  return [text2, absolutePopupContext, value];
}
var TimestampTag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, not_equal, { value: 2 }, add_css34);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimestampTag",
      options,
      id: create_fragment43.name
    });
  }
  get value() {
    throw new Error("<TimestampTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TimestampTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimestampTag_default = TimestampTag;

// ../node_modules/svelte-jsoneditor/plugins/value/renderValue.js
function renderValue({ path, value, readOnly, enforceString, searchResultItems, isEditing, parser, normalization, onPatch, onPasteJson, onSelect, onFind, focus: focus3 }) {
  const renderers = [];
  if (!isEditing && isBoolean(value)) {
    renderers.push({
      component: BooleanToggle_default,
      props: { path, value, readOnly, onPatch, focus: focus3 }
    });
  }
  if (!isEditing && isColor(value)) {
    renderers.push({
      component: ColorPicker_default,
      props: { path, value, readOnly, onPatch, focus: focus3 }
    });
  }
  if (isEditing) {
    renderers.push({
      component: EditableValue_default,
      props: {
        path,
        value,
        enforceString,
        parser,
        normalization,
        onPatch,
        onPasteJson,
        onSelect,
        onFind,
        focus: focus3
      }
    });
  }
  if (!isEditing) {
    renderers.push({
      component: ReadonlyValue_default,
      props: { path, value, readOnly, parser, normalization, searchResultItems, onSelect }
    });
  }
  if (!isEditing && isTimestamp(value)) {
    renderers.push({
      component: TimestampTag_default,
      props: { value }
    });
  }
  return renderers;
}

// ../node_modules/svelte-jsoneditor/components/modals/transformModalState.js
var transformModalState = {};

// ../node_modules/svelte-select/src/utils/isOutOfViewport.js
function isOutOfViewport_default(parent, container) {
  const parentBounding = parent.getBoundingClientRect();
  const boundingContainer = container.getBoundingClientRect();
  const out = {};
  out.top = parentBounding.top < 0;
  out.left = parentBounding.left < 0;
  out.bottom = parentBounding.bottom + boundingContainer.height > (window.innerHeight || document.documentElement.clientHeight);
  out.right = parentBounding.right > (window.innerWidth || document.documentElement.clientWidth);
  out.any = out.top || out.left || out.bottom || out.right;
  return out;
}

// ../node_modules/svelte-select/src/Item.svelte
var file38 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-select/src/Item.svelte";
function add_css35(target) {
  append_styles(target, "svelte-8z6hlj", ".item.svelte-8z6hlj{cursor:default;height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--itemPadding, 0 20px);color:var(--itemColor, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.groupHeader.svelte-8z6hlj{text-transform:var(--groupTitleTextTransform, uppercase)}.groupItem.svelte-8z6hlj{padding-left:var(--groupItemPaddingLeft, 40px)}.item.svelte-8z6hlj:active{background:var(--itemActiveBackground, #b9daff)}.item.active.svelte-8z6hlj{background:var(--itemIsActiveBG, #007aff);color:var(--itemIsActiveColor, #fff)}.item.notSelectable.svelte-8z6hlj{color:var(--itemIsNotSelectableColor, #999)}.item.first.svelte-8z6hlj{border-radius:var(--itemFirstBorderRadius, 4px 4px 0 0)}.item.hover.svelte-8z6hlj:not(.active){background:var(--itemHoverBG, #e7f2ff);color:var(--itemHoverColor, inherit)}.svelte-8z6hlj{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSXRlbS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0NJLEtBQUssY0FBQyxDQUFBLEFBQ0YsTUFBTSxDQUFFLE9BQU8sQ0FDZixNQUFNLENBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQzNCLFdBQVcsQ0FBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FDaEMsT0FBTyxDQUFFLElBQUksYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUNuQyxLQUFLLENBQUUsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQ2hDLGFBQWEsQ0FBRSxRQUFRLENBQ3ZCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFdBQVcsQ0FBRSxNQUFNLEFBQ3ZCLENBQUEsQUFFQSxZQUFZLGNBQUMsQ0FBQSxBQUNULGNBQWMsQ0FBRSxJQUFJLHlCQUF5QixDQUFDLFVBQVUsQ0FBQyxBQUM3RCxDQUFBLEFBRUEsVUFBVSxjQUFDLENBQUEsQUFDUCxZQUFZLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQUFDbkQsQ0FBQSxBQUVBLG1CQUFLLE9BQU8sQUFBQyxDQUFBLEFBQ1QsVUFBVSxDQUFFLElBQUksc0JBQXNCLENBQUMsUUFBUSxDQUFDLEFBQ3BELENBQUEsQUFFQSxLQUFLLE9BQU8sY0FBQyxDQUFBLEFBQ1QsVUFBVSxDQUFFLElBQUksZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQzFDLEtBQUssQ0FBRSxJQUFJLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxBQUN6QyxDQUFBLEFBRUQsS0FBSyxjQUFjLGNBQUMsQ0FBQSxBQUNmLEtBQUssQ0FBRSxJQUFJLDBCQUEwQixDQUFDLEtBQUssQ0FBQyxBQUNoRCxDQUFBLEFBRUEsS0FBSyxNQUFNLGNBQUMsQ0FBQSxBQUNSLGFBQWEsQ0FBRSxJQUFJLHVCQUF1QixDQUFDLFlBQVksQ0FBQyxBQUM1RCxDQUFBLEFBRUEsS0FBSyxvQkFBTSxLQUFLLE9BQU8sQ0FBQyxBQUFDLENBQUEsQUFDckIsVUFBVSxDQUFFLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUN2QyxLQUFLLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQUFDekMsQ0FBQSxnQkFDSiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJJdGVtLnN2ZWx0ZSJdfQ== */");
}
function create_fragment44(ctx) {
  let div;
  let raw_value = ctx[0](ctx[1], ctx[2]) + "";
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "item " + ctx[3] + " svelte-8z6hlj");
      add_location(div, file38, 78, 0, 1841);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 7 && raw_value !== (raw_value = ctx2[0](ctx2[1], ctx2[2]) + ""))
        div.innerHTML = raw_value;
      ;
      if (dirty & 8 && div_class_value !== (div_class_value = "item " + ctx2[3] + " svelte-8z6hlj")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, []);
  let { isActive = false } = $$props;
  let { isFirst = false } = $$props;
  let { isHover = false } = $$props;
  let { isSelectable = false } = $$props;
  let { getOptionLabel = void 0 } = $$props;
  let { item = void 0 } = $$props;
  let { filterText = "" } = $$props;
  let itemClasses = "";
  const writable_props = [
    "isActive",
    "isFirst",
    "isHover",
    "isSelectable",
    "getOptionLabel",
    "item",
    "filterText"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Item> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(4, isActive = $$props2.isActive);
    if ("isFirst" in $$props2)
      $$invalidate(5, isFirst = $$props2.isFirst);
    if ("isHover" in $$props2)
      $$invalidate(6, isHover = $$props2.isHover);
    if ("isSelectable" in $$props2)
      $$invalidate(7, isSelectable = $$props2.isSelectable);
    if ("getOptionLabel" in $$props2)
      $$invalidate(0, getOptionLabel = $$props2.getOptionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("filterText" in $$props2)
      $$invalidate(2, filterText = $$props2.filterText);
  };
  $$self.$capture_state = () => ({
    isActive,
    isFirst,
    isHover,
    isSelectable,
    getOptionLabel,
    item,
    filterText,
    itemClasses
  });
  $$self.$inject_state = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(4, isActive = $$props2.isActive);
    if ("isFirst" in $$props2)
      $$invalidate(5, isFirst = $$props2.isFirst);
    if ("isHover" in $$props2)
      $$invalidate(6, isHover = $$props2.isHover);
    if ("isSelectable" in $$props2)
      $$invalidate(7, isSelectable = $$props2.isSelectable);
    if ("getOptionLabel" in $$props2)
      $$invalidate(0, getOptionLabel = $$props2.getOptionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("filterText" in $$props2)
      $$invalidate(2, filterText = $$props2.filterText);
    if ("itemClasses" in $$props2)
      $$invalidate(3, itemClasses = $$props2.itemClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 242) {
      $: {
        const classes = [];
        if (isActive) {
          classes.push("active");
        }
        if (isFirst) {
          classes.push("first");
        }
        if (isHover) {
          classes.push("hover");
        }
        if (item.isGroupHeader) {
          classes.push("groupHeader");
        }
        if (item.isGroupItem) {
          classes.push("groupItem");
        }
        if (!isSelectable) {
          classes.push("notSelectable");
        }
        $$invalidate(3, itemClasses = classes.join(" "));
      }
    }
  };
  return [
    getOptionLabel,
    item,
    filterText,
    itemClasses,
    isActive,
    isFirst,
    isHover,
    isSelectable
  ];
}
var Item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance44,
      create_fragment44,
      safe_not_equal,
      {
        isActive: 4,
        isFirst: 5,
        isHover: 6,
        isSelectable: 7,
        getOptionLabel: 0,
        item: 1,
        filterText: 2
      },
      add_css35
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment44.name
    });
  }
  get isActive() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isActive(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isFirst() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isFirst(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isHover() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isHover(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSelectable() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelectable(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getOptionLabel() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getOptionLabel(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get item() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterText() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterText(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Item_default = Item;

// ../node_modules/svelte-select/src/List.svelte
var file39 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-select/src/List.svelte";
function add_css36(target) {
  append_styles(target, "svelte-15qlsrv", ".listContainer.svelte-15qlsrv{box-shadow:var(--listShadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--listBorderRadius, 4px);max-height:var(--listMaxHeight, 250px);overflow-y:auto;background:var(--listBackground, #fff);border:var(--listBorder, none);position:var(--listPosition, absolute);z-index:var(--listZIndex, 2);width:100%;left:var(--listLeft, 0);right:var(--listRight, 0)}.virtualList.svelte-15qlsrv{height:var(--virtualListHeight, 200px)}.listGroupTitle.svelte-15qlsrv{color:var(--groupTitleColor, #8f8f8f);cursor:default;font-size:var(--groupTitleFontSize, 12px);font-weight:var(--groupTitleFontWeight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--groupTitlePadding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--groupTitleTextTransform, uppercase)}.empty.svelte-15qlsrv{text-align:var(--listEmptyTextAlign, center);padding:var(--listEmptyPadding, 20px 0);color:var(--listEmptyColor, #78848f)}.svelte-15qlsrv{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlzdC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK09JLGNBQWMsZUFBQyxDQUFBLEFBQ1gsVUFBVSxDQUFFLElBQUksWUFBWSxDQUFDLG1DQUFtQyxDQUFDLENBQ2pFLGFBQWEsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUMzQyxVQUFVLENBQUUsSUFBSSxlQUFlLENBQUMsTUFBTSxDQUFDLENBQ3ZDLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUN2QyxNQUFNLENBQUUsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQy9CLFFBQVEsQ0FBRSxJQUFJLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FDdkMsT0FBTyxDQUFFLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUM3QixLQUFLLENBQUUsSUFBSSxDQUNYLElBQUksQ0FBRSxJQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FDeEIsS0FBSyxDQUFFLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxBQUM5QixDQUFBLEFBRUEsWUFBWSxlQUFDLENBQUEsQUFDVCxNQUFNLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQUFDM0MsQ0FBQSxBQUVBLGVBQWUsZUFBQyxDQUFBLEFBQ1osS0FBSyxDQUFFLElBQUksaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQ3RDLE1BQU0sQ0FBRSxPQUFPLENBQ2YsU0FBUyxDQUFFLElBQUksb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQzFDLFdBQVcsQ0FBRSxJQUFJLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUM3QyxNQUFNLENBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQzNCLFdBQVcsQ0FBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FDaEMsT0FBTyxDQUFFLElBQUksbUJBQW1CLENBQUMsT0FBTyxDQUFDLENBQ3pDLGFBQWEsQ0FBRSxRQUFRLENBQ3ZCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGNBQWMsQ0FBRSxJQUFJLHlCQUF5QixDQUFDLFVBQVUsQ0FBQyxBQUM3RCxDQUFBLEFBRUEsTUFBTSxlQUFDLENBQUEsQUFDSCxVQUFVLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FDN0MsT0FBTyxDQUFFLElBQUksa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQ3hDLEtBQUssQ0FBRSxJQUFJLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxBQUN6QyxDQUFBLGlCQUNKIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkxpc3Quc3ZlbHRlIl19 */");
}
function get_each_context13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[42] = i;
  return child_ctx;
}
function create_else_block13(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block13(get_each_context13(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_23(ctx);
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.l(nodes);
      }
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 114390) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context13(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block13(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_23(ctx2);
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(309:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return {
      props: {
        items: ctx2[1],
        itemHeight: ctx2[8],
        $$slots: {
          default: [
            create_default_slot2,
            ({ item, i }) => ({ 41: item, 42: i }),
            ({ item, i }) => [0, (item ? 1024 : 0) | (i ? 2048 : 0)]
          ]
        },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 2)
        switch_instance_changes.items = ctx2[1];
      if (dirty[0] & 256)
        switch_instance_changes.itemHeight = ctx2[8];
      if (dirty[0] & 9814 | dirty[1] & 11264) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(286:4) {#if isVirtualList}",
    ctx
  });
  return block;
}
function create_else_block_23(ctx) {
  let if_block_anchor;
  let if_block = !ctx[11] && create_if_block_211(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[11]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_211(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy2(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_23.name,
    type: "else",
    source: "(331:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_211(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[12]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ctx[12]);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "empty svelte-15qlsrv");
      add_location(div, file39, 332, 16, 10337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data_dev(t, ctx2[12]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(332:12) {#if !hideEmptyState}",
    ctx
  });
  return block;
}
function create_else_block_14(ctx) {
  let div;
  let switch_instance;
  let t;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    return {
      props: {
        item: ctx2[41],
        filterText: ctx2[13],
        getOptionLabel: ctx2[6],
        isFirst: isItemFirst(ctx2[42]),
        isActive: isItemActive(ctx2[41], ctx2[9], ctx2[10]),
        isHover: isItemHover(ctx2[2], ctx2[41], ctx2[42], ctx2[1]),
        isSelectable: isItemSelectable(ctx2[41])
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  function mouseover_handler_1() {
    return ctx[29](ctx[42]);
  }
  function focus_handler_1() {
    return ctx[30](ctx[42]);
  }
  function click_handler_1(...args) {
    return ctx[31](ctx[41], ctx[42], ...args);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, tabindex: true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listItem svelte-15qlsrv");
      attr_dev(div, "tabindex", "-1");
      add_location(div, file39, 313, 16, 9517);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append_hydration_dev(div, t);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "mouseover", mouseover_handler_1, false, false, false),
          listen_dev(div, "focus", focus_handler_1, false, false, false),
          listen_dev(div, "click", click_handler_1, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 2)
        switch_instance_changes.item = ctx[41];
      if (dirty[0] & 8192)
        switch_instance_changes.filterText = ctx[13];
      if (dirty[0] & 64)
        switch_instance_changes.getOptionLabel = ctx[6];
      if (dirty[0] & 1538)
        switch_instance_changes.isActive = isItemActive(ctx[41], ctx[9], ctx[10]);
      if (dirty[0] & 6)
        switch_instance_changes.isHover = isItemHover(ctx[2], ctx[41], ctx[42], ctx[1]);
      if (dirty[0] & 2)
        switch_instance_changes.isSelectable = isItemSelectable(ctx[41]);
      if (switch_value !== (switch_value = ctx[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(313:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let div;
  let t_value = ctx[7](ctx[41]) + "";
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listGroupTitle svelte-15qlsrv");
      add_location(div, file39, 311, 16, 9419);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 130 && t_value !== (t_value = ctx2[7](ctx2[41]) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(311:12) {#if item.isGroupHeader && !item.isSelectable}",
    ctx
  });
  return block;
}
function create_each_block13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_114, create_else_block_14];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[41].isGroupHeader && !ctx2[41].isSelectable)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block13.name,
    type: "each",
    source: "(310:8) {#each items as item, i}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    return {
      props: {
        item: ctx2[41],
        filterText: ctx2[13],
        getOptionLabel: ctx2[6],
        isFirst: isItemFirst(ctx2[42]),
        isActive: isItemActive(ctx2[41], ctx2[9], ctx2[10]),
        isHover: isItemHover(ctx2[2], ctx2[41], ctx2[42], ctx2[1]),
        isSelectable: isItemSelectable(ctx2[41])
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  function mouseover_handler() {
    return ctx[26](ctx[42]);
  }
  function focus_handler() {
    return ctx[27](ctx[42]);
  }
  function click_handler(...args) {
    return ctx[28](ctx[41], ctx[42], ...args);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listItem svelte-15qlsrv");
      add_location(div, file39, 292, 12, 8625);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "mouseover", mouseover_handler, false, false, false),
          listen_dev(div, "focus", focus_handler, false, false, false),
          listen_dev(div, "click", click_handler, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[1] & 1024)
        switch_instance_changes.item = ctx[41];
      if (dirty[0] & 8192)
        switch_instance_changes.filterText = ctx[13];
      if (dirty[0] & 64)
        switch_instance_changes.getOptionLabel = ctx[6];
      if (dirty[1] & 2048)
        switch_instance_changes.isFirst = isItemFirst(ctx[42]);
      if (dirty[0] & 1536 | dirty[1] & 1024)
        switch_instance_changes.isActive = isItemActive(ctx[41], ctx[9], ctx[10]);
      if (dirty[0] & 6 | dirty[1] & 3072)
        switch_instance_changes.isHover = isItemHover(ctx[2], ctx[41], ctx[42], ctx[1]);
      if (dirty[1] & 1024)
        switch_instance_changes.isSelectable = isItemSelectable(ctx[41]);
      if (switch_value !== (switch_value = ctx[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block23, create_else_block13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listContainer svelte-15qlsrv");
      attr_dev(div, "style", ctx[14]);
      toggle_class(div, "virtualList", ctx[5]);
      add_location(div, file39, 280, 0, 8329);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[32](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "keydown", ctx[17], false, false, false),
          listen_dev(window, "resize", ctx[18], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & 16384) {
        attr_dev(div, "style", ctx2[14]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div, "virtualList", ctx2[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function isItemActive(item, value, optionIdentifier) {
  return value && value[optionIdentifier] === item[optionIdentifier];
}
function isItemFirst(itemIndex) {
  return itemIndex === 0;
}
function isItemHover(hoverItemIndex, item, itemIndex, items) {
  return isItemSelectable(item) && (hoverItemIndex === itemIndex || items.length === 1);
}
function isItemSelectable(item) {
  return item.isGroupHeader && item.isSelectable || item.selectable || !item.hasOwnProperty("selectable");
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, []);
  const dispatch = createEventDispatcher();
  let { container = void 0 } = $$props;
  let { VirtualList: VirtualList2 = null } = $$props;
  let { Item: Item2 = Item_default } = $$props;
  let { isVirtualList = false } = $$props;
  let { items = [] } = $$props;
  let { labelIdentifier = "label" } = $$props;
  let { getOptionLabel = (option, filterText2) => {
    if (option)
      return option.isCreator ? `Create "${filterText2}"` : option[labelIdentifier];
  } } = $$props;
  let { getGroupHeaderLabel = null } = $$props;
  let { itemHeight = 40 } = $$props;
  let { hoverItemIndex = 0 } = $$props;
  let { value = void 0 } = $$props;
  let { optionIdentifier = "value" } = $$props;
  let { hideEmptyState = false } = $$props;
  let { noOptionsMessage = "No options" } = $$props;
  let { isMulti = false } = $$props;
  let { activeItemIndex = 0 } = $$props;
  let { filterText = "" } = $$props;
  let { parent = null } = $$props;
  let { listPlacement = null } = $$props;
  let { listAutoWidth = null } = $$props;
  let { listOffset = 5 } = $$props;
  let isScrollingTimer = 0;
  let isScrolling = false;
  let prev_items;
  onMount(() => {
    if (items.length > 0 && !isMulti && value) {
      const _hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === value[optionIdentifier]);
      if (_hoverItemIndex) {
        $$invalidate(2, hoverItemIndex = _hoverItemIndex);
      }
    }
    scrollToActiveItem("active");
    container.addEventListener(
      "scroll",
      () => {
        clearTimeout(isScrollingTimer);
        isScrollingTimer = setTimeout(
          () => {
            isScrolling = false;
          },
          100
        );
      },
      false
    );
  });
  beforeUpdate(() => {
    if (!items)
      $$invalidate(1, items = []);
    if (items !== prev_items && items.length > 0) {
      $$invalidate(2, hoverItemIndex = 0);
    }
    prev_items = items;
  });
  function handleSelect(item) {
    if (item.isCreator)
      return;
    dispatch("itemSelected", item);
  }
  function handleHover(i) {
    if (isScrolling)
      return;
    $$invalidate(2, hoverItemIndex = i);
  }
  function handleClick(args) {
    const { item, i, event } = args;
    event.stopPropagation();
    if (value && !isMulti && value[optionIdentifier] === item[optionIdentifier])
      return closeList();
    if (item.isCreator) {
      dispatch("itemCreated", filterText);
    } else if (isItemSelectable(item)) {
      $$invalidate(19, activeItemIndex = i);
      $$invalidate(2, hoverItemIndex = i);
      handleSelect(item);
    }
  }
  function closeList() {
    dispatch("closeList");
  }
  async function updateHoverItem(increment) {
    if (isVirtualList)
      return;
    let isNonSelectableItem = true;
    while (isNonSelectableItem) {
      if (increment > 0 && hoverItemIndex === items.length - 1) {
        $$invalidate(2, hoverItemIndex = 0);
      } else if (increment < 0 && hoverItemIndex === 0) {
        $$invalidate(2, hoverItemIndex = items.length - 1);
      } else {
        $$invalidate(2, hoverItemIndex = hoverItemIndex + increment);
      }
      isNonSelectableItem = !isItemSelectable(items[hoverItemIndex]);
    }
    await tick();
    scrollToActiveItem("hover");
  }
  function handleKeyDown(e) {
    switch (e.key) {
      case "Escape":
        e.preventDefault();
        closeList();
        break;
      case "ArrowDown":
        e.preventDefault();
        items.length && updateHoverItem(1);
        break;
      case "ArrowUp":
        e.preventDefault();
        items.length && updateHoverItem(-1);
        break;
      case "Enter":
        e.preventDefault();
        if (items.length === 0)
          break;
        const hoverItem = items[hoverItemIndex];
        if (value && !isMulti && value[optionIdentifier] === hoverItem[optionIdentifier]) {
          closeList();
          break;
        }
        if (hoverItem.isCreator) {
          dispatch("itemCreated", filterText);
        } else {
          $$invalidate(19, activeItemIndex = hoverItemIndex);
          handleSelect(items[hoverItemIndex]);
        }
        break;
      case "Tab":
        e.preventDefault();
        if (items.length === 0) {
          return closeList();
        }
        if (value && value[optionIdentifier] === items[hoverItemIndex][optionIdentifier])
          return closeList();
        $$invalidate(19, activeItemIndex = hoverItemIndex);
        handleSelect(items[hoverItemIndex]);
        break;
    }
  }
  function scrollToActiveItem(className) {
    if (isVirtualList || !container)
      return;
    let offsetBounding;
    const focusedElemBounding = container.querySelector(`.listItem .${className}`);
    if (focusedElemBounding) {
      offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
    }
    $$invalidate(0, container.scrollTop -= offsetBounding, container);
  }
  let listStyle;
  function computePlacement() {
    const { height, width } = parent.getBoundingClientRect();
    $$invalidate(14, listStyle = "");
    $$invalidate(14, listStyle += `min-width:${width}px;width:${listAutoWidth ? "auto" : "100%"};`);
    if (listPlacement === "top" || listPlacement === "auto" && isOutOfViewport_default(parent, container).bottom) {
      $$invalidate(14, listStyle += `bottom:${height + listOffset}px;`);
    } else {
      $$invalidate(14, listStyle += `top:${height + listOffset}px;`);
    }
  }
  const writable_props = [
    "container",
    "VirtualList",
    "Item",
    "isVirtualList",
    "items",
    "labelIdentifier",
    "getOptionLabel",
    "getGroupHeaderLabel",
    "itemHeight",
    "hoverItemIndex",
    "value",
    "optionIdentifier",
    "hideEmptyState",
    "noOptionsMessage",
    "isMulti",
    "activeItemIndex",
    "filterText",
    "parent",
    "listPlacement",
    "listAutoWidth",
    "listOffset"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<List> was created with unknown prop '${key}'`);
  });
  const mouseover_handler = (i) => handleHover(i);
  const focus_handler = (i) => handleHover(i);
  const click_handler = (item, i, event) => handleClick({ item, i, event });
  const mouseover_handler_1 = (i) => handleHover(i);
  const focus_handler_1 = (i) => handleHover(i);
  const click_handler_1 = (item, i, event) => handleClick({ item, i, event });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("VirtualList" in $$props2)
      $$invalidate(3, VirtualList2 = $$props2.VirtualList);
    if ("Item" in $$props2)
      $$invalidate(4, Item2 = $$props2.Item);
    if ("isVirtualList" in $$props2)
      $$invalidate(5, isVirtualList = $$props2.isVirtualList);
    if ("items" in $$props2)
      $$invalidate(1, items = $$props2.items);
    if ("labelIdentifier" in $$props2)
      $$invalidate(20, labelIdentifier = $$props2.labelIdentifier);
    if ("getOptionLabel" in $$props2)
      $$invalidate(6, getOptionLabel = $$props2.getOptionLabel);
    if ("getGroupHeaderLabel" in $$props2)
      $$invalidate(7, getGroupHeaderLabel = $$props2.getGroupHeaderLabel);
    if ("itemHeight" in $$props2)
      $$invalidate(8, itemHeight = $$props2.itemHeight);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(2, hoverItemIndex = $$props2.hoverItemIndex);
    if ("value" in $$props2)
      $$invalidate(9, value = $$props2.value);
    if ("optionIdentifier" in $$props2)
      $$invalidate(10, optionIdentifier = $$props2.optionIdentifier);
    if ("hideEmptyState" in $$props2)
      $$invalidate(11, hideEmptyState = $$props2.hideEmptyState);
    if ("noOptionsMessage" in $$props2)
      $$invalidate(12, noOptionsMessage = $$props2.noOptionsMessage);
    if ("isMulti" in $$props2)
      $$invalidate(21, isMulti = $$props2.isMulti);
    if ("activeItemIndex" in $$props2)
      $$invalidate(19, activeItemIndex = $$props2.activeItemIndex);
    if ("filterText" in $$props2)
      $$invalidate(13, filterText = $$props2.filterText);
    if ("parent" in $$props2)
      $$invalidate(22, parent = $$props2.parent);
    if ("listPlacement" in $$props2)
      $$invalidate(23, listPlacement = $$props2.listPlacement);
    if ("listAutoWidth" in $$props2)
      $$invalidate(24, listAutoWidth = $$props2.listAutoWidth);
    if ("listOffset" in $$props2)
      $$invalidate(25, listOffset = $$props2.listOffset);
  };
  $$self.$capture_state = () => ({
    beforeUpdate,
    createEventDispatcher,
    onMount,
    tick,
    isOutOfViewport: isOutOfViewport_default,
    ItemComponent: Item_default,
    dispatch,
    container,
    VirtualList: VirtualList2,
    Item: Item2,
    isVirtualList,
    items,
    labelIdentifier,
    getOptionLabel,
    getGroupHeaderLabel,
    itemHeight,
    hoverItemIndex,
    value,
    optionIdentifier,
    hideEmptyState,
    noOptionsMessage,
    isMulti,
    activeItemIndex,
    filterText,
    parent,
    listPlacement,
    listAutoWidth,
    listOffset,
    isScrollingTimer,
    isScrolling,
    prev_items,
    handleSelect,
    handleHover,
    handleClick,
    closeList,
    updateHoverItem,
    handleKeyDown,
    scrollToActiveItem,
    isItemActive,
    isItemFirst,
    isItemHover,
    isItemSelectable,
    listStyle,
    computePlacement
  });
  $$self.$inject_state = ($$props2) => {
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("VirtualList" in $$props2)
      $$invalidate(3, VirtualList2 = $$props2.VirtualList);
    if ("Item" in $$props2)
      $$invalidate(4, Item2 = $$props2.Item);
    if ("isVirtualList" in $$props2)
      $$invalidate(5, isVirtualList = $$props2.isVirtualList);
    if ("items" in $$props2)
      $$invalidate(1, items = $$props2.items);
    if ("labelIdentifier" in $$props2)
      $$invalidate(20, labelIdentifier = $$props2.labelIdentifier);
    if ("getOptionLabel" in $$props2)
      $$invalidate(6, getOptionLabel = $$props2.getOptionLabel);
    if ("getGroupHeaderLabel" in $$props2)
      $$invalidate(7, getGroupHeaderLabel = $$props2.getGroupHeaderLabel);
    if ("itemHeight" in $$props2)
      $$invalidate(8, itemHeight = $$props2.itemHeight);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(2, hoverItemIndex = $$props2.hoverItemIndex);
    if ("value" in $$props2)
      $$invalidate(9, value = $$props2.value);
    if ("optionIdentifier" in $$props2)
      $$invalidate(10, optionIdentifier = $$props2.optionIdentifier);
    if ("hideEmptyState" in $$props2)
      $$invalidate(11, hideEmptyState = $$props2.hideEmptyState);
    if ("noOptionsMessage" in $$props2)
      $$invalidate(12, noOptionsMessage = $$props2.noOptionsMessage);
    if ("isMulti" in $$props2)
      $$invalidate(21, isMulti = $$props2.isMulti);
    if ("activeItemIndex" in $$props2)
      $$invalidate(19, activeItemIndex = $$props2.activeItemIndex);
    if ("filterText" in $$props2)
      $$invalidate(13, filterText = $$props2.filterText);
    if ("parent" in $$props2)
      $$invalidate(22, parent = $$props2.parent);
    if ("listPlacement" in $$props2)
      $$invalidate(23, listPlacement = $$props2.listPlacement);
    if ("listAutoWidth" in $$props2)
      $$invalidate(24, listAutoWidth = $$props2.listAutoWidth);
    if ("listOffset" in $$props2)
      $$invalidate(25, listOffset = $$props2.listOffset);
    if ("isScrollingTimer" in $$props2)
      isScrollingTimer = $$props2.isScrollingTimer;
    if ("isScrolling" in $$props2)
      isScrolling = $$props2.isScrolling;
    if ("prev_items" in $$props2)
      prev_items = $$props2.prev_items;
    if ("listStyle" in $$props2)
      $$invalidate(14, listStyle = $$props2.listStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4194305) {
      $: {
        if (parent && container)
          computePlacement();
      }
    }
  };
  return [
    container,
    items,
    hoverItemIndex,
    VirtualList2,
    Item2,
    isVirtualList,
    getOptionLabel,
    getGroupHeaderLabel,
    itemHeight,
    value,
    optionIdentifier,
    hideEmptyState,
    noOptionsMessage,
    filterText,
    listStyle,
    handleHover,
    handleClick,
    handleKeyDown,
    computePlacement,
    activeItemIndex,
    labelIdentifier,
    isMulti,
    parent,
    listPlacement,
    listAutoWidth,
    listOffset,
    mouseover_handler,
    focus_handler,
    click_handler,
    mouseover_handler_1,
    focus_handler_1,
    click_handler_1,
    div_binding
  ];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance45,
      create_fragment45,
      safe_not_equal,
      {
        container: 0,
        VirtualList: 3,
        Item: 4,
        isVirtualList: 5,
        items: 1,
        labelIdentifier: 20,
        getOptionLabel: 6,
        getGroupHeaderLabel: 7,
        itemHeight: 8,
        hoverItemIndex: 2,
        value: 9,
        optionIdentifier: 10,
        hideEmptyState: 11,
        noOptionsMessage: 12,
        isMulti: 21,
        activeItemIndex: 19,
        filterText: 13,
        parent: 22,
        listPlacement: 23,
        listAutoWidth: 24,
        listOffset: 25
      },
      add_css36,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment45.name
    });
  }
  get container() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get VirtualList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set VirtualList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Item() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Item(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVirtualList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVirtualList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelIdentifier() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelIdentifier(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getOptionLabel() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getOptionLabel(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getGroupHeaderLabel() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getGroupHeaderLabel(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemHeight() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemHeight(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hoverItemIndex() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hoverItemIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get optionIdentifier() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set optionIdentifier(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideEmptyState() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideEmptyState(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noOptionsMessage() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noOptionsMessage(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isMulti() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isMulti(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeItemIndex() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeItemIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterText() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterText(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listPlacement() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listPlacement(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listAutoWidth() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listAutoWidth(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listOffset() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listOffset(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;

// ../node_modules/svelte-select/src/Selection.svelte
var file40 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-select/src/Selection.svelte";
function add_css37(target) {
  append_styles(target, "svelte-1je8si1", ".selection.svelte-1je8si1{text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap}.svelte-1je8si1{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFNSSxVQUFVLGVBQUMsQ0FBQSxBQUNQLGFBQWEsQ0FBRSxRQUFRLENBQ3ZCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLEFBQ3ZCLENBQUEsaUJBQ0oiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VsZWN0aW9uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment46(ctx) {
  let div;
  let raw_value = ctx[0](ctx[1]) + "";
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "selection svelte-1je8si1");
      add_location(div, file40, 13, 0, 234);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 3 && raw_value !== (raw_value = ctx2[0](ctx2[1]) + ""))
        div.innerHTML = raw_value;
      ;
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Selection", slots, []);
  let { getSelectionLabel = void 0 } = $$props;
  let { item = void 0 } = $$props;
  const writable_props = ["getSelectionLabel", "item"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Selection> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("getSelectionLabel" in $$props2)
      $$invalidate(0, getSelectionLabel = $$props2.getSelectionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  $$self.$capture_state = () => ({ getSelectionLabel, item });
  $$self.$inject_state = ($$props2) => {
    if ("getSelectionLabel" in $$props2)
      $$invalidate(0, getSelectionLabel = $$props2.getSelectionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [getSelectionLabel, item];
}
var Selection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, { getSelectionLabel: 0, item: 1 }, add_css37);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Selection",
      options,
      id: create_fragment46.name
    });
  }
  get getSelectionLabel() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getSelectionLabel(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get item() {
    throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Selection_default = Selection;

// ../node_modules/svelte-select/src/MultiSelection.svelte
var file41 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-select/src/MultiSelection.svelte";
function add_css38(target) {
  append_styles(target, "svelte-m6f02k", ".multiSelectItem.svelte-m6f02k.svelte-m6f02k{background:var(--multiItemBG, #ebedef);margin:var(--multiItemMargin, 5px 5px 0 0);border-radius:var(--multiItemBorderRadius, 16px);height:var(--multiItemHeight, 32px);line-height:var(--multiItemHeight, 32px);display:flex;cursor:default;padding:var(--multiItemPadding, 0 10px 0 15px);max-width:100%}.multiSelectItem_label.svelte-m6f02k.svelte-m6f02k{margin:var(--multiLabelMargin, 0 5px 0 0);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multiSelectItem.svelte-m6f02k.svelte-m6f02k:hover,.multiSelectItem.active.svelte-m6f02k.svelte-m6f02k{background-color:var(--multiItemActiveBG, #006fff);color:var(--multiItemActiveColor, #fff)}.multiSelectItem.disabled.svelte-m6f02k.svelte-m6f02k:hover{background:var(--multiItemDisabledHoverBg, #ebedef);color:var(--multiItemDisabledHoverColor, #c1c6cc)}.multiSelectItem_clear.svelte-m6f02k.svelte-m6f02k{border-radius:var(--multiClearRadius, 50%);background:var(--multiClearBG, #52616f);min-width:var(--multiClearWidth, 16px);max-width:var(--multiClearWidth, 16px);height:var(--multiClearHeight, 16px);position:relative;top:var(--multiClearTop, 8px);text-align:var(--multiClearTextAlign, center);padding:var(--multiClearPadding, 1px)}.multiSelectItem_clear.svelte-m6f02k.svelte-m6f02k:hover,.active.svelte-m6f02k .multiSelectItem_clear.svelte-m6f02k{background:var(--multiClearHoverBG, #fff)}.multiSelectItem_clear.svelte-m6f02k:hover svg.svelte-m6f02k,.active.svelte-m6f02k .multiSelectItem_clear svg.svelte-m6f02k{fill:var(--multiClearHoverFill, #006fff)}.multiSelectItem_clear.svelte-m6f02k svg.svelte-m6f02k{fill:var(--multiClearFill, #ebedef);vertical-align:top}.svelte-m6f02k.svelte-m6f02k{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTXVsdGlTZWxlY3Rpb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtCSSxnQkFBZ0IsNEJBQUMsQ0FBQSxBQUNiLFVBQVUsQ0FBRSxJQUFJLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FDdkMsTUFBTSxDQUFFLElBQUksaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQzNDLGFBQWEsQ0FBRSxJQUFJLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxDQUNqRCxNQUFNLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FDcEMsV0FBVyxDQUFFLElBQUksaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQ3pDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLE9BQU8sQ0FDZixPQUFPLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsQ0FDL0MsU0FBUyxDQUFFLElBQUksQUFDbkIsQ0FBQSxBQUVBLHNCQUFzQiw0QkFBQyxDQUFBLEFBQ25CLE1BQU0sQ0FBRSxJQUFJLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUMxQyxRQUFRLENBQUUsTUFBTSxDQUNoQixhQUFhLENBQUUsUUFBUSxDQUN2QixXQUFXLENBQUUsTUFBTSxBQUN2QixDQUFBLEFBRUEsNENBQWdCLE1BQU0sQ0FDdEIsZ0JBQWdCLE9BQU8sNEJBQUMsQ0FBQSxBQUNwQixnQkFBZ0IsQ0FBRSxJQUFJLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUNuRCxLQUFLLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQUFDNUMsQ0FBQSxBQUVBLGdCQUFnQixxQ0FBUyxNQUFNLEFBQUMsQ0FBQSxBQUM1QixVQUFVLENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxRQUFRLENBQUMsQ0FDcEQsS0FBSyxDQUFFLElBQUksNkJBQTZCLENBQUMsUUFBUSxDQUFDLEFBQ3RELENBQUEsQUFFQSxzQkFBc0IsNEJBQUMsQ0FBQSxBQUNuQixhQUFhLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FDM0MsVUFBVSxDQUFFLElBQUksY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUN4QyxTQUFTLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FDdkMsU0FBUyxDQUFFLElBQUksaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQ3ZDLE1BQU0sQ0FBRSxJQUFJLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUNyQyxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLENBQzlCLFVBQVUsQ0FBRSxJQUFJLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUM5QyxPQUFPLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQUFDMUMsQ0FBQSxBQUVBLGtEQUFzQixNQUFNLENBQzVCLHFCQUFPLENBQUMsc0JBQXNCLGNBQUMsQ0FBQSxBQUMzQixVQUFVLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQUFDOUMsQ0FBQSxBQUVBLG9DQUFzQixNQUFNLENBQUMsaUJBQUcsQ0FDaEMscUJBQU8sQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLGNBQUMsQ0FBQSxBQUMvQixJQUFJLENBQUUsSUFBSSxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQUFDN0MsQ0FBQSxBQUVBLG9DQUFzQixDQUFDLEdBQUcsY0FBQyxDQUFBLEFBQ3ZCLElBQUksQ0FBRSxJQUFJLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUNwQyxjQUFjLENBQUUsR0FBRyxBQUN2QixDQUFBLDhCQUNKIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk11bHRpU2VsZWN0aW9uLnN2ZWx0ZSJdfQ== */");
}
function get_each_context14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[11] = i;
  return child_ctx;
}
function create_if_block24(ctx) {
  let div;
  let svg;
  let path;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[6](ctx[11], ...args);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        focusable: true,
        "aria-hidden": true,
        role: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, class: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
      attr_dev(path, "class", "svelte-m6f02k");
      add_location(path, file41, 97, 20, 3031);
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "viewBox", "-2 -2 50 50");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "role", "presentation");
      attr_dev(svg, "class", "svelte-m6f02k");
      add_location(svg, file41, 90, 16, 2779);
      attr_dev(div, "class", "multiSelectItem_clear svelte-m6f02k");
      add_location(div, file41, 87, 12, 2651);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = listen_dev(div, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(87:8) {#if !isDisabled && !multiFullItemClearable}",
    ctx
  });
  return block;
}
function create_each_block14(ctx) {
  let div1;
  let div0;
  let raw_value = ctx[4](ctx[9]) + "";
  let t0;
  let t1;
  let div1_class_value;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && !ctx[3] && create_if_block24(ctx);
  function click_handler_1(...args) {
    return ctx[7](ctx[11], ...args);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "multiSelectItem_label svelte-m6f02k");
      add_location(div0, file41, 83, 8, 2491);
      attr_dev(div1, "class", div1_class_value = "multiSelectItem " + (ctx[1] === ctx[11] ? "active" : "") + " " + (ctx[2] ? "disabled" : "") + " svelte-m6f02k");
      add_location(div1, file41, 77, 4, 2260);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      div0.innerHTML = raw_value;
      append_hydration_dev(div1, t0);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t1);
      if (!mounted) {
        dispose = listen_dev(div1, "click", click_handler_1, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 17 && raw_value !== (raw_value = ctx[4](ctx[9]) + ""))
        div0.innerHTML = raw_value;
      ;
      if (!ctx[2] && !ctx[3]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block24(ctx);
          if_block.c();
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (ctx[1] === ctx[11] ? "active" : "") + " " + (ctx[2] ? "disabled" : "") + " svelte-m6f02k")) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block14.name,
    type: "each",
    source: "(77:0) {#each value as item, i}",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let each_1_anchor;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block14(get_each_context14(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 63) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context14(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block14(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MultiSelection", slots, []);
  const dispatch = createEventDispatcher();
  let { value = [] } = $$props;
  let { activeValue = void 0 } = $$props;
  let { isDisabled = false } = $$props;
  let { multiFullItemClearable = false } = $$props;
  let { getSelectionLabel = void 0 } = $$props;
  function handleClear(i, event) {
    event.stopPropagation();
    dispatch("multiItemClear", { i });
  }
  const writable_props = [
    "value",
    "activeValue",
    "isDisabled",
    "multiFullItemClearable",
    "getSelectionLabel"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MultiSelection> was created with unknown prop '${key}'`);
  });
  const click_handler = (i, event) => handleClear(i, event);
  const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("activeValue" in $$props2)
      $$invalidate(1, activeValue = $$props2.activeValue);
    if ("isDisabled" in $$props2)
      $$invalidate(2, isDisabled = $$props2.isDisabled);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(3, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("getSelectionLabel" in $$props2)
      $$invalidate(4, getSelectionLabel = $$props2.getSelectionLabel);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    value,
    activeValue,
    isDisabled,
    multiFullItemClearable,
    getSelectionLabel,
    handleClear
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("activeValue" in $$props2)
      $$invalidate(1, activeValue = $$props2.activeValue);
    if ("isDisabled" in $$props2)
      $$invalidate(2, isDisabled = $$props2.isDisabled);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(3, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("getSelectionLabel" in $$props2)
      $$invalidate(4, getSelectionLabel = $$props2.getSelectionLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    activeValue,
    isDisabled,
    multiFullItemClearable,
    getSelectionLabel,
    handleClear,
    click_handler,
    click_handler_1
  ];
}
var MultiSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance47,
      create_fragment47,
      safe_not_equal,
      {
        value: 0,
        activeValue: 1,
        isDisabled: 2,
        multiFullItemClearable: 3,
        getSelectionLabel: 4
      },
      add_css38
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MultiSelection",
      options,
      id: create_fragment47.name
    });
  }
  get value() {
    throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeValue() {
    throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeValue(value) {
    throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isDisabled() {
    throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isDisabled(value) {
    throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiFullItemClearable() {
    throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiFullItemClearable(value) {
    throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectionLabel() {
    throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getSelectionLabel(value) {
    throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MultiSelection_default = MultiSelection;

// ../node_modules/svelte-select/src/VirtualList.svelte
var file42 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-select/src/VirtualList.svelte";
function add_css39(target) {
  append_styles(target, "svelte-6h3dqe", "svelte-virtual-list-viewport.svelte-6h3dqe{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-6h3dqe,svelte-virtual-list-row.svelte-6h3dqe{display:block}svelte-virtual-list-row.svelte-6h3dqe{overflow:hidden}.svelte-6h3dqe{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlydHVhbExpc3Quc3ZlbHRlIiwibWFwcGluZ3MiOiJBQThISSw0QkFBNEIsY0FBQyxDQUFBLEFBQ3pCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLDBCQUEwQixDQUFFLEtBQUssQ0FDakMsT0FBTyxDQUFFLEtBQUssQUFDbEIsQ0FBQSxBQUVBLDBDQUE0QixDQUM1Qix1QkFBdUIsY0FBQyxDQUFBLEFBQ3BCLE9BQU8sQ0FBRSxLQUFLLEFBQ2xCLENBQUEsQUFFQSx1QkFBdUIsY0FBQyxDQUFBLEFBQ3BCLFFBQVEsQ0FBRSxNQUFNLEFBQ3BCLENBQUEsZ0JBQ0oiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmlydHVhbExpc3Quc3ZlbHRlIl19 */");
}
function get_each_context15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({
  item: dirty & 32,
  i: dirty & 32,
  hoverItemIndex: dirty & 2
});
var get_default_slot_context = (ctx) => ({
  item: ctx[23].data,
  i: ctx[23].index,
  hoverItemIndex: ctx[1]
});
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Missing template");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Missing template");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(154:69) Missing template",
    ctx
  });
  return block;
}
function create_each_block15(key_1, ctx) {
  let svelte_virtual_list_row;
  let t;
  let current;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], get_default_slot_context);
  const default_slot_or_fallback = default_slot || fallback_block2(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      svelte_virtual_list_row = element("svelte-virtual-list-row");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      svelte_virtual_list_row = claim_element(nodes, "SVELTE-VIRTUAL-LIST-ROW", { class: true });
      var svelte_virtual_list_row_nodes = children(svelte_virtual_list_row);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(svelte_virtual_list_row_nodes);
      t = claim_space(svelte_virtual_list_row_nodes);
      svelte_virtual_list_row_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_custom_element_data(svelte_virtual_list_row, "class", "svelte-6h3dqe");
      add_location(svelte_virtual_list_row, file42, 152, 12, 3782);
      this.first = svelte_virtual_list_row;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_virtual_list_row, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(svelte_virtual_list_row, null);
      }
      append_hydration_dev(svelte_virtual_list_row, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16418)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[14],
            !current ? get_all_dirty_from_scope(ctx[14]) : get_slot_changes(default_slot_template, ctx[14], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(svelte_virtual_list_row);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block15.name,
    type: "each",
    source: "(152:8) {#each visible as row (row.index)}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let svelte_virtual_list_viewport;
  let svelte_virtual_list_contents;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let svelte_virtual_list_viewport_resize_listener;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[5];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[23].index;
  validate_each_keys(ctx, each_value, get_each_context15, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context15(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block15(key, child_ctx));
  }
  const block = {
    c: function create() {
      svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
      svelte_virtual_list_contents = element("svelte-virtual-list-contents");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      svelte_virtual_list_viewport = claim_element(nodes, "SVELTE-VIRTUAL-LIST-VIEWPORT", { style: true, class: true });
      var svelte_virtual_list_viewport_nodes = children(svelte_virtual_list_viewport);
      svelte_virtual_list_contents = claim_element(svelte_virtual_list_viewport_nodes, "SVELTE-VIRTUAL-LIST-CONTENTS", { style: true, class: true });
      var svelte_virtual_list_contents_nodes = children(svelte_virtual_list_contents);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svelte_virtual_list_contents_nodes);
      }
      svelte_virtual_list_contents_nodes.forEach(detach_dev);
      svelte_virtual_list_viewport_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(svelte_virtual_list_contents, "padding-top", ctx[6] + "px");
      set_style(svelte_virtual_list_contents, "padding-bottom", ctx[7] + "px");
      set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-6h3dqe");
      add_location(svelte_virtual_list_contents, file42, 148, 4, 3601);
      set_style(svelte_virtual_list_viewport, "height", ctx[0]);
      set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-6h3dqe");
      add_render_callback(() => ctx[18].call(svelte_virtual_list_viewport));
      add_location(svelte_virtual_list_viewport, file42, 143, 0, 3441);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_virtual_list_viewport, anchor);
      append_hydration_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(svelte_virtual_list_contents, null);
      }
      ctx[16](svelte_virtual_list_contents);
      ctx[17](svelte_virtual_list_viewport);
      svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, ctx[18].bind(svelte_virtual_list_viewport));
      current = true;
      if (!mounted) {
        dispose = listen_dev(svelte_virtual_list_viewport, "scroll", ctx[8], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 16418) {
        each_value = ctx2[5];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context15, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block15, null, get_each_context15);
        check_outros();
      }
      if (!current || dirty & 64) {
        set_style(svelte_virtual_list_contents, "padding-top", ctx2[6] + "px");
      }
      if (!current || dirty & 128) {
        set_style(svelte_virtual_list_contents, "padding-bottom", ctx2[7] + "px");
      }
      if (!current || dirty & 1) {
        set_style(svelte_virtual_list_viewport, "height", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(svelte_virtual_list_viewport);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[16](null);
      ctx[17](null);
      svelte_virtual_list_viewport_resize_listener();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VirtualList", slots, ["default"]);
  let { items = void 0 } = $$props;
  let { height = "100%" } = $$props;
  let { itemHeight = 40 } = $$props;
  let { hoverItemIndex = 0 } = $$props;
  let { start = 0 } = $$props;
  let { end = 0 } = $$props;
  let height_map = [];
  let rows;
  let viewport;
  let contents;
  let viewport_height = 0;
  let visible;
  let mounted;
  let top = 0;
  let bottom = 0;
  let average_height;
  async function refresh(items2, viewport_height2, itemHeight2) {
    const { scrollTop } = viewport;
    await tick();
    let content_height = top - scrollTop;
    let i = start;
    while (content_height < viewport_height2 && i < items2.length) {
      let row = rows[i - start];
      if (!row) {
        $$invalidate(10, end = i + 1);
        await tick();
        row = rows[i - start];
      }
      const row_height = height_map[i] = itemHeight2 || row.offsetHeight;
      content_height += row_height;
      i += 1;
    }
    $$invalidate(10, end = i);
    const remaining = items2.length - end;
    average_height = (top + content_height) / end;
    $$invalidate(7, bottom = remaining * average_height);
    height_map.length = items2.length;
    if (viewport)
      $$invalidate(3, viewport.scrollTop = 0, viewport);
  }
  async function handle_scroll() {
    const { scrollTop } = viewport;
    const old_start = start;
    for (let v = 0; v < rows.length; v += 1) {
      height_map[start + v] = itemHeight || rows[v].offsetHeight;
    }
    let i = 0;
    let y = 0;
    while (i < items.length) {
      const row_height = height_map[i] || average_height;
      if (y + row_height > scrollTop) {
        $$invalidate(9, start = i);
        $$invalidate(6, top = y);
        break;
      }
      y += row_height;
      i += 1;
    }
    while (i < items.length) {
      y += height_map[i] || average_height;
      i += 1;
      if (y > scrollTop + viewport_height)
        break;
    }
    $$invalidate(10, end = i);
    const remaining = items.length - end;
    average_height = y / end;
    while (i < items.length)
      height_map[i++] = average_height;
    $$invalidate(7, bottom = remaining * average_height);
    if (start < old_start) {
      await tick();
      let expected_height = 0;
      let actual_height = 0;
      for (let i2 = start; i2 < old_start; i2 += 1) {
        if (rows[i2 - start]) {
          expected_height += height_map[i2];
          actual_height += itemHeight || rows[i2 - start].offsetHeight;
        }
      }
      const d = actual_height - expected_height;
      viewport.scrollTo(0, scrollTop + d);
    }
  }
  onMount(() => {
    rows = contents.getElementsByTagName("svelte-virtual-list-row");
    $$invalidate(13, mounted = true);
  });
  const writable_props = ["items", "height", "itemHeight", "hoverItemIndex", "start", "end"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VirtualList> was created with unknown prop '${key}'`);
  });
  function svelte_virtual_list_contents_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contents = $$value;
      $$invalidate(4, contents);
    });
  }
  function svelte_virtual_list_viewport_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewport = $$value;
      $$invalidate(3, viewport);
    });
  }
  function svelte_virtual_list_viewport_elementresize_handler() {
    viewport_height = this.offsetHeight;
    $$invalidate(2, viewport_height);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(11, items = $$props2.items);
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("itemHeight" in $$props2)
      $$invalidate(12, itemHeight = $$props2.itemHeight);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(1, hoverItemIndex = $$props2.hoverItemIndex);
    if ("start" in $$props2)
      $$invalidate(9, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(10, end = $$props2.end);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    tick,
    items,
    height,
    itemHeight,
    hoverItemIndex,
    start,
    end,
    height_map,
    rows,
    viewport,
    contents,
    viewport_height,
    visible,
    mounted,
    top,
    bottom,
    average_height,
    refresh,
    handle_scroll
  });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(11, items = $$props2.items);
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("itemHeight" in $$props2)
      $$invalidate(12, itemHeight = $$props2.itemHeight);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(1, hoverItemIndex = $$props2.hoverItemIndex);
    if ("start" in $$props2)
      $$invalidate(9, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(10, end = $$props2.end);
    if ("height_map" in $$props2)
      height_map = $$props2.height_map;
    if ("rows" in $$props2)
      rows = $$props2.rows;
    if ("viewport" in $$props2)
      $$invalidate(3, viewport = $$props2.viewport);
    if ("contents" in $$props2)
      $$invalidate(4, contents = $$props2.contents);
    if ("viewport_height" in $$props2)
      $$invalidate(2, viewport_height = $$props2.viewport_height);
    if ("visible" in $$props2)
      $$invalidate(5, visible = $$props2.visible);
    if ("mounted" in $$props2)
      $$invalidate(13, mounted = $$props2.mounted);
    if ("top" in $$props2)
      $$invalidate(6, top = $$props2.top);
    if ("bottom" in $$props2)
      $$invalidate(7, bottom = $$props2.bottom);
    if ("average_height" in $$props2)
      average_height = $$props2.average_height;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3584) {
      $:
        $$invalidate(5, visible = items.slice(start, end).map((data, i) => {
          return { index: i + start, data };
        }));
    }
    if ($$self.$$.dirty & 14340) {
      $:
        if (mounted)
          refresh(items, viewport_height, itemHeight);
    }
  };
  return [
    height,
    hoverItemIndex,
    viewport_height,
    viewport,
    contents,
    visible,
    top,
    bottom,
    handle_scroll,
    start,
    end,
    items,
    itemHeight,
    mounted,
    $$scope,
    slots,
    svelte_virtual_list_contents_binding,
    svelte_virtual_list_viewport_binding,
    svelte_virtual_list_viewport_elementresize_handler
  ];
}
var VirtualList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        items: 11,
        height: 0,
        itemHeight: 12,
        hoverItemIndex: 1,
        start: 9,
        end: 10
      },
      add_css39
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VirtualList",
      options,
      id: create_fragment48.name
    });
  }
  get items() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemHeight() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemHeight(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hoverItemIndex() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hoverItemIndex(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VirtualList_default = VirtualList;

// ../node_modules/svelte-select/src/ClearIcon.svelte
var file43 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-select/src/ClearIcon.svelte";
function create_fragment49(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        focusable: true,
        "aria-hidden": true,
        role: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
      add_location(path, file43, 8, 4, 141);
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "viewBox", "-2 -2 50 50");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "role", "presentation");
      add_location(svg, file43, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClearIcon", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
  });
  return [];
}
var ClearIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClearIcon",
      options,
      id: create_fragment49.name
    });
  }
};
var ClearIcon_default = ClearIcon;

// ../node_modules/svelte-select/src/utils/debounce.js
function debounce(func, wait, immediate) {
  let timeout;
  return function executedFunction() {
    let context = this;
    let args = arguments;
    let later = function() {
      timeout = null;
      if (!immediate)
        func.apply(context, args);
    };
    let callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func.apply(context, args);
  };
}

// ../node_modules/svelte-select/src/Select.svelte
var { Object: Object_16, console: console_13 } = globals;
var file44 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-select/src/Select.svelte";
function add_css40(target) {
  append_styles(target, "svelte-17fnnnn", ".selectContainer.svelte-17fnnnn.svelte-17fnnnn{--internalPadding:0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--borderRadius, 3px);box-sizing:border-box;height:var(--height, 42px);position:relative;display:flex;align-items:center;padding:var(--padding, var(--internalPadding));background:var(--background, #fff);margin:var(--margin, 0)}.selectContainer.svelte-17fnnnn input.svelte-17fnnnn{cursor:default;border:none;color:var(--inputColor, #3f4f5f);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--inputPadding, var(--padding, var(--internalPadding)));width:100%;background:transparent;font-size:var(--inputFontSize, 14px);letter-spacing:var(--inputLetterSpacing, -0.08px);position:absolute;left:var(--inputLeft, 0);margin:var(--inputMargin, 0)}.selectContainer.svelte-17fnnnn input.svelte-17fnnnn::placeholder{color:var(--placeholderColor, #78848f);opacity:var(--placeholderOpacity, 1)}.selectContainer.svelte-17fnnnn input.svelte-17fnnnn:focus{outline:none}.selectContainer.svelte-17fnnnn.svelte-17fnnnn:hover{border-color:var(--borderHoverColor, #b2b8bf)}.selectContainer.focused.svelte-17fnnnn.svelte-17fnnnn{border-color:var(--borderFocusColor, #006fe8)}.selectContainer.disabled.svelte-17fnnnn.svelte-17fnnnn{background:var(--disabledBackground, #ebedef);border-color:var(--disabledBorderColor, #ebedef);color:var(--disabledColor, #c1c6cc)}.selectContainer.disabled.svelte-17fnnnn input.svelte-17fnnnn::placeholder{color:var(--disabledPlaceholderColor, #c1c6cc);opacity:var(--disabledPlaceholderOpacity, 1)}.selectedItem.svelte-17fnnnn.svelte-17fnnnn{line-height:var(--height, 42px);height:var(--height, 42px);overflow-x:hidden;padding:var(--selectedItemPadding, 0 20px 0 0)}.selectedItem.svelte-17fnnnn.svelte-17fnnnn:focus{outline:none}.clearSelect.svelte-17fnnnn.svelte-17fnnnn{position:absolute;right:var(--clearSelectRight, 10px);top:var(--clearSelectTop, 11px);bottom:var(--clearSelectBottom, 11px);width:var(--clearSelectWidth, 20px);color:var(--clearSelectColor, #c5cacf);flex:none !important}.clearSelect.svelte-17fnnnn.svelte-17fnnnn:hover{color:var(--clearSelectHoverColor, #2c3e50)}.selectContainer.focused.svelte-17fnnnn .clearSelect.svelte-17fnnnn{color:var(--clearSelectFocusColor, #3f4f5f)}.indicator.svelte-17fnnnn.svelte-17fnnnn{position:absolute;right:var(--indicatorRight, 10px);top:var(--indicatorTop, 11px);width:var(--indicatorWidth, 20px);height:var(--indicatorHeight, 20px);color:var(--indicatorColor, #c5cacf)}.indicator.svelte-17fnnnn svg.svelte-17fnnnn{display:inline-block;fill:var(--indicatorFill, currentcolor);line-height:1;stroke:var(--indicatorStroke, currentcolor);stroke-width:0}.spinner.svelte-17fnnnn.svelte-17fnnnn{position:absolute;right:var(--spinnerRight, 10px);top:var(--spinnerLeft, 11px);width:var(--spinnerWidth, 20px);height:var(--spinnerHeight, 20px);color:var(--spinnerColor, #51ce6c);animation:svelte-17fnnnn-rotate 0.75s linear infinite}.spinner_icon.svelte-17fnnnn.svelte-17fnnnn{display:block;height:100%;transform-origin:center center;width:100%;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;-webkit-transform:none}.spinner_path.svelte-17fnnnn.svelte-17fnnnn{stroke-dasharray:90;stroke-linecap:round}.multiSelect.svelte-17fnnnn.svelte-17fnnnn{display:flex;padding:var(--multiSelectPadding, 0 35px 0 16px);height:auto;flex-wrap:wrap;align-items:stretch}.multiSelect.svelte-17fnnnn>.svelte-17fnnnn{flex:1 1 50px}.selectContainer.multiSelect.svelte-17fnnnn input.svelte-17fnnnn{padding:var(--multiSelectInputPadding, 0);position:relative;margin:var(--multiSelectInputMargin, 0)}.hasError.svelte-17fnnnn.svelte-17fnnnn{border:var(--errorBorder, 1px solid #ff2d55);background:var(--errorBackground, #fff)}.a11yText.svelte-17fnnnn.svelte-17fnnnn{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}@keyframes svelte-17fnnnn-rotate{100%{transform:rotate(360deg)}}.svelte-17fnnnn.svelte-17fnnnn{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5cUJJLGdCQUFnQiw4QkFBQyxDQUFBLEFBQ2IsaUJBQWlCLENBQUUsTUFBTSxDQUN6QixNQUFNLENBQUUsSUFBSSxRQUFRLENBQUMsa0JBQWtCLENBQUMsQ0FDeEMsYUFBYSxDQUFFLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxDQUN2QyxVQUFVLENBQUUsVUFBVSxDQUN0QixNQUFNLENBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQzNCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsT0FBTyxDQUFFLElBQUksU0FBUyxDQUFDLHVCQUF1QixDQUFDLENBQy9DLFVBQVUsQ0FBRSxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FDbkMsTUFBTSxDQUFFLElBQUksUUFBUSxDQUFDLEVBQUUsQ0FBQyxBQUM1QixDQUFBLEFBRUEsK0JBQWdCLENBQUMsS0FBSyxlQUFDLENBQUEsQUFDbkIsTUFBTSxDQUFFLE9BQU8sQ0FDZixNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FDakMsTUFBTSxDQUFFLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUMzQixXQUFXLENBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQ2hDLE9BQU8sQ0FBRSxJQUFJLGNBQWMsQ0FBQyx1Q0FBdUMsQ0FBQyxDQUNwRSxLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxXQUFXLENBQ3ZCLFNBQVMsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FDckMsY0FBYyxDQUFFLElBQUksb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQ2xELFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxJQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FDekIsTUFBTSxDQUFFLElBQUksYUFBYSxDQUFDLEVBQUUsQ0FBQyxBQUNqQyxDQUFBLEFBRUEsK0JBQWdCLENBQUMsb0JBQUssYUFBYSxBQUFDLENBQUEsQUFDaEMsS0FBSyxDQUFFLElBQUksa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQ3ZDLE9BQU8sQ0FBRSxJQUFJLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxBQUN6QyxDQUFBLEFBRUEsK0JBQWdCLENBQUMsb0JBQUssTUFBTSxBQUFDLENBQUEsQUFDekIsT0FBTyxDQUFFLElBQUksQUFDakIsQ0FBQSxBQUVBLDhDQUFnQixNQUFNLEFBQUMsQ0FBQSxBQUNuQixZQUFZLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQUFDbEQsQ0FBQSxBQUVBLGdCQUFnQixRQUFRLDhCQUFDLENBQUEsQUFDckIsWUFBWSxDQUFFLElBQUksa0JBQWtCLENBQUMsUUFBUSxDQUFDLEFBQ2xELENBQUEsQUFFQSxnQkFBZ0IsU0FBUyw4QkFBQyxDQUFBLEFBQ3RCLFVBQVUsQ0FBRSxJQUFJLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUM5QyxZQUFZLENBQUUsSUFBSSxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQ0FDakQsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLFFBQVEsQ0FBQyxBQUN4QyxDQUFBLEFBRUEsZ0JBQWdCLHdCQUFTLENBQUMsb0JBQUssYUFBYSxBQUFDLENBQUEsQUFDekMsS0FBSyxDQUFFLElBQUksMEJBQTBCLENBQUMsUUFBUSxDQUFDLENBQy9DLE9BQU8sQ0FBRSxJQUFJLDRCQUE0QixDQUFDLEVBQUUsQ0FBQyxBQUNqRCxDQUFBLEFBRUEsYUFBYSw4QkFBQyxDQUFBLEFBQ1YsV0FBVyxDQUFFLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUNoQyxNQUFNLENBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQzNCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxBQUNuRCxDQUFBLEFBRUEsMkNBQWEsTUFBTSxBQUFDLENBQUEsQUFDaEIsT0FBTyxDQUFFLElBQUksQUFDakIsQ0FBQSxBQUVBLFlBQVksOEJBQUMsQ0FBQSxBQUNULFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUNwQyxHQUFHLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FDaEMsTUFBTSxDQUFFLElBQUksbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQ3RDLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUNwQyxLQUFLLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FDdkMsSUFBSSxDQUFFLElBQUksQ0FBQyxVQUFVLEFBQ3pCLENBQUEsQUFFQSwwQ0FBWSxNQUFNLEFBQUMsQ0FBQSxBQUNmLEtBQUssQ0FBRSxJQUFJLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxBQUNoRCxDQUFBLEFBRUEsZ0JBQWdCLHVCQUFRLENBQUMsWUFBWSxlQUFDLENBQUEsQUFDbEMsS0FBSyxDQUFFLElBQUksdUJBQXVCLENBQUMsUUFBUSxDQUFDLEFBQ2hELENBQUEsQUFFQSxVQUFVLDhCQUFDLENBQUEsQUFDUCxRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FDbEMsR0FBRyxDQUFFLElBQUksY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUM5QixLQUFLLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FDbEMsTUFBTSxDQUFFLElBQUksaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQ3BDLEtBQUssQ0FBRSxJQUFJLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxBQUN6QyxDQUFBLEFBRUEseUJBQVUsQ0FBQyxHQUFHLGVBQUMsQ0FBQSxBQUNYLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLElBQUksQ0FBRSxJQUFJLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FDeEMsV0FBVyxDQUFFLENBQUMsQ0FDZCxNQUFNLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FDNUMsWUFBWSxDQUFFLENBQUMsQUFDbkIsQ0FBQSxBQUVBLFFBQVEsOEJBQUMsQ0FBQSxBQUNMLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FDaEMsR0FBRyxDQUFFLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUM3QixLQUFLLENBQUUsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQ2hDLE1BQU0sQ0FBRSxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FDbEMsS0FBSyxDQUFFLElBQUksY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUNuQyxTQUFTLENBQUUscUJBQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQUFDM0MsQ0FBQSxBQUVBLGFBQWEsOEJBQUMsQ0FBQSxBQUNWLE9BQU8sQ0FBRSxLQUFLLENBQ2QsTUFBTSxDQUFFLElBQUksQ0FDWixnQkFBZ0IsQ0FBRSxNQUFNLENBQUMsTUFBTSxDQUMvQixLQUFLLENBQUUsSUFBSSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLElBQUksQ0FDWixpQkFBaUIsQ0FBRSxJQUFJLEFBQzNCLENBQUEsQUFFQSxhQUFhLDhCQUFDLENBQUEsQUFDVixnQkFBZ0IsQ0FBRSxFQUFFLENBQ3BCLGNBQWMsQ0FBRSxLQUFLLEFBQ3pCLENBQUEsQUFFQSxZQUFZLDhCQUFDLENBQUEsQUFDVCxPQUFPLENBQUUsSUFBSSxDQUNiLE9BQU8sQ0FBRSxJQUFJLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxDQUNqRCxNQUFNLENBQUUsSUFBSSxDQUNaLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLE9BQU8sQUFDeEIsQ0FBQSxBQUVBLDJCQUFZLENBQUcsZUFBRSxDQUFBLEFBQ2IsSUFBSSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxBQUNsQixDQUFBLEFBRUEsZ0JBQWdCLDJCQUFZLENBQUMsS0FBSyxlQUFDLENBQUEsQUFDL0IsT0FBTyxDQUFFLElBQUkseUJBQXlCLENBQUMsRUFBRSxDQUFDLENBQzFDLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLHdCQUF3QixDQUFDLEVBQUUsQ0FBQyxBQUM1QyxDQUFBLEFBRUEsU0FBUyw4QkFBQyxDQUFBLEFBQ04sTUFBTSxDQUFFLElBQUksYUFBYSxDQUFDLGtCQUFrQixDQUFDLENBQzdDLFVBQVUsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxBQUM1QyxDQUFBLEFBRUEsU0FBUyw4QkFBQyxDQUFBLEFBQ04sT0FBTyxDQUFFLElBQUksQ0FDYixNQUFNLENBQUUsR0FBRyxDQUNYLElBQUksQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUM5QixNQUFNLENBQUUsR0FBRyxDQUNYLEtBQUssQ0FBRSxHQUFHLENBQ1YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLEdBQUcsQ0FDWixXQUFXLENBQUUsTUFBTSxBQUN2QixDQUFBLEFBRUEsV0FBVyxxQkFBTyxDQUFBLEFBQ2QsSUFBSSxBQUFDLENBQUEsQUFDRCxTQUFTLENBQUUsT0FBTyxNQUFNLENBQUMsQUFDN0IsQ0FBQSxBQUNKLENBQUEsZ0NBQ0oiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VsZWN0LnN2ZWx0ZSJdfQ== */");
}
function get_each_context16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[103] = list[i];
  return child_ctx;
}
function create_if_block_102(ctx) {
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(ctx[33]);
      t1 = space();
      span1 = element("span");
      t2 = text(ctx[32]);
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { id: true, class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, ctx[33]);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { id: true, class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, ctx[32]);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "id", "aria-selection");
      attr_dev(span0, "class", "svelte-17fnnnn");
      add_location(span0, file44, 876, 12, 23846);
      attr_dev(span1, "id", "aria-context");
      attr_dev(span1, "class", "svelte-17fnnnn");
      add_location(span1, file44, 877, 12, 23907);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & 4)
        set_data_dev(t0, ctx2[33]);
      if (dirty[1] & 2)
        set_data_dev(t2, ctx2[32]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(span0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_102.name,
    type: "if",
    source: "(876:8) {#if isFocused}",
    ctx
  });
  return block;
}
function create_if_block_92(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[18]];
  var switch_value = ctx[17];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & 262144 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[18])]) : {};
      if (switch_value !== (switch_value = ctx2[17])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_92.name,
    type: "if",
    source: "(884:4) {#if Icon}",
    ctx
  });
  return block;
}
function create_if_block_82(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[26];
  function switch_props(ctx2) {
    return {
      props: {
        value: ctx2[2],
        getSelectionLabel: ctx2[12],
        activeValue: ctx2[30],
        isDisabled: ctx2[9],
        multiFullItemClearable: ctx2[8]
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on("multiItemClear", ctx[38]);
    switch_instance.$on("focus", ctx[40]);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 4)
        switch_instance_changes.value = ctx2[2];
      if (dirty[0] & 4096)
        switch_instance_changes.getSelectionLabel = ctx2[12];
      if (dirty[0] & 1073741824)
        switch_instance_changes.activeValue = ctx2[30];
      if (dirty[0] & 512)
        switch_instance_changes.isDisabled = ctx2[9];
      if (dirty[0] & 256)
        switch_instance_changes.multiFullItemClearable = ctx2[8];
      if (switch_value !== (switch_value = ctx2[26])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          switch_instance.$on("multiItemClear", ctx2[38]);
          switch_instance.$on("focus", ctx2[40]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(888:4) {#if showMultiSelect}",
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[25];
  function switch_props(ctx2) {
    return {
      props: {
        item: ctx2[2],
        getSelectionLabel: ctx2[12]
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "selectedItem svelte-17fnnnn");
      add_location(div, file44, 910, 8, 24729);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "focus", ctx[40], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 4)
        switch_instance_changes.item = ctx2[2];
      if (dirty[0] & 4096)
        switch_instance_changes.getSelectionLabel = ctx2[12];
      if (switch_value !== (switch_value = ctx2[25])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(910:4) {#if !isMulti && showSelectedItem}",
    ctx
  });
  return block;
}
function create_if_block_63(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[23];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "clearSelect svelte-17fnnnn");
      attr_dev(div, "aria-hidden", "true");
      add_location(div, file44, 919, 8, 24968);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", prevent_default(ctx[27]), false, true, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[23])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_63.name,
    type: "if",
    source: "(919:4) {#if showClearIcon}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[22])
      return create_if_block_54;
    return create_else_block14;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "indicator svelte-17fnnnn");
      attr_dev(div, "aria-hidden", "true");
      add_location(div, file44, 928, 8, 25351);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_block.m(div, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(928:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}",
    ctx
  });
  return block;
}
function create_else_block14(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        focusable: true,
        "aria-hidden": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, class: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
      attr_dev(path, "class", "svelte-17fnnnn");
      add_location(path, file44, 938, 20, 25708);
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "class", "svelte-17fnnnn");
      add_location(svg, file44, 932, 16, 25498);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(932:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_54(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(ctx[22], target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4194304)
        html_tag.p(ctx2[22]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(930:12) {#if indicatorSvg}",
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let div;
  let svg;
  let circle;
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", { class: true, viewBox: true });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", {
        class: true,
        cx: true,
        cy: true,
        r: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-miterlimit": true
      });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "class", "spinner_path svelte-17fnnnn");
      attr_dev(circle, "cx", "50");
      attr_dev(circle, "cy", "50");
      attr_dev(circle, "r", "20");
      attr_dev(circle, "fill", "none");
      attr_dev(circle, "stroke", "currentColor");
      attr_dev(circle, "stroke-width", "5");
      attr_dev(circle, "stroke-miterlimit", "10");
      add_location(circle, file44, 952, 16, 26257);
      attr_dev(svg, "class", "spinner_icon svelte-17fnnnn");
      attr_dev(svg, "viewBox", "25 25 50 50");
      add_location(svg, file44, 951, 12, 26192);
      attr_dev(div, "class", "spinner svelte-17fnnnn");
      add_location(div, file44, 950, 8, 26158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      append_hydration_dev(svg, circle);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(950:4) {#if isWaiting}",
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let switch_instance;
  let updating_hoverItemIndex;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[34]];
  function switch_instance_hoverItemIndex_binding(value) {
    ctx[84](value);
  }
  var switch_value = ctx[24];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (ctx2[28] !== void 0) {
      switch_instance_props.hoverItemIndex = ctx2[28];
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "hoverItemIndex", switch_instance_hoverItemIndex_binding));
    switch_instance.$on("itemSelected", ctx[43]);
    switch_instance.$on("itemCreated", ctx[44]);
    switch_instance.$on("closeList", ctx[45]);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[1] & 8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[34])]) : {};
      if (!updating_hoverItemIndex && dirty[0] & 268435456) {
        updating_hoverItemIndex = true;
        switch_instance_changes.hoverItemIndex = ctx2[28];
        add_flush_callback(() => updating_hoverItemIndex = false);
      }
      if (switch_value !== (switch_value = ctx2[24])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "hoverItemIndex", switch_instance_hoverItemIndex_binding));
          switch_instance.$on("itemSelected", ctx2[43]);
          switch_instance.$on("itemCreated", ctx2[44]);
          switch_instance.$on("closeList", ctx2[45]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(966:4) {#if listOpen}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let input_1;
  let input_1_name_value;
  let input_1_value_value;
  const block = {
    c: function create() {
      input_1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input_1 = claim_element(nodes, "INPUT", { name: true, type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input_1, "name", input_1_name_value = ctx[16].name);
      attr_dev(input_1, "type", "hidden");
      input_1.value = input_1_value_value = ctx[2] ? ctx[12](ctx[2]) : null;
      attr_dev(input_1, "class", "svelte-17fnnnn");
      add_location(input_1, file44, 976, 8, 26914);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 65536 && input_1_name_value !== (input_1_name_value = ctx2[16].name)) {
        attr_dev(input_1, "name", input_1_name_value);
      }
      if (dirty[0] & 4100 && input_1_value_value !== (input_1_value_value = ctx2[2] ? ctx2[12](ctx2[2]) : null)) {
        prop_dev(input_1, "value", input_1_value_value);
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(input_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(976:4) {#if !isMulti || (isMulti && !showMultiSelect)}",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let each_1_anchor;
  let each_value = ctx[2];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block16(get_each_context16(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 69636) {
        each_value = ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context16(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block16(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy2(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(983:4) {#if isMulti && showMultiSelect}",
    ctx
  });
  return block;
}
function create_each_block16(ctx) {
  let input_1;
  let input_1_name_value;
  let input_1_value_value;
  const block = {
    c: function create() {
      input_1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input_1 = claim_element(nodes, "INPUT", { name: true, type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input_1, "name", input_1_name_value = ctx[16].name);
      attr_dev(input_1, "type", "hidden");
      input_1.value = input_1_value_value = ctx[103] ? ctx[12](ctx[103]) : null;
      attr_dev(input_1, "class", "svelte-17fnnnn");
      add_location(input_1, file44, 984, 12, 27140);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 65536 && input_1_name_value !== (input_1_name_value = ctx2[16].name)) {
        attr_dev(input_1, "name", input_1_name_value);
      }
      if (dirty[0] & 4100 && input_1_value_value !== (input_1_value_value = ctx2[103] ? ctx2[12](ctx2[103]) : null)) {
        prop_dev(input_1, "value", input_1_value_value);
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(input_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block16.name,
    type: "each",
    source: "(984:8) {#each value as item}",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let t2;
  let input_1;
  let input_1_readonly_value;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1] && create_if_block_102(ctx);
  let if_block1 = ctx[17] && create_if_block_92(ctx);
  let if_block2 = ctx[35] && create_if_block_82(ctx);
  let input_1_levels = [
    {
      readOnly: input_1_readonly_value = !ctx[13]
    },
    ctx[31],
    { placeholder: ctx[36] },
    { style: ctx[14] },
    { disabled: ctx[9] }
  ];
  let input_1_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_1_data = assign(input_1_data, input_1_levels[i]);
  }
  let if_block3 = !ctx[7] && ctx[29] && create_if_block_72(ctx);
  let if_block4 = ctx[37] && create_if_block_63(ctx);
  let if_block5 = !ctx[37] && (ctx[20] || ctx[19] && !ctx[2] || !ctx[13] && !ctx[9] && !ctx[4] && (ctx[29] && !ctx[15] || !ctx[29])) && create_if_block_44(ctx);
  let if_block6 = ctx[4] && create_if_block_38(ctx);
  let if_block7 = ctx[5] && create_if_block_212(ctx);
  let if_block8 = (!ctx[7] || ctx[7] && !ctx[35]) && create_if_block_115(ctx);
  let if_block9 = ctx[7] && ctx[35] && create_if_block25(ctx);
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      input_1 = element("input");
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      t9 = space();
      if (if_block9)
        if_block9.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", {
        "aria-live": true,
        "aria-atomic": true,
        "aria-relevant": true,
        class: true
      });
      var span_nodes = children(span);
      if (if_block0)
        if_block0.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t2 = claim_space(div_nodes);
      input_1 = claim_element(div_nodes, "INPUT", { placeholder: true, style: true });
      t3 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      t4 = claim_space(div_nodes);
      if (if_block4)
        if_block4.l(div_nodes);
      t5 = claim_space(div_nodes);
      if (if_block5)
        if_block5.l(div_nodes);
      t6 = claim_space(div_nodes);
      if (if_block6)
        if_block6.l(div_nodes);
      t7 = claim_space(div_nodes);
      if (if_block7)
        if_block7.l(div_nodes);
      t8 = claim_space(div_nodes);
      if (if_block8)
        if_block8.l(div_nodes);
      t9 = claim_space(div_nodes);
      if (if_block9)
        if_block9.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "aria-live", "polite");
      attr_dev(span, "aria-atomic", "false");
      attr_dev(span, "aria-relevant", "additions text");
      attr_dev(span, "class", "a11yText svelte-17fnnnn");
      add_location(span, file44, 870, 4, 23684);
      set_attributes(input_1, input_1_data);
      toggle_class(input_1, "svelte-17fnnnn", true);
      add_location(input_1, file44, 899, 4, 24423);
      attr_dev(div, "class", div_class_value = "selectContainer " + ctx[21] + " svelte-17fnnnn");
      attr_dev(div, "style", ctx[11]);
      toggle_class(div, "hasError", ctx[10]);
      toggle_class(div, "multiSelect", ctx[7]);
      toggle_class(div, "disabled", ctx[9]);
      toggle_class(div, "focused", ctx[1]);
      add_location(div, file44, 861, 0, 23433);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      if (if_block0)
        if_block0.m(span, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration_dev(div, t2);
      append_hydration_dev(div, input_1);
      if (input_1.autofocus)
        input_1.focus();
      ctx[82](input_1);
      set_input_value(input_1, ctx[3]);
      append_hydration_dev(div, t3);
      if (if_block3)
        if_block3.m(div, null);
      append_hydration_dev(div, t4);
      if (if_block4)
        if_block4.m(div, null);
      append_hydration_dev(div, t5);
      if (if_block5)
        if_block5.m(div, null);
      append_hydration_dev(div, t6);
      if (if_block6)
        if_block6.m(div, null);
      append_hydration_dev(div, t7);
      if (if_block7)
        if_block7.m(div, null);
      append_hydration_dev(div, t8);
      if (if_block8)
        if_block8.m(div, null);
      append_hydration_dev(div, t9);
      if (if_block9)
        if_block9.m(div, null);
      ctx[85](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "click", ctx[41], false, false, false),
          listen_dev(window, "focusin", ctx[41], false, false, false),
          listen_dev(window, "keydown", ctx[39], false, false, false),
          listen_dev(input_1, "focus", ctx[40], false, false, false),
          listen_dev(input_1, "input", ctx[83]),
          listen_dev(div, "click", ctx[42], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_102(ctx2);
          if_block0.c();
          if_block0.m(span, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[17]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_92(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[35]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_82(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
        (!current || dirty[0] & 8192 && input_1_readonly_value !== (input_1_readonly_value = !ctx2[13])) && { readOnly: input_1_readonly_value },
        dirty[1] & 1 && ctx2[31],
        (!current || dirty[1] & 32) && { placeholder: ctx2[36] },
        (!current || dirty[0] & 16384) && { style: ctx2[14] },
        (!current || dirty[0] & 512) && { disabled: ctx2[9] }
      ]));
      if (dirty[0] & 8 && input_1.value !== ctx2[3]) {
        set_input_value(input_1, ctx2[3]);
      }
      toggle_class(input_1, "svelte-17fnnnn", true);
      if (!ctx2[7] && ctx2[29]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 536871040) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_72(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[37]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & 64) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_63(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!ctx2[37] && (ctx2[20] || ctx2[19] && !ctx2[2] || !ctx2[13] && !ctx2[9] && !ctx2[4] && (ctx2[29] && !ctx2[15] || !ctx2[29]))) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_44(ctx2);
          if_block5.c();
          if_block5.m(div, t6);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (ctx2[4]) {
        if (if_block6) {
        } else {
          if_block6 = create_if_block_38(ctx2);
          if_block6.c();
          if_block6.m(div, t7);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (ctx2[5]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_212(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div, t8);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (!ctx2[7] || ctx2[7] && !ctx2[35]) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
        } else {
          if_block8 = create_if_block_115(ctx2);
          if_block8.c();
          if_block8.m(div, t9);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
      if (ctx2[7] && ctx2[35]) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
        } else {
          if_block9 = create_if_block25(ctx2);
          if_block9.c();
          if_block9.m(div, null);
        }
      } else if (if_block9) {
        if_block9.d(1);
        if_block9 = null;
      }
      if (!current || dirty[0] & 2097152 && div_class_value !== (div_class_value = "selectContainer " + ctx2[21] + " svelte-17fnnnn")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & 2048) {
        attr_dev(div, "style", ctx2[11]);
      }
      if (!current || dirty[0] & 2098176) {
        toggle_class(div, "hasError", ctx2[10]);
      }
      if (!current || dirty[0] & 2097280) {
        toggle_class(div, "multiSelect", ctx2[7]);
      }
      if (!current || dirty[0] & 2097664) {
        toggle_class(div, "disabled", ctx2[9]);
      }
      if (!current || dirty[0] & 2097154) {
        toggle_class(div, "focused", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block7);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block7);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[82](null);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
      ctx[85](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function convertStringItemsToObjects(_items) {
  return _items.map((item, index) => {
    return { index, value: item, label: `${item}` };
  });
}
function instance50($$self, $$props, $$invalidate) {
  let filteredItems;
  let showSelectedItem;
  let showClearIcon;
  let placeholderText;
  let showMultiSelect;
  let listProps;
  let ariaSelection;
  let ariaContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, []);
  const dispatch = createEventDispatcher();
  let { id: id2 = null } = $$props;
  let { container = void 0 } = $$props;
  let { input = void 0 } = $$props;
  let { isMulti = false } = $$props;
  let { multiFullItemClearable = false } = $$props;
  let { isDisabled = false } = $$props;
  let { isCreatable = false } = $$props;
  let { isFocused = false } = $$props;
  let { value = null } = $$props;
  let { filterText = "" } = $$props;
  let { placeholder = "Select..." } = $$props;
  let { placeholderAlwaysShow = false } = $$props;
  let { items = null } = $$props;
  let { itemFilter = (label, filterText2, option) => `${label}`.toLowerCase().includes(filterText2.toLowerCase()) } = $$props;
  let { groupBy = void 0 } = $$props;
  let { groupFilter = (groups) => groups } = $$props;
  let { isGroupHeaderSelectable = false } = $$props;
  let { getGroupHeaderLabel = (option) => {
    return option[labelIdentifier] || option.id;
  } } = $$props;
  let { labelIdentifier = "label" } = $$props;
  let { getOptionLabel = (option, filterText2) => {
    return option.isCreator ? `Create "${filterText2}"` : option[labelIdentifier];
  } } = $$props;
  let { optionIdentifier = "value" } = $$props;
  let { loadOptions = void 0 } = $$props;
  let { hasError = false } = $$props;
  let { containerStyles = "" } = $$props;
  let { getSelectionLabel = (option) => {
    if (option)
      return option[labelIdentifier];
    else
      return null;
  } } = $$props;
  let { createGroupHeaderItem = (groupValue) => {
    return { value: groupValue, label: groupValue };
  } } = $$props;
  let { createItem = (filterText2) => {
    return { value: filterText2, label: filterText2 };
  } } = $$props;
  const getFilteredItems = () => {
    return filteredItems;
  };
  let { isSearchable = true } = $$props;
  let { inputStyles = "" } = $$props;
  let { isClearable = true } = $$props;
  let { isWaiting = false } = $$props;
  let { listPlacement = "auto" } = $$props;
  let { listOpen = false } = $$props;
  let { isVirtualList = false } = $$props;
  let { loadOptionsInterval = 300 } = $$props;
  let { noOptionsMessage = "No options" } = $$props;
  let { hideEmptyState = false } = $$props;
  let { inputAttributes = {} } = $$props;
  let { listAutoWidth = true } = $$props;
  let { itemHeight = 40 } = $$props;
  let { Icon: Icon2 = void 0 } = $$props;
  let { iconProps = {} } = $$props;
  let { showChevron = false } = $$props;
  let { showIndicator = false } = $$props;
  let { containerClasses = "" } = $$props;
  let { indicatorSvg = void 0 } = $$props;
  let { listOffset = 5 } = $$props;
  let { ClearIcon: ClearIcon2 = ClearIcon_default } = $$props;
  let { Item: Item2 = Item_default } = $$props;
  let { List: List2 = List_default } = $$props;
  let { Selection: Selection2 = Selection_default } = $$props;
  let { MultiSelection: MultiSelection2 = MultiSelection_default } = $$props;
  let { VirtualList: VirtualList2 = VirtualList_default } = $$props;
  function filterMethod(args) {
    if (args.loadOptions && args.filterText.length > 0)
      return;
    if (!args.items)
      return [];
    if (args.items && args.items.length > 0 && typeof args.items[0] !== "object") {
      args.items = convertStringItemsToObjects(args.items);
    }
    let filterResults = args.items.filter((item) => {
      let matchesFilter = itemFilter(getOptionLabel(item, args.filterText), args.filterText, item);
      if (matchesFilter && args.isMulti && args.value && Array.isArray(args.value)) {
        matchesFilter = !args.value.some((x) => {
          return x[args.optionIdentifier] === item[args.optionIdentifier];
        });
      }
      return matchesFilter;
    });
    if (args.groupBy) {
      filterResults = filterGroupedItems(filterResults);
    }
    if (args.isCreatable) {
      filterResults = addCreatableItem(filterResults, args.filterText);
    }
    return filterResults;
  }
  function addCreatableItem(_items, _filterText) {
    if (_filterText.length === 0)
      return _items;
    const itemToCreate = createItem(_filterText);
    if (_items[0] && _filterText === _items[0][labelIdentifier])
      return _items;
    itemToCreate.isCreator = true;
    return [..._items, itemToCreate];
  }
  let { selectedValue = null } = $$props;
  let activeValue;
  let prev_value;
  let prev_filterText;
  let prev_isFocused;
  let prev_isMulti;
  let hoverItemIndex;
  const getItems = debounce(
    async () => {
      $$invalidate(4, isWaiting = true);
      let res = await loadOptions(filterText).catch((err) => {
        console.warn("svelte-select loadOptions error :>> ", err);
        dispatch("error", { type: "loadOptions", details: err });
      });
      if (res && !res.cancelled) {
        if (res) {
          if (res && res.length > 0 && typeof res[0] !== "object") {
            res = convertStringItemsToObjects(res);
          }
          $$invalidate(81, filteredItems = [...res]);
          dispatch("loaded", { items: filteredItems });
        } else {
          $$invalidate(81, filteredItems = []);
        }
        if (isCreatable) {
          $$invalidate(81, filteredItems = addCreatableItem(filteredItems, filterText));
        }
        $$invalidate(4, isWaiting = false);
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = true);
      }
    },
    loadOptionsInterval
  );
  function setValue() {
    if (typeof value === "string") {
      $$invalidate(2, value = { [optionIdentifier]: value, label: value });
    } else if (isMulti && Array.isArray(value) && value.length > 0) {
      $$invalidate(2, value = value.map((item) => typeof item === "string" ? { value: item, label: item } : item));
    }
  }
  let _inputAttributes;
  function assignInputAttributes() {
    $$invalidate(31, _inputAttributes = Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      inputAttributes
    ));
    if (id2) {
      $$invalidate(31, _inputAttributes.id = id2, _inputAttributes);
    }
    if (!isSearchable) {
      $$invalidate(31, _inputAttributes.readonly = true, _inputAttributes);
    }
  }
  function filterGroupedItems(_items) {
    const groupValues = [];
    const groups = {};
    _items.forEach((item) => {
      const groupValue = groupBy(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
            id: groupValue,
            isGroupHeader: true,
            isSelectable: isGroupHeaderSelectable
          }));
        }
      }
      groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
    });
    const sortedGroupedItems = [];
    groupFilter(groupValues).forEach((groupValue) => {
      sortedGroupedItems.push(...groups[groupValue]);
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (isMulti) {
      if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
        if (checkValueForDuplicates()) {
          dispatch("select", value);
        }
      }
      return;
    }
    if (!prev_value || JSON.stringify(value[optionIdentifier]) !== JSON.stringify(prev_value[optionIdentifier])) {
      dispatch("select", value);
    }
  }
  function setupFocus() {
    if (isFocused || listOpen) {
      handleFocus();
    } else {
      if (input)
        input.blur();
    }
  }
  function setupMulti() {
    if (value) {
      if (Array.isArray(value)) {
        $$invalidate(2, value = [...value]);
      } else {
        $$invalidate(2, value = [value]);
      }
    }
  }
  function setupSingle() {
    if (value)
      $$invalidate(2, value = null);
  }
  function setupFilterText() {
    if (filterText.length === 0)
      return;
    $$invalidate(1, isFocused = true);
    $$invalidate(5, listOpen = true);
    if (loadOptions) {
      getItems();
    } else {
      $$invalidate(5, listOpen = true);
      if (isMulti) {
        $$invalidate(30, activeValue = void 0);
      }
    }
  }
  beforeUpdate(async () => {
    $$invalidate(77, prev_value = value);
    $$invalidate(78, prev_filterText = filterText);
    $$invalidate(79, prev_isFocused = isFocused);
    $$invalidate(80, prev_isMulti = isMulti);
  });
  function checkValueForDuplicates() {
    let noDuplicates = true;
    if (value) {
      const ids = [];
      const uniqueValues = [];
      value.forEach((val) => {
        if (!ids.includes(val[optionIdentifier])) {
          ids.push(val[optionIdentifier]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates)
        $$invalidate(2, value = uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    let matchTo = selection ? selection[optionIdentifier] : value[optionIdentifier];
    return items.find((item) => item[optionIdentifier] === matchTo);
  }
  function updateValueDisplay(items2) {
    if (!items2 || items2.length === 0 || items2.some((item) => typeof item !== "object"))
      return;
    if (!value || (isMulti ? value.some((selection) => !selection || !selection[optionIdentifier]) : !value[optionIdentifier]))
      return;
    if (Array.isArray(value)) {
      $$invalidate(2, value = value.map((selection) => findItem(selection) || selection));
    } else {
      $$invalidate(2, value = findItem() || value);
    }
  }
  function handleMultiItemClear(event) {
    const { detail } = event;
    const itemToRemove = value[detail ? detail.i : value.length - 1];
    if (value.length === 1) {
      $$invalidate(2, value = void 0);
    } else {
      $$invalidate(2, value = value.filter((item) => {
        return item !== itemToRemove;
      }));
    }
    dispatch("clear", itemToRemove);
  }
  function handleKeyDown(e) {
    if (!isFocused)
      return;
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        $$invalidate(5, listOpen = true);
        $$invalidate(30, activeValue = void 0);
        break;
      case "ArrowUp":
        e.preventDefault();
        $$invalidate(5, listOpen = true);
        $$invalidate(30, activeValue = void 0);
        break;
      case "Tab":
        if (!listOpen)
          $$invalidate(1, isFocused = false);
        break;
      case "Backspace":
        if (!isMulti || filterText.length > 0)
          return;
        if (isMulti && value && value.length > 0) {
          handleMultiItemClear(activeValue !== void 0 ? activeValue : value.length - 1);
          if (activeValue === 0 || activeValue === void 0)
            break;
          $$invalidate(30, activeValue = value.length > activeValue ? activeValue - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!isMulti || filterText.length > 0)
          return;
        if (activeValue === void 0) {
          $$invalidate(30, activeValue = value.length - 1);
        } else if (value.length > activeValue && activeValue !== 0) {
          $$invalidate(30, activeValue -= 1);
        }
        break;
      case "ArrowRight":
        if (!isMulti || filterText.length > 0 || activeValue === void 0)
          return;
        if (activeValue === value.length - 1) {
          $$invalidate(30, activeValue = void 0);
        } else if (activeValue < value.length - 1) {
          $$invalidate(30, activeValue += 1);
        }
        break;
    }
  }
  function handleFocus() {
    $$invalidate(1, isFocused = true);
    if (input)
      input.focus();
  }
  function handleWindowEvent(event) {
    if (!container)
      return;
    const eventTarget = event.path && event.path.length > 0 ? event.path[0] : event.target;
    if (container.contains(eventTarget) || container.contains(event.relatedTarget)) {
      return;
    }
    $$invalidate(1, isFocused = false);
    $$invalidate(5, listOpen = false);
    $$invalidate(30, activeValue = void 0);
    if (input)
      input.blur();
  }
  function handleClick() {
    if (isDisabled)
      return;
    $$invalidate(1, isFocused = true);
    $$invalidate(5, listOpen = !listOpen);
  }
  function handleClear() {
    $$invalidate(2, value = void 0);
    $$invalidate(5, listOpen = false);
    dispatch("clear", value);
    handleFocus();
  }
  onMount(() => {
    if (isFocused && input)
      input.focus();
  });
  function itemSelected(event) {
    const { detail } = event;
    if (detail) {
      $$invalidate(3, filterText = "");
      const item = Object.assign({}, detail);
      if (!item.isGroupHeader || item.isSelectable) {
        if (isMulti) {
          $$invalidate(2, value = value ? value.concat([item]) : [item]);
        } else {
          $$invalidate(2, value = item);
        }
        $$invalidate(2, value);
        setTimeout(() => {
          $$invalidate(5, listOpen = false);
          $$invalidate(30, activeValue = void 0);
        });
      }
    }
  }
  function itemCreated(event) {
    const { detail } = event;
    if (isMulti) {
      $$invalidate(2, value = value || []);
      $$invalidate(2, value = [...value, createItem(detail)]);
    } else {
      $$invalidate(2, value = createItem(detail));
    }
    dispatch("itemCreated", detail);
    $$invalidate(3, filterText = "");
    $$invalidate(5, listOpen = false);
    $$invalidate(30, activeValue = void 0);
  }
  function closeList() {
    $$invalidate(3, filterText = "");
    $$invalidate(5, listOpen = false);
  }
  let { ariaValues = (values) => {
    return `Option ${values}, selected.`;
  } } = $$props;
  let { ariaListOpen = (label, count) => {
    return `You are currently focused on option ${label}. There are ${count} results available.`;
  } } = $$props;
  let { ariaFocused = () => {
    return `Select is focused, type to refine list, press down to open the menu.`;
  } } = $$props;
  function handleAriaSelection() {
    let selected = void 0;
    if (isMulti && value.length > 0) {
      selected = value.map((v) => getSelectionLabel(v)).join(", ");
    } else {
      selected = getSelectionLabel(value);
    }
    return ariaValues(selected);
  }
  function handleAriaContent() {
    if (!isFocused || !filteredItems || filteredItems.length === 0)
      return "";
    let _item = filteredItems[hoverItemIndex];
    if (listOpen && _item) {
      let label = getSelectionLabel(_item);
      let count = filteredItems ? filteredItems.length : 0;
      return ariaListOpen(label, count);
    } else {
      return ariaFocused();
    }
  }
  const writable_props = [
    "id",
    "container",
    "input",
    "isMulti",
    "multiFullItemClearable",
    "isDisabled",
    "isCreatable",
    "isFocused",
    "value",
    "filterText",
    "placeholder",
    "placeholderAlwaysShow",
    "items",
    "itemFilter",
    "groupBy",
    "groupFilter",
    "isGroupHeaderSelectable",
    "getGroupHeaderLabel",
    "labelIdentifier",
    "getOptionLabel",
    "optionIdentifier",
    "loadOptions",
    "hasError",
    "containerStyles",
    "getSelectionLabel",
    "createGroupHeaderItem",
    "createItem",
    "isSearchable",
    "inputStyles",
    "isClearable",
    "isWaiting",
    "listPlacement",
    "listOpen",
    "isVirtualList",
    "loadOptionsInterval",
    "noOptionsMessage",
    "hideEmptyState",
    "inputAttributes",
    "listAutoWidth",
    "itemHeight",
    "Icon",
    "iconProps",
    "showChevron",
    "showIndicator",
    "containerClasses",
    "indicatorSvg",
    "listOffset",
    "ClearIcon",
    "Item",
    "List",
    "Selection",
    "MultiSelection",
    "VirtualList",
    "selectedValue",
    "ariaValues",
    "ariaListOpen",
    "ariaFocused"
  ];
  Object_16.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_13.warn(`<Select> was created with unknown prop '${key}'`);
  });
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(6, input);
    });
  }
  function input_1_input_handler() {
    filterText = this.value;
    $$invalidate(3, filterText);
  }
  function switch_instance_hoverItemIndex_binding(value2) {
    hoverItemIndex = value2;
    $$invalidate(28, hoverItemIndex);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(46, id2 = $$props2.id);
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2)
      $$invalidate(6, input = $$props2.input);
    if ("isMulti" in $$props2)
      $$invalidate(7, isMulti = $$props2.isMulti);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(8, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("isDisabled" in $$props2)
      $$invalidate(9, isDisabled = $$props2.isDisabled);
    if ("isCreatable" in $$props2)
      $$invalidate(47, isCreatable = $$props2.isCreatable);
    if ("isFocused" in $$props2)
      $$invalidate(1, isFocused = $$props2.isFocused);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("filterText" in $$props2)
      $$invalidate(3, filterText = $$props2.filterText);
    if ("placeholder" in $$props2)
      $$invalidate(48, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2)
      $$invalidate(49, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2)
      $$invalidate(50, items = $$props2.items);
    if ("itemFilter" in $$props2)
      $$invalidate(51, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2)
      $$invalidate(52, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2)
      $$invalidate(53, groupFilter = $$props2.groupFilter);
    if ("isGroupHeaderSelectable" in $$props2)
      $$invalidate(54, isGroupHeaderSelectable = $$props2.isGroupHeaderSelectable);
    if ("getGroupHeaderLabel" in $$props2)
      $$invalidate(55, getGroupHeaderLabel = $$props2.getGroupHeaderLabel);
    if ("labelIdentifier" in $$props2)
      $$invalidate(56, labelIdentifier = $$props2.labelIdentifier);
    if ("getOptionLabel" in $$props2)
      $$invalidate(57, getOptionLabel = $$props2.getOptionLabel);
    if ("optionIdentifier" in $$props2)
      $$invalidate(58, optionIdentifier = $$props2.optionIdentifier);
    if ("loadOptions" in $$props2)
      $$invalidate(59, loadOptions = $$props2.loadOptions);
    if ("hasError" in $$props2)
      $$invalidate(10, hasError = $$props2.hasError);
    if ("containerStyles" in $$props2)
      $$invalidate(11, containerStyles = $$props2.containerStyles);
    if ("getSelectionLabel" in $$props2)
      $$invalidate(12, getSelectionLabel = $$props2.getSelectionLabel);
    if ("createGroupHeaderItem" in $$props2)
      $$invalidate(60, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("createItem" in $$props2)
      $$invalidate(61, createItem = $$props2.createItem);
    if ("isSearchable" in $$props2)
      $$invalidate(13, isSearchable = $$props2.isSearchable);
    if ("inputStyles" in $$props2)
      $$invalidate(14, inputStyles = $$props2.inputStyles);
    if ("isClearable" in $$props2)
      $$invalidate(15, isClearable = $$props2.isClearable);
    if ("isWaiting" in $$props2)
      $$invalidate(4, isWaiting = $$props2.isWaiting);
    if ("listPlacement" in $$props2)
      $$invalidate(63, listPlacement = $$props2.listPlacement);
    if ("listOpen" in $$props2)
      $$invalidate(5, listOpen = $$props2.listOpen);
    if ("isVirtualList" in $$props2)
      $$invalidate(64, isVirtualList = $$props2.isVirtualList);
    if ("loadOptionsInterval" in $$props2)
      $$invalidate(65, loadOptionsInterval = $$props2.loadOptionsInterval);
    if ("noOptionsMessage" in $$props2)
      $$invalidate(66, noOptionsMessage = $$props2.noOptionsMessage);
    if ("hideEmptyState" in $$props2)
      $$invalidate(67, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2)
      $$invalidate(16, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2)
      $$invalidate(68, listAutoWidth = $$props2.listAutoWidth);
    if ("itemHeight" in $$props2)
      $$invalidate(69, itemHeight = $$props2.itemHeight);
    if ("Icon" in $$props2)
      $$invalidate(17, Icon2 = $$props2.Icon);
    if ("iconProps" in $$props2)
      $$invalidate(18, iconProps = $$props2.iconProps);
    if ("showChevron" in $$props2)
      $$invalidate(19, showChevron = $$props2.showChevron);
    if ("showIndicator" in $$props2)
      $$invalidate(20, showIndicator = $$props2.showIndicator);
    if ("containerClasses" in $$props2)
      $$invalidate(21, containerClasses = $$props2.containerClasses);
    if ("indicatorSvg" in $$props2)
      $$invalidate(22, indicatorSvg = $$props2.indicatorSvg);
    if ("listOffset" in $$props2)
      $$invalidate(70, listOffset = $$props2.listOffset);
    if ("ClearIcon" in $$props2)
      $$invalidate(23, ClearIcon2 = $$props2.ClearIcon);
    if ("Item" in $$props2)
      $$invalidate(71, Item2 = $$props2.Item);
    if ("List" in $$props2)
      $$invalidate(24, List2 = $$props2.List);
    if ("Selection" in $$props2)
      $$invalidate(25, Selection2 = $$props2.Selection);
    if ("MultiSelection" in $$props2)
      $$invalidate(26, MultiSelection2 = $$props2.MultiSelection);
    if ("VirtualList" in $$props2)
      $$invalidate(72, VirtualList2 = $$props2.VirtualList);
    if ("selectedValue" in $$props2)
      $$invalidate(73, selectedValue = $$props2.selectedValue);
    if ("ariaValues" in $$props2)
      $$invalidate(74, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2)
      $$invalidate(75, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2)
      $$invalidate(76, ariaFocused = $$props2.ariaFocused);
  };
  $$self.$capture_state = () => ({
    beforeUpdate,
    createEventDispatcher,
    onMount,
    _List: List_default,
    _Item: Item_default,
    _Selection: Selection_default,
    _MultiSelection: MultiSelection_default,
    _VirtualList: VirtualList_default,
    _ClearIcon: ClearIcon_default,
    debounce,
    dispatch,
    id: id2,
    container,
    input,
    isMulti,
    multiFullItemClearable,
    isDisabled,
    isCreatable,
    isFocused,
    value,
    filterText,
    placeholder,
    placeholderAlwaysShow,
    items,
    itemFilter,
    groupBy,
    groupFilter,
    isGroupHeaderSelectable,
    getGroupHeaderLabel,
    labelIdentifier,
    getOptionLabel,
    optionIdentifier,
    loadOptions,
    hasError,
    containerStyles,
    getSelectionLabel,
    createGroupHeaderItem,
    createItem,
    getFilteredItems,
    isSearchable,
    inputStyles,
    isClearable,
    isWaiting,
    listPlacement,
    listOpen,
    isVirtualList,
    loadOptionsInterval,
    noOptionsMessage,
    hideEmptyState,
    inputAttributes,
    listAutoWidth,
    itemHeight,
    Icon: Icon2,
    iconProps,
    showChevron,
    showIndicator,
    containerClasses,
    indicatorSvg,
    listOffset,
    ClearIcon: ClearIcon2,
    Item: Item2,
    List: List2,
    Selection: Selection2,
    MultiSelection: MultiSelection2,
    VirtualList: VirtualList2,
    filterMethod,
    addCreatableItem,
    selectedValue,
    activeValue,
    prev_value,
    prev_filterText,
    prev_isFocused,
    prev_isMulti,
    hoverItemIndex,
    getItems,
    setValue,
    _inputAttributes,
    assignInputAttributes,
    convertStringItemsToObjects,
    filterGroupedItems,
    dispatchSelectedItem,
    setupFocus,
    setupMulti,
    setupSingle,
    setupFilterText,
    checkValueForDuplicates,
    findItem,
    updateValueDisplay,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleWindowEvent,
    handleClick,
    handleClear,
    itemSelected,
    itemCreated,
    closeList,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    handleAriaSelection,
    handleAriaContent,
    filteredItems,
    ariaContext,
    ariaSelection,
    listProps,
    showMultiSelect,
    placeholderText,
    showSelectedItem,
    showClearIcon
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(46, id2 = $$props2.id);
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2)
      $$invalidate(6, input = $$props2.input);
    if ("isMulti" in $$props2)
      $$invalidate(7, isMulti = $$props2.isMulti);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(8, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("isDisabled" in $$props2)
      $$invalidate(9, isDisabled = $$props2.isDisabled);
    if ("isCreatable" in $$props2)
      $$invalidate(47, isCreatable = $$props2.isCreatable);
    if ("isFocused" in $$props2)
      $$invalidate(1, isFocused = $$props2.isFocused);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("filterText" in $$props2)
      $$invalidate(3, filterText = $$props2.filterText);
    if ("placeholder" in $$props2)
      $$invalidate(48, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2)
      $$invalidate(49, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2)
      $$invalidate(50, items = $$props2.items);
    if ("itemFilter" in $$props2)
      $$invalidate(51, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2)
      $$invalidate(52, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2)
      $$invalidate(53, groupFilter = $$props2.groupFilter);
    if ("isGroupHeaderSelectable" in $$props2)
      $$invalidate(54, isGroupHeaderSelectable = $$props2.isGroupHeaderSelectable);
    if ("getGroupHeaderLabel" in $$props2)
      $$invalidate(55, getGroupHeaderLabel = $$props2.getGroupHeaderLabel);
    if ("labelIdentifier" in $$props2)
      $$invalidate(56, labelIdentifier = $$props2.labelIdentifier);
    if ("getOptionLabel" in $$props2)
      $$invalidate(57, getOptionLabel = $$props2.getOptionLabel);
    if ("optionIdentifier" in $$props2)
      $$invalidate(58, optionIdentifier = $$props2.optionIdentifier);
    if ("loadOptions" in $$props2)
      $$invalidate(59, loadOptions = $$props2.loadOptions);
    if ("hasError" in $$props2)
      $$invalidate(10, hasError = $$props2.hasError);
    if ("containerStyles" in $$props2)
      $$invalidate(11, containerStyles = $$props2.containerStyles);
    if ("getSelectionLabel" in $$props2)
      $$invalidate(12, getSelectionLabel = $$props2.getSelectionLabel);
    if ("createGroupHeaderItem" in $$props2)
      $$invalidate(60, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("createItem" in $$props2)
      $$invalidate(61, createItem = $$props2.createItem);
    if ("isSearchable" in $$props2)
      $$invalidate(13, isSearchable = $$props2.isSearchable);
    if ("inputStyles" in $$props2)
      $$invalidate(14, inputStyles = $$props2.inputStyles);
    if ("isClearable" in $$props2)
      $$invalidate(15, isClearable = $$props2.isClearable);
    if ("isWaiting" in $$props2)
      $$invalidate(4, isWaiting = $$props2.isWaiting);
    if ("listPlacement" in $$props2)
      $$invalidate(63, listPlacement = $$props2.listPlacement);
    if ("listOpen" in $$props2)
      $$invalidate(5, listOpen = $$props2.listOpen);
    if ("isVirtualList" in $$props2)
      $$invalidate(64, isVirtualList = $$props2.isVirtualList);
    if ("loadOptionsInterval" in $$props2)
      $$invalidate(65, loadOptionsInterval = $$props2.loadOptionsInterval);
    if ("noOptionsMessage" in $$props2)
      $$invalidate(66, noOptionsMessage = $$props2.noOptionsMessage);
    if ("hideEmptyState" in $$props2)
      $$invalidate(67, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2)
      $$invalidate(16, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2)
      $$invalidate(68, listAutoWidth = $$props2.listAutoWidth);
    if ("itemHeight" in $$props2)
      $$invalidate(69, itemHeight = $$props2.itemHeight);
    if ("Icon" in $$props2)
      $$invalidate(17, Icon2 = $$props2.Icon);
    if ("iconProps" in $$props2)
      $$invalidate(18, iconProps = $$props2.iconProps);
    if ("showChevron" in $$props2)
      $$invalidate(19, showChevron = $$props2.showChevron);
    if ("showIndicator" in $$props2)
      $$invalidate(20, showIndicator = $$props2.showIndicator);
    if ("containerClasses" in $$props2)
      $$invalidate(21, containerClasses = $$props2.containerClasses);
    if ("indicatorSvg" in $$props2)
      $$invalidate(22, indicatorSvg = $$props2.indicatorSvg);
    if ("listOffset" in $$props2)
      $$invalidate(70, listOffset = $$props2.listOffset);
    if ("ClearIcon" in $$props2)
      $$invalidate(23, ClearIcon2 = $$props2.ClearIcon);
    if ("Item" in $$props2)
      $$invalidate(71, Item2 = $$props2.Item);
    if ("List" in $$props2)
      $$invalidate(24, List2 = $$props2.List);
    if ("Selection" in $$props2)
      $$invalidate(25, Selection2 = $$props2.Selection);
    if ("MultiSelection" in $$props2)
      $$invalidate(26, MultiSelection2 = $$props2.MultiSelection);
    if ("VirtualList" in $$props2)
      $$invalidate(72, VirtualList2 = $$props2.VirtualList);
    if ("selectedValue" in $$props2)
      $$invalidate(73, selectedValue = $$props2.selectedValue);
    if ("activeValue" in $$props2)
      $$invalidate(30, activeValue = $$props2.activeValue);
    if ("prev_value" in $$props2)
      $$invalidate(77, prev_value = $$props2.prev_value);
    if ("prev_filterText" in $$props2)
      $$invalidate(78, prev_filterText = $$props2.prev_filterText);
    if ("prev_isFocused" in $$props2)
      $$invalidate(79, prev_isFocused = $$props2.prev_isFocused);
    if ("prev_isMulti" in $$props2)
      $$invalidate(80, prev_isMulti = $$props2.prev_isMulti);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(28, hoverItemIndex = $$props2.hoverItemIndex);
    if ("_inputAttributes" in $$props2)
      $$invalidate(31, _inputAttributes = $$props2._inputAttributes);
    if ("ariaValues" in $$props2)
      $$invalidate(74, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2)
      $$invalidate(75, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2)
      $$invalidate(76, ariaFocused = $$props2.ariaFocused);
    if ("filteredItems" in $$props2)
      $$invalidate(81, filteredItems = $$props2.filteredItems);
    if ("ariaContext" in $$props2)
      $$invalidate(32, ariaContext = $$props2.ariaContext);
    if ("ariaSelection" in $$props2)
      $$invalidate(33, ariaSelection = $$props2.ariaSelection);
    if ("listProps" in $$props2)
      $$invalidate(34, listProps = $$props2.listProps);
    if ("showMultiSelect" in $$props2)
      $$invalidate(35, showMultiSelect = $$props2.showMultiSelect);
    if ("placeholderText" in $$props2)
      $$invalidate(36, placeholderText = $$props2.placeholderText);
    if ("showSelectedItem" in $$props2)
      $$invalidate(29, showSelectedItem = $$props2.showSelectedItem);
    if ("showClearIcon" in $$props2)
      $$invalidate(37, showClearIcon = $$props2.showClearIcon);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 140 | $$self.$$.dirty[1] & 405340160) {
      $:
        $$invalidate(81, filteredItems = filterMethod({
          loadOptions,
          filterText,
          items,
          value,
          isMulti,
          optionIdentifier,
          groupBy,
          isCreatable
        }));
    }
    if ($$self.$$.dirty[2] & 2048) {
      $: {
        if (selectedValue)
          console.warn("selectedValue is no longer used. Please use value instead.");
      }
    }
    if ($$self.$$.dirty[1] & 524288) {
      $:
        updateValueDisplay(items);
    }
    if ($$self.$$.dirty[0] & 4) {
      $: {
        if (value)
          setValue();
      }
    }
    if ($$self.$$.dirty[0] & 73728) {
      $: {
        if (inputAttributes || !isSearchable)
          assignInputAttributes();
      }
    }
    if ($$self.$$.dirty[0] & 128 | $$self.$$.dirty[2] & 262144) {
      $: {
        if (isMulti) {
          setupMulti();
        }
        if (prev_isMulti && !isMulti) {
          setupSingle();
        }
      }
    }
    if ($$self.$$.dirty[0] & 132) {
      $: {
        if (isMulti && value && value.length > 1) {
          checkValueForDuplicates();
        }
      }
    }
    if ($$self.$$.dirty[0] & 4) {
      $: {
        if (value)
          dispatchSelectedItem();
      }
    }
    if ($$self.$$.dirty[0] & 132 | $$self.$$.dirty[2] & 32768) {
      $: {
        if (!value && isMulti && prev_value) {
          dispatch("select", value);
        }
      }
    }
    if ($$self.$$.dirty[0] & 2 | $$self.$$.dirty[2] & 131072) {
      $: {
        if (isFocused !== prev_isFocused) {
          setupFocus();
        }
      }
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[2] & 65536) {
      $: {
        if (filterText !== prev_filterText) {
          setupFilterText();
        }
      }
    }
    if ($$self.$$.dirty[0] & 12) {
      $:
        $$invalidate(29, showSelectedItem = value && filterText.length === 0);
    }
    if ($$self.$$.dirty[0] & 536904208) {
      $:
        $$invalidate(37, showClearIcon = showSelectedItem && isClearable && !isDisabled && !isWaiting);
    }
    if ($$self.$$.dirty[0] & 132 | $$self.$$.dirty[1] & 393216) {
      $:
        $$invalidate(36, placeholderText = placeholderAlwaysShow && isMulti ? placeholder : value ? "" : placeholder);
    }
    if ($$self.$$.dirty[0] & 132) {
      $:
        $$invalidate(35, showMultiSelect = isMulti && value && value.length > 0);
    }
    if ($$self.$$.dirty[0] & 141 | $$self.$$.dirty[1] & 218103808 | $$self.$$.dirty[2] & 526326) {
      $:
        $$invalidate(34, listProps = {
          Item: Item2,
          filterText,
          optionIdentifier,
          noOptionsMessage,
          hideEmptyState,
          isVirtualList,
          VirtualList: VirtualList2,
          value,
          isMulti,
          getGroupHeaderLabel,
          items: filteredItems,
          itemHeight,
          getOptionLabel,
          listPlacement,
          parent: container,
          listAutoWidth,
          listOffset
        });
    }
    if ($$self.$$.dirty[0] & 132) {
      $:
        $$invalidate(33, ariaSelection = value ? handleAriaSelection(isMulti) : "");
    }
    if ($$self.$$.dirty[0] & 268435490 | $$self.$$.dirty[2] & 524288) {
      $:
        $$invalidate(32, ariaContext = handleAriaContent(filteredItems, hoverItemIndex, isFocused, listOpen));
    }
  };
  return [
    container,
    isFocused,
    value,
    filterText,
    isWaiting,
    listOpen,
    input,
    isMulti,
    multiFullItemClearable,
    isDisabled,
    hasError,
    containerStyles,
    getSelectionLabel,
    isSearchable,
    inputStyles,
    isClearable,
    inputAttributes,
    Icon2,
    iconProps,
    showChevron,
    showIndicator,
    containerClasses,
    indicatorSvg,
    ClearIcon2,
    List2,
    Selection2,
    MultiSelection2,
    handleClear,
    hoverItemIndex,
    showSelectedItem,
    activeValue,
    _inputAttributes,
    ariaContext,
    ariaSelection,
    listProps,
    showMultiSelect,
    placeholderText,
    showClearIcon,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleWindowEvent,
    handleClick,
    itemSelected,
    itemCreated,
    closeList,
    id2,
    isCreatable,
    placeholder,
    placeholderAlwaysShow,
    items,
    itemFilter,
    groupBy,
    groupFilter,
    isGroupHeaderSelectable,
    getGroupHeaderLabel,
    labelIdentifier,
    getOptionLabel,
    optionIdentifier,
    loadOptions,
    createGroupHeaderItem,
    createItem,
    getFilteredItems,
    listPlacement,
    isVirtualList,
    loadOptionsInterval,
    noOptionsMessage,
    hideEmptyState,
    listAutoWidth,
    itemHeight,
    listOffset,
    Item2,
    VirtualList2,
    selectedValue,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    prev_value,
    prev_filterText,
    prev_isFocused,
    prev_isMulti,
    filteredItems,
    input_1_binding,
    input_1_input_handler,
    switch_instance_hoverItemIndex_binding,
    div_binding
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance50,
      create_fragment50,
      safe_not_equal,
      {
        id: 46,
        container: 0,
        input: 6,
        isMulti: 7,
        multiFullItemClearable: 8,
        isDisabled: 9,
        isCreatable: 47,
        isFocused: 1,
        value: 2,
        filterText: 3,
        placeholder: 48,
        placeholderAlwaysShow: 49,
        items: 50,
        itemFilter: 51,
        groupBy: 52,
        groupFilter: 53,
        isGroupHeaderSelectable: 54,
        getGroupHeaderLabel: 55,
        labelIdentifier: 56,
        getOptionLabel: 57,
        optionIdentifier: 58,
        loadOptions: 59,
        hasError: 10,
        containerStyles: 11,
        getSelectionLabel: 12,
        createGroupHeaderItem: 60,
        createItem: 61,
        getFilteredItems: 62,
        isSearchable: 13,
        inputStyles: 14,
        isClearable: 15,
        isWaiting: 4,
        listPlacement: 63,
        listOpen: 5,
        isVirtualList: 64,
        loadOptionsInterval: 65,
        noOptionsMessage: 66,
        hideEmptyState: 67,
        inputAttributes: 16,
        listAutoWidth: 68,
        itemHeight: 69,
        Icon: 17,
        iconProps: 18,
        showChevron: 19,
        showIndicator: 20,
        containerClasses: 21,
        indicatorSvg: 22,
        listOffset: 70,
        ClearIcon: 23,
        Item: 71,
        List: 24,
        Selection: 25,
        MultiSelection: 26,
        VirtualList: 72,
        selectedValue: 73,
        handleClear: 27,
        ariaValues: 74,
        ariaListOpen: 75,
        ariaFocused: 76
      },
      add_css40,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment50.name
    });
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isMulti() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isMulti(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiFullItemClearable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiFullItemClearable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isDisabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isDisabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCreatable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCreatable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isFocused() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isFocused(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholderAlwaysShow() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholderAlwaysShow(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemFilter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemFilter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupBy() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupBy(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupFilter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupFilter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isGroupHeaderSelectable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isGroupHeaderSelectable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getGroupHeaderLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getGroupHeaderLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelIdentifier() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelIdentifier(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getOptionLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getOptionLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get optionIdentifier() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set optionIdentifier(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadOptions() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loadOptions(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasError() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasError(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerStyles() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerStyles(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectionLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getSelectionLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createGroupHeaderItem() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createGroupHeaderItem(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createItem() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createItem(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getFilteredItems() {
    return this.$$.ctx[62];
  }
  set getFilteredItems(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSearchable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSearchable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputStyles() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputStyles(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isClearable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isClearable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isWaiting() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isWaiting(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listPlacement() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listPlacement(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listOpen() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listOpen(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVirtualList() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVirtualList(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadOptionsInterval() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loadOptionsInterval(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noOptionsMessage() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noOptionsMessage(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideEmptyState() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideEmptyState(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputAttributes() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputAttributes(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listAutoWidth() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listAutoWidth(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemHeight() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemHeight(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Icon() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Icon(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showChevron() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showChevron(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showIndicator() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showIndicator(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerClasses() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerClasses(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indicatorSvg() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indicatorSvg(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listOffset() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listOffset(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ClearIcon() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ClearIcon(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Item() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Item(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get List() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set List(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Selection() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Selection(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get MultiSelection() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set MultiSelection(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get VirtualList() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set VirtualList(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedValue() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedValue(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleClear() {
    return this.$$.ctx[27];
  }
  set handleClear(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaValues() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaValues(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaListOpen() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaListOpen(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaFocused() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaFocused(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// ../node_modules/svelte-jsoneditor/components/modals/TransformWizard.svelte
var file45 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/TransformWizard.svelte";
function add_css41(target) {
  append_styles(target, "svelte-1liozfp", "table.jse-transform-wizard.svelte-1liozfp.svelte-1liozfp{border-collapse:collapse;border-spacing:0;width:100%}table.jse-transform-wizard.svelte-1liozfp input.svelte-1liozfp{font-family:inherit;font-size:inherit}table.jse-transform-wizard.svelte-1liozfp tr th.svelte-1liozfp{font-weight:normal;text-align:left;width:60px}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal.svelte-1liozfp{width:100%;display:flex;flex-direction:row;margin-bottom:calc(0.5 * var(--jse-padding))}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal.svelte-1liozfp .selectContainer.jse-filter-path{flex:4;margin-right:calc(0.5 * var(--jse-padding))}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal.svelte-1liozfp .selectContainer.jse-filter-relation{flex:1.5;margin-right:calc(0.5 * var(--jse-padding))}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal.svelte-1liozfp .selectContainer.jse-sort-path{flex:3;margin-right:calc(0.5 * var(--jse-padding))}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal.svelte-1liozfp .selectContainer.jse-sort-direction{flex:1}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal.svelte-1liozfp .selectContainer.jse-projection-paths{flex:1}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal.svelte-1liozfp .selectContainer input{box-sizing:border-box}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal .jse-filter-value.svelte-1liozfp{flex:4;padding:4px 8px;border:var(--jse-input-border);border-radius:var(--jse-input-radius);outline:none;background:var(--jse-input-background);color:inherit}table.jse-transform-wizard.svelte-1liozfp tr td .jse-horizontal .jse-filter-value.svelte-1liozfp:focus{border:var(--jse-input-border-focus)}.svelte-1liozfp.svelte-1liozfp{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNmb3JtV2l6YXJkLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFvSm1DLEtBQUEscUJBQUEsOEJBQUEsQ0FBQSx3ckRBb0RsQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUcmFuc2Zvcm1XaXphcmQuc3ZlbHRlIl19 */");
}
function create_fragment51(ctx) {
  let table;
  let tr0;
  let th0;
  let t0;
  let t1;
  let td0;
  let div0;
  let select0;
  let updating_value;
  let t2;
  let select1;
  let updating_value_1;
  let t3;
  let input;
  let t4;
  let tr1;
  let th1;
  let t5;
  let t6;
  let td1;
  let div1;
  let select2;
  let updating_value_2;
  let t7;
  let select3;
  let updating_value_3;
  let t8;
  let tr2;
  let th2;
  let t9;
  let t10;
  let td2;
  let div2;
  let select4;
  let updating_value_4;
  let current;
  let mounted;
  let dispose;
  function select0_value_binding(value) {
    ctx[16](value);
  }
  let select0_props = {
    containerClasses: "jse-filter-path",
    showIndicator: true,
    items: ctx[6]
  };
  if (ctx[0] !== void 0) {
    select0_props.value = ctx[0];
  }
  select0 = new Select_default({ props: select0_props, $$inline: true });
  binding_callbacks.push(() => bind(select0, "value", select0_value_binding));
  function select1_value_binding(value) {
    ctx[17](value);
  }
  let select1_props = {
    containerClasses: "jse-filter-relation",
    showIndicator: true,
    items: ctx[8]
  };
  if (ctx[1] !== void 0) {
    select1_props.value = ctx[1];
  }
  select1 = new Select_default({ props: select1_props, $$inline: true });
  binding_callbacks.push(() => bind(select1, "value", select1_value_binding));
  function select2_value_binding(value) {
    ctx[19](value);
  }
  let select2_props = {
    containerClasses: "jse-sort-path",
    showIndicator: true,
    items: ctx[6]
  };
  if (ctx[3] !== void 0) {
    select2_props.value = ctx[3];
  }
  select2 = new Select_default({ props: select2_props, $$inline: true });
  binding_callbacks.push(() => bind(select2, "value", select2_value_binding));
  function select3_value_binding(value) {
    ctx[20](value);
  }
  let select3_props = {
    containerClasses: "jse-sort-direction",
    showIndicator: true,
    items: ctx[9]
  };
  if (ctx[4] !== void 0) {
    select3_props.value = ctx[4];
  }
  select3 = new Select_default({ props: select3_props, $$inline: true });
  binding_callbacks.push(() => bind(select3, "value", select3_value_binding));
  function select4_value_binding(value) {
    ctx[21](value);
  }
  let select4_props = {
    containerClasses: "jse-projection-paths",
    isMulti: true,
    showIndicator: true,
    items: ctx[7]
  };
  if (ctx[5] !== void 0) {
    select4_props.value = ctx[5];
  }
  select4 = new Select_default({ props: select4_props, $$inline: true });
  binding_callbacks.push(() => bind(select4, "value", select4_value_binding));
  const block = {
    c: function create() {
      table = element("table");
      tr0 = element("tr");
      th0 = element("th");
      t0 = text("Filter");
      t1 = space();
      td0 = element("td");
      div0 = element("div");
      create_component(select0.$$.fragment);
      t2 = space();
      create_component(select1.$$.fragment);
      t3 = space();
      input = element("input");
      t4 = space();
      tr1 = element("tr");
      th1 = element("th");
      t5 = text("Sort");
      t6 = space();
      td1 = element("td");
      div1 = element("div");
      create_component(select2.$$.fragment);
      t7 = space();
      create_component(select3.$$.fragment);
      t8 = space();
      tr2 = element("tr");
      th2 = element("th");
      t9 = text("Pick");
      t10 = space();
      td2 = element("td");
      div2 = element("div");
      create_component(select4.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      tr0 = claim_element(table_nodes, "TR", { class: true });
      var tr0_nodes = children(tr0);
      th0 = claim_element(tr0_nodes, "TH", { class: true });
      var th0_nodes = children(th0);
      t0 = claim_text(th0_nodes, "Filter");
      th0_nodes.forEach(detach_dev);
      t1 = claim_space(tr0_nodes);
      td0 = claim_element(tr0_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      div0 = claim_element(td0_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(select0.$$.fragment, div0_nodes);
      t2 = claim_space(div0_nodes);
      claim_component(select1.$$.fragment, div0_nodes);
      t3 = claim_space(div0_nodes);
      input = claim_element(div0_nodes, "INPUT", { class: true });
      div0_nodes.forEach(detach_dev);
      td0_nodes.forEach(detach_dev);
      tr0_nodes.forEach(detach_dev);
      t4 = claim_space(table_nodes);
      tr1 = claim_element(table_nodes, "TR", { class: true });
      var tr1_nodes = children(tr1);
      th1 = claim_element(tr1_nodes, "TH", { class: true });
      var th1_nodes = children(th1);
      t5 = claim_text(th1_nodes, "Sort");
      th1_nodes.forEach(detach_dev);
      t6 = claim_space(tr1_nodes);
      td1 = claim_element(tr1_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      div1 = claim_element(td1_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(select2.$$.fragment, div1_nodes);
      t7 = claim_space(div1_nodes);
      claim_component(select3.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      td1_nodes.forEach(detach_dev);
      tr1_nodes.forEach(detach_dev);
      t8 = claim_space(table_nodes);
      tr2 = claim_element(table_nodes, "TR", { class: true });
      var tr2_nodes = children(tr2);
      th2 = claim_element(tr2_nodes, "TH", { class: true });
      var th2_nodes = children(th2);
      t9 = claim_text(th2_nodes, "Pick");
      th2_nodes.forEach(detach_dev);
      t10 = claim_space(tr2_nodes);
      td2 = claim_element(tr2_nodes, "TD", { class: true });
      var td2_nodes = children(td2);
      div2 = claim_element(td2_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(select4.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach_dev);
      td2_nodes.forEach(detach_dev);
      tr2_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th0, "class", "svelte-1liozfp");
      add_location(th0, file45, 94, 4, 3951);
      attr_dev(input, "class", "jse-filter-value svelte-1liozfp");
      add_location(input, file45, 109, 8, 4358);
      attr_dev(div0, "class", "jse-horizontal svelte-1liozfp");
      add_location(div0, file45, 96, 6, 3982);
      attr_dev(td0, "class", "svelte-1liozfp");
      add_location(td0, file45, 95, 4, 3971);
      attr_dev(tr0, "class", "svelte-1liozfp");
      add_location(tr0, file45, 93, 2, 3942);
      attr_dev(th1, "class", "svelte-1liozfp");
      add_location(th1, file45, 114, 4, 4460);
      attr_dev(div1, "class", "jse-horizontal svelte-1liozfp");
      add_location(div1, file45, 116, 6, 4489);
      attr_dev(td1, "class", "svelte-1liozfp");
      add_location(td1, file45, 115, 4, 4478);
      attr_dev(tr1, "class", "svelte-1liozfp");
      add_location(tr1, file45, 113, 2, 4451);
      attr_dev(th2, "class", "svelte-1liozfp");
      add_location(th2, file45, 133, 4, 4892);
      attr_dev(div2, "class", "jse-horizontal svelte-1liozfp");
      add_location(div2, file45, 135, 6, 4921);
      attr_dev(td2, "class", "svelte-1liozfp");
      add_location(td2, file45, 134, 4, 4910);
      attr_dev(tr2, "class", "svelte-1liozfp");
      add_location(tr2, file45, 132, 2, 4883);
      attr_dev(table, "class", "jse-transform-wizard svelte-1liozfp");
      add_location(table, file45, 92, 0, 3903);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, tr0);
      append_hydration_dev(tr0, th0);
      append_hydration_dev(th0, t0);
      append_hydration_dev(tr0, t1);
      append_hydration_dev(tr0, td0);
      append_hydration_dev(td0, div0);
      mount_component(select0, div0, null);
      append_hydration_dev(div0, t2);
      mount_component(select1, div0, null);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, input);
      set_input_value(input, ctx[2]);
      append_hydration_dev(table, t4);
      append_hydration_dev(table, tr1);
      append_hydration_dev(tr1, th1);
      append_hydration_dev(th1, t5);
      append_hydration_dev(tr1, t6);
      append_hydration_dev(tr1, td1);
      append_hydration_dev(td1, div1);
      mount_component(select2, div1, null);
      append_hydration_dev(div1, t7);
      mount_component(select3, div1, null);
      append_hydration_dev(table, t8);
      append_hydration_dev(table, tr2);
      append_hydration_dev(tr2, th2);
      append_hydration_dev(th2, t9);
      append_hydration_dev(tr2, t10);
      append_hydration_dev(tr2, td2);
      append_hydration_dev(td2, div2);
      mount_component(select4, div2, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(input, "input", ctx[18]);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const select0_changes = {};
      if (dirty & 64)
        select0_changes.items = ctx2[6];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        select0_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      select0.$set(select0_changes);
      const select1_changes = {};
      if (!updating_value_1 && dirty & 2) {
        updating_value_1 = true;
        select1_changes.value = ctx2[1];
        add_flush_callback(() => updating_value_1 = false);
      }
      select1.$set(select1_changes);
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      const select2_changes = {};
      if (dirty & 64)
        select2_changes.items = ctx2[6];
      if (!updating_value_2 && dirty & 8) {
        updating_value_2 = true;
        select2_changes.value = ctx2[3];
        add_flush_callback(() => updating_value_2 = false);
      }
      select2.$set(select2_changes);
      const select3_changes = {};
      if (!updating_value_3 && dirty & 16) {
        updating_value_3 = true;
        select3_changes.value = ctx2[4];
        add_flush_callback(() => updating_value_3 = false);
      }
      select3.$set(select3_changes);
      const select4_changes = {};
      if (dirty & 128)
        select4_changes.items = ctx2[7];
      if (!updating_value_4 && dirty & 32) {
        updating_value_4 = true;
        select4_changes.value = ctx2[5];
        add_flush_callback(() => updating_value_4 = false);
      }
      select4.$set(select4_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select0.$$.fragment, local);
      transition_in(select1.$$.fragment, local);
      transition_in(select2.$$.fragment, local);
      transition_in(select3.$$.fragment, local);
      transition_in(select4.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select0.$$.fragment, local);
      transition_out(select1.$$.fragment, local);
      transition_out(select2.$$.fragment, local);
      transition_out(select3.$$.fragment, local);
      transition_out(select4.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_component(select0);
      destroy_component(select1);
      destroy_component(select2);
      destroy_component(select3);
      destroy_component(select4);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  var _a, _b, _c, _d, _e, _f;
  let jsonIsArray;
  let paths;
  let pathsIncludingObjects;
  let fieldOptions;
  let projectionOptions;
  let fieldPath;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformWizard", slots, []);
  const debug5 = createDebug("jsoneditor:TransformWizard");
  let { json: json2 } = $$props;
  let { queryOptions = {} } = $$props;
  let { onChange } = $$props;
  const filterRelationOptions = ["==", "!=", "<", "<=", ">", ">="].map((relation) => ({ value: relation, label: relation }));
  const sortDirectionOptions = [{ value: "asc", label: "ascending" }, { value: "desc", label: "descending" }];
  let filterPath2 = ((_a = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _a.path) ? pathToOption(queryOptions.filter.path) : null;
  let filterRelation = ((_b = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _b.relation) ? filterRelationOptions.find((option) => option.value === queryOptions.filter.relation) : null;
  let filterValue = ((_c = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _c.value) || "";
  let sortPath = ((_d = queryOptions == null ? void 0 : queryOptions.sort) == null ? void 0 : _d.path) ? pathToOption(queryOptions.sort.path) : null;
  let sortDirection = ((_e = queryOptions == null ? void 0 : queryOptions.sort) == null ? void 0 : _e.direction) ? sortDirectionOptions.find((option) => option.value === queryOptions.sort.direction) : null;
  let projectionPaths = ((_f = queryOptions == null ? void 0 : queryOptions.projection) == null ? void 0 : _f.paths) ? queryOptions.projection.paths.map(pathToOption) : null;
  function changeFilterPath(path) {
    var _a2;
    if (!isEqual_default((_a2 = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _a2.path, path)) {
      debug5("changeFilterPath", path);
      $$invalidate(10, queryOptions = setIn(queryOptions, ["filter", "path"], path, true));
      onChange(queryOptions);
    }
  }
  function changeFilterRelation(relation) {
    var _a2;
    if (!isEqual_default((_a2 = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _a2.relation, relation)) {
      debug5("changeFilterRelation", relation);
      $$invalidate(10, queryOptions = setIn(queryOptions, ["filter", "relation"], relation, true));
      onChange(queryOptions);
    }
  }
  function changeFilterValue(value) {
    var _a2;
    if (!isEqual_default((_a2 = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _a2.value, value)) {
      debug5("changeFilterValue", value);
      $$invalidate(10, queryOptions = setIn(queryOptions, ["filter", "value"], value, true));
      onChange(queryOptions);
    }
  }
  function changeSortPath(path) {
    var _a2;
    if (!isEqual_default((_a2 = queryOptions == null ? void 0 : queryOptions.sort) == null ? void 0 : _a2.path, path)) {
      debug5("changeSortPath", path);
      $$invalidate(10, queryOptions = setIn(queryOptions, ["sort", "path"], path, true));
      onChange(queryOptions);
    }
  }
  function changeSortDirection(direction) {
    var _a2;
    if (!isEqual_default((_a2 = queryOptions == null ? void 0 : queryOptions.sort) == null ? void 0 : _a2.direction, direction)) {
      debug5("changeSortDirection", direction);
      $$invalidate(10, queryOptions = setIn(queryOptions, ["sort", "direction"], direction, true));
      onChange(queryOptions);
    }
  }
  function changeProjectionPaths(paths2) {
    var _a2;
    if (!isEqual_default((_a2 = queryOptions == null ? void 0 : queryOptions.projection) == null ? void 0 : _a2.paths, paths2)) {
      debug5("changeProjectionPaths", paths2);
      $$invalidate(10, queryOptions = setIn(queryOptions, ["projection", "paths"], paths2, true));
      onChange(queryOptions);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (json2 === void 0 && !("json" in $$props || $$self.$$.bound[$$self.$$.props["json"]])) {
      console.warn("<TransformWizard> was created without expected prop 'json'");
    }
    if (onChange === void 0 && !("onChange" in $$props || $$self.$$.bound[$$self.$$.props["onChange"]])) {
      console.warn("<TransformWizard> was created without expected prop 'onChange'");
    }
  });
  const writable_props = ["json", "queryOptions", "onChange"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TransformWizard> was created with unknown prop '${key}'`);
  });
  function select0_value_binding(value) {
    filterPath2 = value;
    $$invalidate(0, filterPath2);
  }
  function select1_value_binding(value) {
    filterRelation = value;
    $$invalidate(1, filterRelation);
  }
  function input_input_handler() {
    filterValue = this.value;
    $$invalidate(2, filterValue);
  }
  function select2_value_binding(value) {
    sortPath = value;
    $$invalidate(3, sortPath);
  }
  function select3_value_binding(value) {
    sortDirection = value;
    $$invalidate(4, sortDirection);
  }
  function select4_value_binding(value) {
    projectionPaths = value;
    $$invalidate(5, projectionPaths);
  }
  $$self.$$set = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(11, json2 = $$props2.json);
    if ("queryOptions" in $$props2)
      $$invalidate(10, queryOptions = $$props2.queryOptions);
    if ("onChange" in $$props2)
      $$invalidate(12, onChange = $$props2.onChange);
  };
  $$self.$capture_state = () => ({
    Select: Select_default,
    getNestedPaths,
    pathToOption,
    createDebug,
    isEqual: isEqual_default,
    setIn,
    debug: debug5,
    json: json2,
    queryOptions,
    onChange,
    filterRelationOptions,
    sortDirectionOptions,
    filterPath: filterPath2,
    filterRelation,
    filterValue,
    sortPath,
    sortDirection,
    projectionPaths,
    changeFilterPath,
    changeFilterRelation,
    changeFilterValue,
    changeSortPath,
    changeSortDirection,
    changeProjectionPaths,
    fieldOptions,
    fieldPath,
    pathsIncludingObjects,
    projectionOptions,
    paths,
    jsonIsArray
  });
  $$self.$inject_state = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(11, json2 = $$props2.json);
    if ("queryOptions" in $$props2)
      $$invalidate(10, queryOptions = $$props2.queryOptions);
    if ("onChange" in $$props2)
      $$invalidate(12, onChange = $$props2.onChange);
    if ("filterPath" in $$props2)
      $$invalidate(0, filterPath2 = $$props2.filterPath);
    if ("filterRelation" in $$props2)
      $$invalidate(1, filterRelation = $$props2.filterRelation);
    if ("filterValue" in $$props2)
      $$invalidate(2, filterValue = $$props2.filterValue);
    if ("sortPath" in $$props2)
      $$invalidate(3, sortPath = $$props2.sortPath);
    if ("sortDirection" in $$props2)
      $$invalidate(4, sortDirection = $$props2.sortDirection);
    if ("projectionPaths" in $$props2)
      $$invalidate(5, projectionPaths = $$props2.projectionPaths);
    if ("fieldOptions" in $$props2)
      $$invalidate(6, fieldOptions = $$props2.fieldOptions);
    if ("fieldPath" in $$props2)
      fieldPath = $$props2.fieldPath;
    if ("pathsIncludingObjects" in $$props2)
      $$invalidate(13, pathsIncludingObjects = $$props2.pathsIncludingObjects);
    if ("projectionOptions" in $$props2)
      $$invalidate(7, projectionOptions = $$props2.projectionOptions);
    if ("paths" in $$props2)
      $$invalidate(14, paths = $$props2.paths);
    if ("jsonIsArray" in $$props2)
      $$invalidate(15, jsonIsArray = $$props2.jsonIsArray);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a2;
    if ($$self.$$.dirty & 2048) {
      $:
        $$invalidate(15, jsonIsArray = Array.isArray(json2));
    }
    if ($$self.$$.dirty & 34816) {
      $:
        $$invalidate(14, paths = jsonIsArray ? getNestedPaths(json2) : []);
    }
    if ($$self.$$.dirty & 34816) {
      $:
        $$invalidate(13, pathsIncludingObjects = jsonIsArray ? getNestedPaths(json2, true) : []);
    }
    if ($$self.$$.dirty & 16384) {
      $:
        $$invalidate(6, fieldOptions = paths.map(pathToOption));
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(7, projectionOptions = pathsIncludingObjects ? pathsIncludingObjects.map(pathToOption) : []);
    }
    if ($$self.$$.dirty & 1088) {
      $:
        fieldPath = ((_a2 = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _a2.path) ? fieldOptions.find((option) => {
          var _a3;
          return isEqual_default(option.value, (_a3 = queryOptions == null ? void 0 : queryOptions.filter) == null ? void 0 : _a3.path);
        }) : null;
    }
    if ($$self.$$.dirty & 1) {
      $:
        changeFilterPath((filterPath2 == null ? void 0 : filterPath2.value) || null);
    }
    if ($$self.$$.dirty & 2) {
      $:
        changeFilterRelation((filterRelation == null ? void 0 : filterRelation.value) || null);
    }
    if ($$self.$$.dirty & 4) {
      $:
        changeFilterValue(filterValue || null);
    }
    if ($$self.$$.dirty & 8) {
      $:
        changeSortPath((sortPath == null ? void 0 : sortPath.value) || null);
    }
    if ($$self.$$.dirty & 16) {
      $:
        changeSortDirection((sortDirection == null ? void 0 : sortDirection.value) || null);
    }
    if ($$self.$$.dirty & 32) {
      $:
        changeProjectionPaths(projectionPaths ? projectionPaths.map((item) => item.value) : null);
    }
  };
  return [
    filterPath2,
    filterRelation,
    filterValue,
    sortPath,
    sortDirection,
    projectionPaths,
    fieldOptions,
    projectionOptions,
    filterRelationOptions,
    sortDirectionOptions,
    queryOptions,
    json2,
    onChange,
    pathsIncludingObjects,
    paths,
    jsonIsArray,
    select0_value_binding,
    select1_value_binding,
    input_input_handler,
    select2_value_binding,
    select3_value_binding,
    select4_value_binding
  ];
}
var TransformWizard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, not_equal, { json: 11, queryOptions: 10, onChange: 12 }, add_css41);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformWizard",
      options,
      id: create_fragment51.name
    });
  }
  get json() {
    throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set json(value) {
    throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryOptions() {
    throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryOptions(value) {
    throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error("<TransformWizard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error("<TransformWizard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformWizard_default = TransformWizard;

// ../node_modules/svelte-jsoneditor/components/controls/selectQueryLanguage/SelectQueryLanguage.svelte
var file46 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/controls/selectQueryLanguage/SelectQueryLanguage.svelte";
function add_css42(target) {
  append_styles(target, "svelte-tm5b6w", ".jse-select-query-language.svelte-tm5b6w.svelte-tm5b6w{position:relative;width:32px}.jse-select-query-language.svelte-tm5b6w .jse-select-query-language-container.svelte-tm5b6w{position:absolute;top:0;right:0;display:flex;flex-direction:column;box-shadow:var(--jse-controls-box-shadow)}.jse-select-query-language.svelte-tm5b6w .jse-select-query-language-container .jse-query-language.svelte-tm5b6w{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;text-align:left;padding:var(--jse-padding) calc(2 * var(--jse-padding));white-space:nowrap;color:var(--jse-context-menu-color);background:var(--jse-context-menu-background)}.jse-select-query-language.svelte-tm5b6w .jse-select-query-language-container .jse-query-language.svelte-tm5b6w:hover{background:var(--jse-context-menu-background-highlight)}.svelte-tm5b6w.svelte-tm5b6w{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0UXVlcnlMYW5ndWFnZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBZ0N1QywwQkFBQSw0QkFBQSxDQUFBLHMyQkE2QnRDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNlbGVjdFF1ZXJ5TGFuZ3VhZ2Uuc3ZlbHRlIl19 */");
}
function get_each_context17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_else_block15(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faSquare },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(24:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let icon;
  let current;
  icon = new Icon_default({
    props: { data: faCheckSquare },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(icon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(icon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(22:8) {#if queryLanguage.id === queryLanguageId}",
    ctx
  });
  return block;
}
function create_each_block17(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let t0;
  let t1_value = ctx[5].name + "";
  let t1;
  let t2;
  let button_title_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block26, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].id === ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function click_handler() {
    return ctx[4](ctx[5]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      t0 = claim_space(button_nodes);
      t1 = claim_text(button_nodes, t1_value);
      t2 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-query-language svelte-tm5b6w");
      attr_dev(button, "title", button_title_value = `Select ${ctx[5].name} as query language`);
      toggle_class(button, "selected", ctx[5].id === ctx[0]);
      add_location(button, file46, 14, 6, 521);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, t2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, t0);
      }
      if ((!current || dirty & 2) && t1_value !== (t1_value = ctx[5].name + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty & 2 && button_title_value !== (button_title_value = `Select ${ctx[5].name} as query language`)) {
        attr_dev(button, "title", button_title_value);
      }
      if (!current || dirty & 3) {
        toggle_class(button, "selected", ctx[5].id === ctx[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block17.name,
    type: "each",
    source: "(14:4) {#each queryLanguages as queryLanguage}",
    ctx
  });
  return block;
}
function create_fragment52(ctx) {
  let div1;
  let div0;
  let current;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block17(get_each_context17(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-select-query-language-container svelte-tm5b6w");
      add_location(div0, file46, 12, 2, 421);
      attr_dev(div1, "class", "jse-select-query-language svelte-tm5b6w");
      add_location(div1, file46, 11, 0, 379);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context17(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block17(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectQueryLanguage", slots, []);
  let { queryLanguages } = $$props;
  let { queryLanguageId } = $$props;
  let { onChangeQueryLanguage } = $$props;
  function handleChangeQueryLanguage(newQueryLanguageId) {
    $$invalidate(0, queryLanguageId = newQueryLanguageId);
    onChangeQueryLanguage(newQueryLanguageId);
  }
  $$self.$$.on_mount.push(function() {
    if (queryLanguages === void 0 && !("queryLanguages" in $$props || $$self.$$.bound[$$self.$$.props["queryLanguages"]])) {
      console.warn("<SelectQueryLanguage> was created without expected prop 'queryLanguages'");
    }
    if (queryLanguageId === void 0 && !("queryLanguageId" in $$props || $$self.$$.bound[$$self.$$.props["queryLanguageId"]])) {
      console.warn("<SelectQueryLanguage> was created without expected prop 'queryLanguageId'");
    }
    if (onChangeQueryLanguage === void 0 && !("onChangeQueryLanguage" in $$props || $$self.$$.bound[$$self.$$.props["onChangeQueryLanguage"]])) {
      console.warn("<SelectQueryLanguage> was created without expected prop 'onChangeQueryLanguage'");
    }
  });
  const writable_props = ["queryLanguages", "queryLanguageId", "onChangeQueryLanguage"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SelectQueryLanguage> was created with unknown prop '${key}'`);
  });
  const click_handler = (queryLanguage) => handleChangeQueryLanguage(queryLanguage.id);
  $$self.$$set = ($$props2) => {
    if ("queryLanguages" in $$props2)
      $$invalidate(1, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(0, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(3, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
  };
  $$self.$capture_state = () => ({
    Icon: Icon_default,
    faCheckSquare,
    faSquare,
    queryLanguages,
    queryLanguageId,
    onChangeQueryLanguage,
    handleChangeQueryLanguage
  });
  $$self.$inject_state = ($$props2) => {
    if ("queryLanguages" in $$props2)
      $$invalidate(1, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(0, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(3, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    queryLanguageId,
    queryLanguages,
    handleChangeQueryLanguage,
    onChangeQueryLanguage,
    click_handler
  ];
}
var SelectQueryLanguage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance52,
      create_fragment52,
      safe_not_equal,
      {
        queryLanguages: 1,
        queryLanguageId: 0,
        onChangeQueryLanguage: 3
      },
      add_css42
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectQueryLanguage",
      options,
      id: create_fragment52.name
    });
  }
  get queryLanguages() {
    throw new Error("<SelectQueryLanguage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguages(value) {
    throw new Error("<SelectQueryLanguage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryLanguageId() {
    throw new Error("<SelectQueryLanguage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguageId(value) {
    throw new Error("<SelectQueryLanguage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChangeQueryLanguage() {
    throw new Error("<SelectQueryLanguage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChangeQueryLanguage(value) {
    throw new Error("<SelectQueryLanguage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectQueryLanguage_default = SelectQueryLanguage;

// ../node_modules/svelte-jsoneditor/components/modals/TransformModalHeader.svelte
var file47 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/TransformModalHeader.svelte";
function add_css43(target) {
  append_styles(target, "svelte-hwcgwi", ".jse-header.svelte-hwcgwi.svelte-hwcgwi{display:flex;background:var(--jse-theme-color);color:var(--jse-menu-color)}.jse-header.svelte-hwcgwi .jse-title.svelte-hwcgwi{flex:1;padding:5px;vertical-align:middle}.jse-header.svelte-hwcgwi button.svelte-hwcgwi{border:none;background:transparent;min-width:32px;color:inherit;cursor:pointer}.jse-header.svelte-hwcgwi button.svelte-hwcgwi:hover{background:rgba(255, 255, 255, 0.1)}.svelte-hwcgwi.svelte-hwcgwi{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNmb3JtTW9kYWxIZWFkZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtEMEIsV0FBQSw0QkFBQSxDQUFBLDRaQW1CekIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVHJhbnNmb3JtTW9kYWxIZWFkZXIuc3ZlbHRlIl19 */");
}
function create_if_block27(ctx) {
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faCog }, $$inline: true });
  const block = {
    c: function create() {
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true, title: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-config svelte-hwcgwi");
      attr_dev(button, "title", "Select a query language");
      add_location(button, file47, 35, 4, 1151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(icon, button, null);
      ctx[6](button);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[3], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(icon);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(35:2) {#if queryLanguages.length > 1}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let button;
  let icon;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0].length > 1 && create_if_block27(ctx);
  icon = new Icon_default({ props: { data: faTimes }, $$inline: true });
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text("Transform");
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      button = element("button");
      create_component(icon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "Transform");
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-title svelte-hwcgwi");
      add_location(div0, file47, 33, 2, 1074);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-close svelte-hwcgwi");
      add_location(button, file47, 45, 2, 1362);
      attr_dev(div1, "class", "jse-header svelte-hwcgwi");
      add_location(div1, file47, 32, 0, 1047);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, button);
      mount_component(icon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[2], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0].length > 1) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformModalHeader", slots, []);
  let { queryLanguages } = $$props;
  let { queryLanguageId } = $$props;
  let { onChangeQueryLanguage } = $$props;
  let refConfigButton;
  let popupId;
  const { close } = getContext("simple-modal");
  const { openAbsolutePopup, closeAbsolutePopup } = getContext("absolute-popup");
  function openConfig() {
    const props = {
      queryLanguages,
      queryLanguageId,
      onChangeQueryLanguage: (selectedQueryLanguage) => {
        closeAbsolutePopup(popupId);
        onChangeQueryLanguage(selectedQueryLanguage);
      }
    };
    popupId = openAbsolutePopup(SelectQueryLanguage_default, props, {
      position: "bottom",
      offsetTop: -2,
      offsetLeft: 0,
      anchor: refConfigButton,
      closeOnOuterClick: true
    });
  }
  $$self.$$.on_mount.push(function() {
    if (queryLanguages === void 0 && !("queryLanguages" in $$props || $$self.$$.bound[$$self.$$.props["queryLanguages"]])) {
      console.warn("<TransformModalHeader> was created without expected prop 'queryLanguages'");
    }
    if (queryLanguageId === void 0 && !("queryLanguageId" in $$props || $$self.$$.bound[$$self.$$.props["queryLanguageId"]])) {
      console.warn("<TransformModalHeader> was created without expected prop 'queryLanguageId'");
    }
    if (onChangeQueryLanguage === void 0 && !("onChangeQueryLanguage" in $$props || $$self.$$.bound[$$self.$$.props["onChangeQueryLanguage"]])) {
      console.warn("<TransformModalHeader> was created without expected prop 'onChangeQueryLanguage'");
    }
  });
  const writable_props = ["queryLanguages", "queryLanguageId", "onChangeQueryLanguage"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TransformModalHeader> was created with unknown prop '${key}'`);
  });
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refConfigButton = $$value;
      $$invalidate(1, refConfigButton);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("queryLanguages" in $$props2)
      $$invalidate(0, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(4, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(5, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
  };
  $$self.$capture_state = () => ({
    getContext,
    Icon: Icon_default,
    faCog,
    faTimes,
    SelectQueryLanguage: SelectQueryLanguage_default,
    queryLanguages,
    queryLanguageId,
    onChangeQueryLanguage,
    refConfigButton,
    popupId,
    close,
    openAbsolutePopup,
    closeAbsolutePopup,
    openConfig
  });
  $$self.$inject_state = ($$props2) => {
    if ("queryLanguages" in $$props2)
      $$invalidate(0, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(4, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(5, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
    if ("refConfigButton" in $$props2)
      $$invalidate(1, refConfigButton = $$props2.refConfigButton);
    if ("popupId" in $$props2)
      popupId = $$props2.popupId;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    queryLanguages,
    refConfigButton,
    close,
    openConfig,
    queryLanguageId,
    onChangeQueryLanguage,
    button_binding
  ];
}
var TransformModalHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance53,
      create_fragment53,
      not_equal,
      {
        queryLanguages: 0,
        queryLanguageId: 4,
        onChangeQueryLanguage: 5
      },
      add_css43
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformModalHeader",
      options,
      id: create_fragment53.name
    });
  }
  get queryLanguages() {
    throw new Error("<TransformModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguages(value) {
    throw new Error("<TransformModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryLanguageId() {
    throw new Error("<TransformModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguageId(value) {
    throw new Error("<TransformModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChangeQueryLanguage() {
    throw new Error("<TransformModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChangeQueryLanguage(value) {
    throw new Error("<TransformModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformModalHeader_default = TransformModalHeader;

// ../node_modules/svelte-jsoneditor/components/modals/TransformModal.svelte
var { console: console_14 } = globals;
var file48 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/TransformModal.svelte";
function add_css44(target) {
  append_styles(target, "svelte-1612ba0", ".jse-modal.svelte-1612ba0.svelte-1612ba0{--height:36px;--multiItemHeight:28px;--multiItemMargin:2px;--multiItemPadding:2px 8px;--multiClearTop:5px;--multiItemBorderRadius:6px;--clearSelectTop:2px;--clearSelectBottom:2px;--indicatorTop:8px;flex:1;display:flex;flex-direction:column;font-family:var(--jse-font-family);font-size:var(--jse-font-size);line-height:normal;background:var(--jse-modal-background);color:var(--jse-text-color)}.jse-modal.svelte-1612ba0 .jse-contents.svelte-1612ba0{padding:20px;overflow:auto}.jse-modal.svelte-1612ba0 .jse-contents .jse-actions.svelte-1612ba0{display:flex;flex-direction:row;justify-content:flex-end;padding-top:var(--jse-padding)}.jse-modal.svelte-1612ba0 .jse-contents .jse-actions button.svelte-1612ba0{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;background:var(--jse-button-primary-background);color:var(--jse-button-primary-color);padding:var(--jse-padding) calc(2 * var(--jse-padding));border-radius:3px}.jse-modal.svelte-1612ba0 .jse-contents .jse-actions button.svelte-1612ba0:hover{background:var(--jse-button-primary-background-highlight)}.jse-modal.svelte-1612ba0 .jse-contents .jse-actions button.svelte-1612ba0:disabled{background:var(--jse-button-primary-background-disabled)}.bg.jse-modal-bg{width:100%;height:100%;top:0;left:0;background:var(--jse-modal-overlay-background)}.bg.jse-modal-bg .jse-modal-window-wrap{margin:0}.bg.jse-modal-bg .jse-modal-window{max-width:90%;margin:4rem auto 2rem auto;border-radius:2px}.bg.jse-modal-bg .jse-modal-window.jse-modal-window-sort{width:400px}.bg.jse-modal-bg .jse-modal-window.jse-modal-window-transform{width:1200px;height:1200px;max-height:80%;display:flex}.bg.jse-modal-bg .jse-modal-content{flex:1;display:flex;max-height:calc(100vh - 6rem);padding:0}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents.svelte-1612ba0{flex:1;display:flex;flex-direction:column;color:inherit;min-height:0;padding:0}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents.svelte-1612ba0{flex:1;display:flex;gap:calc(2 * var(--jse-padding));min-height:0;box-sizing:border-box;padding:0 calc(2 * var(--jse-padding)) var(--jse-padding)}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-query-contents.svelte-1612ba0{flex:1;display:flex;flex-direction:column}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-query-contents .jse-description.svelte-1612ba0 p{margin:var(--jse-padding) 0}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-query-contents .jse-description.svelte-1612ba0 p:first-child{margin-top:0}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-query-contents .jse-description.svelte-1612ba0 p:last-child{margin-bottom:0}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-query-contents .jse-description.svelte-1612ba0 code{background:var(--jse-modal-code-background);font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono)}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-query-contents textarea.jse-query.svelte-1612ba0{flex:1;outline:none;resize:vertical}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-data-contents.svelte-1612ba0{flex:1;display:flex;flex-direction:column;gap:calc(2 * var(--jse-padding))}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-data-contents .jse-original-data.svelte-1612ba0{flex:1;display:flex;flex-direction:column;min-height:0;box-sizing:border-box}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-data-contents .jse-original-data.jse-hide.svelte-1612ba0{flex:none}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-data-contents .jse-preview-data.svelte-1612ba0{flex:1;display:flex;flex-direction:column;min-height:0;box-sizing:border-box}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-data-contents.jse-hide-original-data.svelte-1612ba0{flex-direction:column;gap:0;margin-bottom:0}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-actions.svelte-1612ba0{padding:var(--jse-padding) calc(2 * var(--jse-padding)) calc(2 * var(--jse-padding))}@media screen and (max-width: 1200px){.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents.svelte-1612ba0{flex-direction:column;overflow:auto}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-query-contents textarea.jse-query.svelte-1612ba0{min-height:150px;flex:none}.jse-modal.jse-transform.svelte-1612ba0 .jse-contents .jse-main-contents .jse-data-contents.svelte-1612ba0 .jse-tree-mode{height:300px;flex:none}}.jse-modal.jse-transform.svelte-1612ba0 .jse-label.svelte-1612ba0{font-weight:bold;display:block;box-sizing:border-box}.jse-modal.jse-transform.svelte-1612ba0 .jse-label .jse-label-inner.svelte-1612ba0{margin-top:calc(2 * var(--jse-padding));margin-bottom:calc(0.5 * var(--jse-padding));box-sizing:border-box}.jse-modal.jse-transform.svelte-1612ba0 .jse-label .jse-label-inner button.svelte-1612ba0{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;font-weight:bold;padding:0}.jse-modal.jse-transform.svelte-1612ba0 .jse-tree-mode{flex:1;background:var(--jse-input-background-readonly);box-shadow:none;box-sizing:border-box;--jse-main-border:var(--jse-input-border)}.jse-modal.jse-transform.svelte-1612ba0 input.svelte-1612ba0,.jse-modal.jse-transform.svelte-1612ba0 textarea.svelte-1612ba0{border:var(--jse-input-border);outline:none;box-sizing:border-box;padding:calc(0.5 * var(--jse-padding));font-family:var(--jse-font-family-mono);font-size:var(--jse-font-size-mono);color:inherit;background:var(--jse-input-background)}.jse-modal.jse-transform.svelte-1612ba0 input.svelte-1612ba0:focus,.jse-modal.jse-transform.svelte-1612ba0 textarea.svelte-1612ba0:focus{border:var(--jse-input-border-focus)}.jse-modal.jse-transform.svelte-1612ba0 input.svelte-1612ba0:read-only,.jse-modal.jse-transform.svelte-1612ba0 textarea.svelte-1612ba0:read-only{background:var(--jse-input-background-readonly)}.jse-modal.jse-transform.svelte-1612ba0 .jse-preview.jse-error.svelte-1612ba0{flex:1;background:var(--jse-input-background-readonly);border:var(--jse-input-border);color:var(--jse-error-color);padding:calc(0.5 * var(--jse-padding))}.jse-modal.jse-transform.svelte-1612ba0 a{color:var(--jse-a-color)}.jse-modal.jse-transform.svelte-1612ba0 a:hover{color:var(--jse-a-color-highlight)}.svelte-1612ba0.svelte-1612ba0{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNmb3JtTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdRa0MsVUFBQSw4QkFBQSxDQUFBLDZnTkF1T2pDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRyYW5zZm9ybU1vZGFsLnN2ZWx0ZSJdfQ== */");
}
function create_if_block_213(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_39, create_else_block_15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & 1024)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(ctx2[10]);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(171:10) {#if showWizard}",
    ctx
  });
  return block;
}
function create_else_block_15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(Only available for arrays, not for objects)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(Only available for arrays, not for objects)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_15.name,
    type: "else",
    source: "(174:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_39(ctx) {
  let transformwizard;
  let current;
  transformwizard = new TransformWizard_default({
    props: {
      queryOptions: ctx[8],
      json: ctx[10],
      onChange: ctx[17]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(transformwizard.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(transformwizard.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(transformwizard, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transformwizard_changes = {};
      if (dirty[0] & 256)
        transformwizard_changes.queryOptions = ctx2[8];
      if (dirty[0] & 1024)
        transformwizard_changes.json = ctx2[10];
      transformwizard.$set(transformwizard_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(transformwizard.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(transformwizard.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(transformwizard, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_39.name,
    type: "if",
    source: "(172:12) {#if Array.isArray(selectedJson)}",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let treemode;
  let current;
  treemode = new TreeMode_default({
    props: {
      externalContent: ctx[15],
      readOnly: true,
      mainMenuBar: false,
      navigationBar: false,
      escapeControlCharacters: ctx[2],
      escapeUnicodeCharacters: ctx[3],
      parser: ctx[4],
      onRenderValue: ctx[6],
      onError: console.error,
      onChange: noop_default,
      onFocus: noop_default,
      onBlur: noop_default,
      onSortModal: noop_default,
      onTransformModal: noop_default,
      onClassName: ctx[7]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treemode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treemode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treemode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treemode_changes = {};
      if (dirty[0] & 32768)
        treemode_changes.externalContent = ctx2[15];
      if (dirty[0] & 4)
        treemode_changes.escapeControlCharacters = ctx2[2];
      if (dirty[0] & 8)
        treemode_changes.escapeUnicodeCharacters = ctx2[3];
      if (dirty[0] & 16)
        treemode_changes.parser = ctx2[4];
      if (dirty[0] & 64)
        treemode_changes.onRenderValue = ctx2[6];
      if (dirty[0] & 128)
        treemode_changes.onClassName = ctx2[7];
      treemode.$set(treemode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treemode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treemode.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(treemode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(199:12) {#if showOriginal}",
    ctx
  });
  return block;
}
function create_else_block16(ctx) {
  let div;
  let t_value = ctx[13].toString() + "";
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-preview jse-error svelte-1612ba0");
      add_location(div, file48, 241, 14, 8693);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8192 && t_value !== (t_value = ctx2[13].toString() + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(241:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block28(ctx) {
  let treemode;
  let current;
  treemode = new TreeMode_default({
    props: {
      externalContent: ctx[14],
      readOnly: true,
      mainMenuBar: false,
      navigationBar: false,
      escapeControlCharacters: ctx[2],
      escapeUnicodeCharacters: ctx[3],
      parser: ctx[4],
      onRenderValue: ctx[6],
      onError: console.error,
      onChange: noop_default,
      onFocus: noop_default,
      onBlur: noop_default,
      onSortModal: noop_default,
      onTransformModal: noop_default,
      onClassName: ctx[7]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treemode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treemode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treemode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treemode_changes = {};
      if (dirty[0] & 16384)
        treemode_changes.externalContent = ctx2[14];
      if (dirty[0] & 4)
        treemode_changes.escapeControlCharacters = ctx2[2];
      if (dirty[0] & 8)
        treemode_changes.escapeUnicodeCharacters = ctx2[3];
      if (dirty[0] & 16)
        treemode_changes.parser = ctx2[4];
      if (dirty[0] & 64)
        treemode_changes.onRenderValue = ctx2[6];
      if (dirty[0] & 128)
        treemode_changes.onClassName = ctx2[7];
      treemode.$set(treemode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treemode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treemode.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(treemode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(223:12) {#if !previewError}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let transformmodalheader;
  let t0;
  let div19;
  let div17;
  let div9;
  let div1;
  let div0;
  let t1;
  let t2;
  let div2;
  let raw_value = ctx[16](ctx[0]).description + "";
  let t3;
  let div4;
  let div3;
  let t4;
  let t5;
  let input;
  let input_value_value;
  let t6;
  let div6;
  let div5;
  let button0;
  let icon0;
  let t7;
  let t8;
  let t9;
  let div8;
  let div7;
  let t10;
  let t11;
  let textarea;
  let t12;
  let div16;
  let div12;
  let div11;
  let div10;
  let button1;
  let icon1;
  let t13;
  let t14;
  let t15;
  let div15;
  let div14;
  let div13;
  let t16;
  let t17;
  let current_block_type_index;
  let if_block2;
  let t18;
  let div18;
  let button2;
  let t19;
  let button2_disabled_value;
  let focus_action;
  let current;
  let mounted;
  let dispose;
  transformmodalheader = new TransformModalHeader_default({
    props: {
      queryLanguages: ctx[5],
      queryLanguageId: ctx[0],
      onChangeQueryLanguage: ctx[22]
    },
    $$inline: true
  });
  icon0 = new Icon_default({
    props: {
      data: ctx[11] ? faCaretDown : faCaretRight
    },
    $$inline: true
  });
  let if_block0 = ctx[11] && create_if_block_213(ctx);
  icon1 = new Icon_default({
    props: {
      data: ctx[12] ? faCaretDown : faCaretRight
    },
    $$inline: true
  });
  let if_block1 = ctx[12] && create_if_block_116(ctx);
  const if_block_creators = [create_if_block28, create_else_block16];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[13])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      create_component(transformmodalheader.$$.fragment);
      t0 = space();
      div19 = element("div");
      div17 = element("div");
      div9 = element("div");
      div1 = element("div");
      div0 = element("div");
      t1 = text("Language");
      t2 = space();
      div2 = element("div");
      t3 = space();
      div4 = element("div");
      div3 = element("div");
      t4 = text("Path");
      t5 = space();
      input = element("input");
      t6 = space();
      div6 = element("div");
      div5 = element("div");
      button0 = element("button");
      create_component(icon0.$$.fragment);
      t7 = text("\n                Wizard");
      t8 = space();
      if (if_block0)
        if_block0.c();
      t9 = space();
      div8 = element("div");
      div7 = element("div");
      t10 = text("Query");
      t11 = space();
      textarea = element("textarea");
      t12 = space();
      div16 = element("div");
      div12 = element("div");
      div11 = element("div");
      div10 = element("div");
      button1 = element("button");
      create_component(icon1.$$.fragment);
      t13 = text("\n                  Original");
      t14 = space();
      if (if_block1)
        if_block1.c();
      t15 = space();
      div15 = element("div");
      div14 = element("div");
      div13 = element("div");
      t16 = text("Preview");
      t17 = space();
      if_block2.c();
      t18 = space();
      div18 = element("div");
      button2 = element("button");
      t19 = text("Transform");
      this.h();
    },
    l: function claim(nodes) {
      claim_component(transformmodalheader.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div19 = claim_element(nodes, "DIV", { class: true });
      var div19_nodes = children(div19);
      div17 = claim_element(div19_nodes, "DIV", { class: true });
      var div17_nodes = children(div17);
      div9 = claim_element(div17_nodes, "DIV", { class: true });
      var div9_nodes = children(div9);
      div1 = claim_element(div9_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Language");
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div9_nodes);
      div2 = claim_element(div9_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div2_nodes.forEach(detach_dev);
      t3 = claim_space(div9_nodes);
      div4 = claim_element(div9_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      t4 = claim_text(div3_nodes, "Path");
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t5 = claim_space(div9_nodes);
      input = claim_element(div9_nodes, "INPUT", { class: true, type: true, title: true });
      t6 = claim_space(div9_nodes);
      div6 = claim_element(div9_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      button0 = claim_element(div5_nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      claim_component(icon0.$$.fragment, button0_nodes);
      t7 = claim_text(button0_nodes, "\n                Wizard");
      button0_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      div6_nodes.forEach(detach_dev);
      t8 = claim_space(div9_nodes);
      if (if_block0)
        if_block0.l(div9_nodes);
      t9 = claim_space(div9_nodes);
      div8 = claim_element(div9_nodes, "DIV", { class: true });
      var div8_nodes = children(div8);
      div7 = claim_element(div8_nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      t10 = claim_text(div7_nodes, "Query");
      div7_nodes.forEach(detach_dev);
      div8_nodes.forEach(detach_dev);
      t11 = claim_space(div9_nodes);
      textarea = claim_element(div9_nodes, "TEXTAREA", { class: true, spellcheck: true });
      children(textarea).forEach(detach_dev);
      div9_nodes.forEach(detach_dev);
      t12 = claim_space(div17_nodes);
      div16 = claim_element(div17_nodes, "DIV", { class: true });
      var div16_nodes = children(div16);
      div12 = claim_element(div16_nodes, "DIV", { class: true });
      var div12_nodes = children(div12);
      div11 = claim_element(div12_nodes, "DIV", { class: true });
      var div11_nodes = children(div11);
      div10 = claim_element(div11_nodes, "DIV", { class: true });
      var div10_nodes = children(div10);
      button1 = claim_element(div10_nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      claim_component(icon1.$$.fragment, button1_nodes);
      t13 = claim_text(button1_nodes, "\n                  Original");
      button1_nodes.forEach(detach_dev);
      div10_nodes.forEach(detach_dev);
      div11_nodes.forEach(detach_dev);
      t14 = claim_space(div12_nodes);
      if (if_block1)
        if_block1.l(div12_nodes);
      div12_nodes.forEach(detach_dev);
      t15 = claim_space(div16_nodes);
      div15 = claim_element(div16_nodes, "DIV", { class: true });
      var div15_nodes = children(div15);
      div14 = claim_element(div15_nodes, "DIV", { class: true });
      var div14_nodes = children(div14);
      div13 = claim_element(div14_nodes, "DIV", { class: true });
      var div13_nodes = children(div13);
      t16 = claim_text(div13_nodes, "Preview");
      div13_nodes.forEach(detach_dev);
      div14_nodes.forEach(detach_dev);
      t17 = claim_space(div15_nodes);
      if_block2.l(div15_nodes);
      div15_nodes.forEach(detach_dev);
      div16_nodes.forEach(detach_dev);
      div17_nodes.forEach(detach_dev);
      t18 = claim_space(div19_nodes);
      div18 = claim_element(div19_nodes, "DIV", { class: true });
      var div18_nodes = children(div18);
      button2 = claim_element(div18_nodes, "BUTTON", { type: true, class: true });
      var button2_nodes = children(button2);
      t19 = claim_text(button2_nodes, "Transform");
      button2_nodes.forEach(detach_dev);
      div18_nodes.forEach(detach_dev);
      div19_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "jse-label-inner svelte-1612ba0");
      add_location(div0, file48, 143, 12, 5340);
      attr_dev(div1, "class", "jse-label svelte-1612ba0");
      add_location(div1, file48, 142, 10, 5304);
      attr_dev(div2, "class", "jse-description svelte-1612ba0");
      add_location(div2, file48, 145, 10, 5411);
      attr_dev(div3, "class", "jse-label-inner svelte-1612ba0");
      add_location(div3, file48, 150, 12, 5579);
      attr_dev(div4, "class", "jse-label svelte-1612ba0");
      add_location(div4, file48, 149, 10, 5543);
      attr_dev(input, "class", "jse-path svelte-1612ba0");
      attr_dev(input, "type", "text");
      input.readOnly = true;
      attr_dev(input, "title", "Selected path");
      input.value = input_value_value = !isEmpty_default(ctx[1]) ? stripRootObject(stringifyJSONPath(ctx[1])) : "(whole document)";
      add_location(input, file48, 152, 10, 5646);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "svelte-1612ba0");
      add_location(button0, file48, 164, 14, 6008);
      attr_dev(div5, "class", "jse-label-inner svelte-1612ba0");
      add_location(div5, file48, 163, 12, 5964);
      attr_dev(div6, "class", "jse-label svelte-1612ba0");
      add_location(div6, file48, 162, 10, 5928);
      attr_dev(div7, "class", "jse-label-inner svelte-1612ba0");
      add_location(div7, file48, 179, 12, 6547);
      attr_dev(div8, "class", "jse-label svelte-1612ba0");
      add_location(div8, file48, 178, 10, 6511);
      attr_dev(textarea, "class", "jse-query svelte-1612ba0");
      attr_dev(textarea, "spellcheck", "false");
      textarea.value = ctx[9];
      add_location(textarea, file48, 181, 10, 6615);
      attr_dev(div9, "class", "jse-query-contents svelte-1612ba0");
      add_location(div9, file48, 141, 8, 5261);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", "svelte-1612ba0");
      add_location(button1, file48, 192, 16, 7035);
      attr_dev(div10, "class", "jse-label-inner svelte-1612ba0");
      add_location(div10, file48, 191, 14, 6989);
      attr_dev(div11, "class", "jse-label svelte-1612ba0");
      add_location(div11, file48, 190, 12, 6951);
      attr_dev(div12, "class", "jse-original-data svelte-1612ba0");
      toggle_class(div12, "jse-hide", !ctx[12]);
      add_location(div12, file48, 189, 10, 6876);
      attr_dev(div13, "class", "jse-label-inner svelte-1612ba0");
      add_location(div13, file48, 220, 14, 7990);
      attr_dev(div14, "class", "jse-label svelte-1612ba0");
      add_location(div14, file48, 219, 12, 7952);
      attr_dev(div15, "class", "jse-preview-data svelte-1612ba0");
      add_location(div15, file48, 218, 10, 7909);
      attr_dev(div16, "class", "jse-data-contents svelte-1612ba0");
      toggle_class(div16, "jse-hide-original-data", !ctx[12]);
      add_location(div16, file48, 188, 8, 6789);
      attr_dev(div17, "class", "jse-main-contents svelte-1612ba0");
      add_location(div17, file48, 140, 6, 5221);
      attr_dev(button2, "type", "button");
      attr_dev(button2, "class", "jse-primary svelte-1612ba0");
      button2.disabled = button2_disabled_value = !!ctx[13];
      add_location(button2, file48, 250, 8, 8896);
      attr_dev(div18, "class", "jse-actions svelte-1612ba0");
      add_location(div18, file48, 249, 6, 8862);
      attr_dev(div19, "class", "jse-contents svelte-1612ba0");
      add_location(div19, file48, 139, 4, 5188);
    },
    m: function mount(target, anchor) {
      mount_component(transformmodalheader, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div19, anchor);
      append_hydration_dev(div19, div17);
      append_hydration_dev(div17, div9);
      append_hydration_dev(div9, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div9, t2);
      append_hydration_dev(div9, div2);
      div2.innerHTML = raw_value;
      append_hydration_dev(div9, t3);
      append_hydration_dev(div9, div4);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, t4);
      append_hydration_dev(div9, t5);
      append_hydration_dev(div9, input);
      append_hydration_dev(div9, t6);
      append_hydration_dev(div9, div6);
      append_hydration_dev(div6, div5);
      append_hydration_dev(div5, button0);
      mount_component(icon0, button0, null);
      append_hydration_dev(button0, t7);
      append_hydration_dev(div9, t8);
      if (if_block0)
        if_block0.m(div9, null);
      append_hydration_dev(div9, t9);
      append_hydration_dev(div9, div8);
      append_hydration_dev(div8, div7);
      append_hydration_dev(div7, t10);
      append_hydration_dev(div9, t11);
      append_hydration_dev(div9, textarea);
      append_hydration_dev(div17, t12);
      append_hydration_dev(div17, div16);
      append_hydration_dev(div16, div12);
      append_hydration_dev(div12, div11);
      append_hydration_dev(div11, div10);
      append_hydration_dev(div10, button1);
      mount_component(icon1, button1, null);
      append_hydration_dev(button1, t13);
      append_hydration_dev(div12, t14);
      if (if_block1)
        if_block1.m(div12, null);
      append_hydration_dev(div16, t15);
      append_hydration_dev(div16, div15);
      append_hydration_dev(div15, div14);
      append_hydration_dev(div14, div13);
      append_hydration_dev(div13, t16);
      append_hydration_dev(div15, t17);
      if_blocks[current_block_type_index].m(div15, null);
      append_hydration_dev(div19, t18);
      append_hydration_dev(div19, div18);
      append_hydration_dev(div18, button2);
      append_hydration_dev(button2, t19);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", ctx[20], false, false, false),
          listen_dev(textarea, "input", ctx[18], false, false, false),
          listen_dev(button1, "click", ctx[21], false, false, false),
          listen_dev(button2, "click", ctx[19], false, false, false),
          action_destroyer(focus_action = focus.call(null, button2))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const transformmodalheader_changes = {};
      if (dirty[0] & 32)
        transformmodalheader_changes.queryLanguages = ctx2[5];
      if (dirty[0] & 1)
        transformmodalheader_changes.queryLanguageId = ctx2[0];
      transformmodalheader.$set(transformmodalheader_changes);
      if ((!current || dirty[0] & 1) && raw_value !== (raw_value = ctx2[16](ctx2[0]).description + ""))
        div2.innerHTML = raw_value;
      ;
      if (!current || dirty[0] & 2 && input_value_value !== (input_value_value = !isEmpty_default(ctx2[1]) ? stripRootObject(stringifyJSONPath(ctx2[1])) : "(whole document)") && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      const icon0_changes = {};
      if (dirty[0] & 2048)
        icon0_changes.data = ctx2[11] ? faCaretDown : faCaretRight;
      icon0.$set(icon0_changes);
      if (ctx2[11]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_213(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div9, t9);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 512) {
        prop_dev(textarea, "value", ctx2[9]);
      }
      const icon1_changes = {};
      if (dirty[0] & 4096)
        icon1_changes.data = ctx2[12] ? faCaretDown : faCaretRight;
      icon1.$set(icon1_changes);
      if (ctx2[12]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_116(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div12, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 4096) {
        toggle_class(div12, "jse-hide", !ctx2[12]);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div15, null);
      }
      if (!current || dirty[0] & 4096) {
        toggle_class(div16, "jse-hide-original-data", !ctx2[12]);
      }
      if (!current || dirty[0] & 8192 && button2_disabled_value !== (button2_disabled_value = !!ctx2[13])) {
        prop_dev(button2, "disabled", button2_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(transformmodalheader.$$.fragment, local);
      transition_in(icon0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(icon1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(transformmodalheader.$$.fragment, local);
      transition_out(icon0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(icon1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(transformmodalheader, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div19);
      destroy_component(icon0);
      if (if_block0)
        if_block0.d();
      destroy_component(icon1);
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(134:2) <AbsolutePopup>",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let div;
  let absolutepopup;
  let current;
  absolutepopup = new AbsolutePopup_default({
    props: {
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(absolutepopup.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(absolutepopup.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-modal jse-transform svelte-1612ba0");
      add_location(div, file48, 132, 0, 4992);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(absolutepopup, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const absolutepopup_changes = {};
      if (dirty[0] & 65535 | dirty[1] & 16) {
        absolutepopup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      absolutepopup.$set(absolutepopup_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(absolutepopup.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(absolutepopup.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(absolutepopup);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function focus(element2) {
  element2.focus();
}
function instance54($$self, $$props, $$invalidate) {
  let selectedJson;
  let selectedContent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformModal", slots, []);
  const debug5 = createDebug("jsoneditor:TransformModal");
  let { id: id2 = "transform-modal-" + uniqueId() } = $$props;
  let { json: json2 } = $$props;
  let { selectedPath = [] } = $$props;
  let { escapeControlCharacters } = $$props;
  let { escapeUnicodeCharacters } = $$props;
  let { parser } = $$props;
  let { queryLanguages } = $$props;
  let { queryLanguageId } = $$props;
  let { onChangeQueryLanguage } = $$props;
  let { onRenderValue } = $$props;
  let { onClassName } = $$props;
  let { onTransform } = $$props;
  const { close } = getContext("simple-modal");
  const stateId = `${id2}:${compileJSONPointer(selectedPath)}`;
  const state = transformModalState[stateId] || {};
  let showWizard = transformModalState.showWizard !== false;
  let showOriginal = transformModalState.showOriginal !== false;
  let queryOptions = state.queryOptions || {};
  let query = queryLanguageId === state.queryLanguageId && state.query ? state.query : getSelectedQueryLanguage(queryLanguageId).createQuery(json2, state.queryOptions || {});
  let isManual = state.isManual || false;
  let previewError = void 0;
  let previewContent = { text: "" };
  function getSelectedQueryLanguage(queryLanguageId2) {
    return queryLanguages.find((item) => item.id === queryLanguageId2) || queryLanguages[0];
  }
  function updateQueryByWizard(newQueryOptions) {
    $$invalidate(8, queryOptions = newQueryOptions);
    $$invalidate(9, query = getSelectedQueryLanguage(queryLanguageId).createQuery(json2, newQueryOptions));
    $$invalidate(28, isManual = false);
    debug5("updateQueryByWizard", { queryOptions, query, isManual });
  }
  function handleChangeQuery(event) {
    $$invalidate(9, query = event.target.value);
    $$invalidate(28, isManual = true);
    debug5("handleChangeQuery", { query, isManual });
  }
  function previewTransform(json3, query2) {
    try {
      debug5("previewTransform", { query: query2 });
      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(json3, query2);
      $$invalidate(14, previewContent = { json: jsonTransformed });
      $$invalidate(13, previewError = void 0);
    } catch (err) {
      $$invalidate(14, previewContent = { text: "" });
      $$invalidate(13, previewError = err);
    }
  }
  const previewTransformDebounced = debounce_default(previewTransform, DEBOUNCE_DELAY);
  function handleTransform() {
    try {
      debug5("handleTransform", { query });
      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(selectedJson, query);
      onTransform([
        {
          op: "replace",
          path: compileJSONPointer(selectedPath),
          value: jsonTransformed
        }
      ]);
      close();
    } catch (err) {
      console.error(err);
      $$invalidate(14, previewContent = { text: "" });
      $$invalidate(13, previewError = err.toString());
    }
  }
  function toggleShowWizard() {
    $$invalidate(11, showWizard = !showWizard);
    $$invalidate(27, transformModalState.showWizard = showWizard, transformModalState);
  }
  function toggleShowOriginal() {
    $$invalidate(12, showOriginal = !showOriginal);
    $$invalidate(27, transformModalState.showOriginal = showOriginal, transformModalState);
  }
  function handleChangeQueryLanguage(newQueryLanguageId) {
    debug5("handleChangeQueryLanguage", newQueryLanguageId);
    $$invalidate(0, queryLanguageId = newQueryLanguageId);
    onChangeQueryLanguage(newQueryLanguageId);
    const newSelectedQueryLanguage = getSelectedQueryLanguage(queryLanguageId);
    $$invalidate(9, query = newSelectedQueryLanguage.createQuery(json2, queryOptions));
    $$invalidate(28, isManual = false);
  }
  $$self.$$.on_mount.push(function() {
    if (json2 === void 0 && !("json" in $$props || $$self.$$.bound[$$self.$$.props["json"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'json'");
    }
    if (escapeControlCharacters === void 0 && !("escapeControlCharacters" in $$props || $$self.$$.bound[$$self.$$.props["escapeControlCharacters"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'escapeControlCharacters'");
    }
    if (escapeUnicodeCharacters === void 0 && !("escapeUnicodeCharacters" in $$props || $$self.$$.bound[$$self.$$.props["escapeUnicodeCharacters"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'escapeUnicodeCharacters'");
    }
    if (parser === void 0 && !("parser" in $$props || $$self.$$.bound[$$self.$$.props["parser"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'parser'");
    }
    if (queryLanguages === void 0 && !("queryLanguages" in $$props || $$self.$$.bound[$$self.$$.props["queryLanguages"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'queryLanguages'");
    }
    if (queryLanguageId === void 0 && !("queryLanguageId" in $$props || $$self.$$.bound[$$self.$$.props["queryLanguageId"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'queryLanguageId'");
    }
    if (onChangeQueryLanguage === void 0 && !("onChangeQueryLanguage" in $$props || $$self.$$.bound[$$self.$$.props["onChangeQueryLanguage"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'onChangeQueryLanguage'");
    }
    if (onRenderValue === void 0 && !("onRenderValue" in $$props || $$self.$$.bound[$$self.$$.props["onRenderValue"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'onRenderValue'");
    }
    if (onClassName === void 0 && !("onClassName" in $$props || $$self.$$.bound[$$self.$$.props["onClassName"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'onClassName'");
    }
    if (onTransform === void 0 && !("onTransform" in $$props || $$self.$$.bound[$$self.$$.props["onTransform"]])) {
      console_14.warn("<TransformModal> was created without expected prop 'onTransform'");
    }
  });
  const writable_props = [
    "id",
    "json",
    "selectedPath",
    "escapeControlCharacters",
    "escapeUnicodeCharacters",
    "parser",
    "queryLanguages",
    "queryLanguageId",
    "onChangeQueryLanguage",
    "onRenderValue",
    "onClassName",
    "onTransform"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_14.warn(`<TransformModal> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(23, id2 = $$props2.id);
    if ("json" in $$props2)
      $$invalidate(24, json2 = $$props2.json);
    if ("selectedPath" in $$props2)
      $$invalidate(1, selectedPath = $$props2.selectedPath);
    if ("escapeControlCharacters" in $$props2)
      $$invalidate(2, escapeControlCharacters = $$props2.escapeControlCharacters);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(3, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(4, parser = $$props2.parser);
    if ("queryLanguages" in $$props2)
      $$invalidate(5, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(0, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(25, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
    if ("onRenderValue" in $$props2)
      $$invalidate(6, onRenderValue = $$props2.onRenderValue);
    if ("onClassName" in $$props2)
      $$invalidate(7, onClassName = $$props2.onClassName);
    if ("onTransform" in $$props2)
      $$invalidate(26, onTransform = $$props2.onTransform);
  };
  $$self.$capture_state = () => ({
    uniqueId,
    faCaretDown,
    faCaretRight,
    debounce: debounce_default,
    isEmpty: isEmpty_default,
    noop: noop_default,
    getContext,
    Icon: Icon_default,
    DEBOUNCE_DELAY,
    compileJSONPointer,
    getIn,
    stringifyJSONPath,
    transformModalState,
    TransformWizard: TransformWizard_default,
    TransformModalHeader: TransformModalHeader_default,
    AbsolutePopup: AbsolutePopup_default,
    createDebug,
    TreeMode: TreeMode_default,
    stripRootObject,
    debug: debug5,
    id: id2,
    json: json2,
    selectedPath,
    escapeControlCharacters,
    escapeUnicodeCharacters,
    parser,
    queryLanguages,
    queryLanguageId,
    onChangeQueryLanguage,
    onRenderValue,
    onClassName,
    onTransform,
    close,
    stateId,
    state,
    showWizard,
    showOriginal,
    queryOptions,
    query,
    isManual,
    previewError,
    previewContent,
    getSelectedQueryLanguage,
    updateQueryByWizard,
    handleChangeQuery,
    previewTransform,
    previewTransformDebounced,
    handleTransform,
    toggleShowWizard,
    toggleShowOriginal,
    focus,
    handleChangeQueryLanguage,
    selectedJson,
    selectedContent
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(23, id2 = $$props2.id);
    if ("json" in $$props2)
      $$invalidate(24, json2 = $$props2.json);
    if ("selectedPath" in $$props2)
      $$invalidate(1, selectedPath = $$props2.selectedPath);
    if ("escapeControlCharacters" in $$props2)
      $$invalidate(2, escapeControlCharacters = $$props2.escapeControlCharacters);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(3, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(4, parser = $$props2.parser);
    if ("queryLanguages" in $$props2)
      $$invalidate(5, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(0, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(25, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
    if ("onRenderValue" in $$props2)
      $$invalidate(6, onRenderValue = $$props2.onRenderValue);
    if ("onClassName" in $$props2)
      $$invalidate(7, onClassName = $$props2.onClassName);
    if ("onTransform" in $$props2)
      $$invalidate(26, onTransform = $$props2.onTransform);
    if ("showWizard" in $$props2)
      $$invalidate(11, showWizard = $$props2.showWizard);
    if ("showOriginal" in $$props2)
      $$invalidate(12, showOriginal = $$props2.showOriginal);
    if ("queryOptions" in $$props2)
      $$invalidate(8, queryOptions = $$props2.queryOptions);
    if ("query" in $$props2)
      $$invalidate(9, query = $$props2.query);
    if ("isManual" in $$props2)
      $$invalidate(28, isManual = $$props2.isManual);
    if ("previewError" in $$props2)
      $$invalidate(13, previewError = $$props2.previewError);
    if ("previewContent" in $$props2)
      $$invalidate(14, previewContent = $$props2.previewContent);
    if ("selectedJson" in $$props2)
      $$invalidate(10, selectedJson = $$props2.selectedJson);
    if ("selectedContent" in $$props2)
      $$invalidate(15, selectedContent = $$props2.selectedContent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 16777218) {
      $:
        $$invalidate(10, selectedJson = getIn(json2, selectedPath));
    }
    if ($$self.$$.dirty[0] & 1024) {
      $:
        $$invalidate(15, selectedContent = { json: selectedJson });
    }
    if ($$self.$$.dirty[0] & 1536) {
      $: {
        previewTransformDebounced(selectedJson, query);
      }
    }
    if ($$self.$$.dirty[0] & 402653953) {
      $: {
        $$invalidate(
          27,
          transformModalState[stateId] = {
            queryOptions,
            query,
            queryLanguageId,
            isManual
          },
          transformModalState
        );
        debug5("store state in memory", stateId, transformModalState[stateId]);
      }
    }
  };
  return [
    queryLanguageId,
    selectedPath,
    escapeControlCharacters,
    escapeUnicodeCharacters,
    parser,
    queryLanguages,
    onRenderValue,
    onClassName,
    queryOptions,
    query,
    selectedJson,
    showWizard,
    showOriginal,
    previewError,
    previewContent,
    selectedContent,
    getSelectedQueryLanguage,
    updateQueryByWizard,
    handleChangeQuery,
    handleTransform,
    toggleShowWizard,
    toggleShowOriginal,
    handleChangeQueryLanguage,
    id2,
    json2,
    onChangeQueryLanguage,
    onTransform,
    transformModalState,
    isManual
  ];
}
var TransformModal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance54,
      create_fragment54,
      not_equal,
      {
        id: 23,
        json: 24,
        selectedPath: 1,
        escapeControlCharacters: 2,
        escapeUnicodeCharacters: 3,
        parser: 4,
        queryLanguages: 5,
        queryLanguageId: 0,
        onChangeQueryLanguage: 25,
        onRenderValue: 6,
        onClassName: 7,
        onTransform: 26
      },
      add_css44,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformModal",
      options,
      id: create_fragment54.name
    });
  }
  get id() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get json() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set json(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedPath() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedPath(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeControlCharacters() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeControlCharacters(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeUnicodeCharacters() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeUnicodeCharacters(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryLanguages() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguages(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryLanguageId() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguageId(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChangeQueryLanguage() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChangeQueryLanguage(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderValue() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderValue(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClassName() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClassName(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTransform() {
    throw new Error("<TransformModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTransform(value) {
    throw new Error("<TransformModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformModal_default = TransformModal;

// ../node_modules/svelte-jsoneditor/components/modals/sortModalState.js
var sortModalState = {};

// ../node_modules/svelte-jsoneditor/components/modals/SortModal.svelte
var { console: console_15 } = globals;
var file49 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/modals/SortModal.svelte";
function add_css45(target) {
  append_styles(target, "svelte-br95s3", ".jse-modal.svelte-br95s3.svelte-br95s3{--height:36px;--multiItemHeight:28px;--multiItemMargin:2px;--multiItemPadding:2px 8px;--multiClearTop:5px;--multiItemBorderRadius:6px;--clearSelectTop:2px;--clearSelectBottom:2px;--indicatorTop:8px;flex:1;display:flex;flex-direction:column;font-family:var(--jse-font-family);font-size:var(--jse-font-size);line-height:normal;background:var(--jse-modal-background);color:var(--jse-text-color)}.jse-modal.svelte-br95s3 .jse-contents.svelte-br95s3{padding:20px;overflow:auto}.jse-modal.svelte-br95s3 .jse-contents .jse-actions.svelte-br95s3{display:flex;flex-direction:row;justify-content:flex-end;padding-top:var(--jse-padding)}.jse-modal.svelte-br95s3 .jse-contents .jse-actions button.svelte-br95s3{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family);font-size:var(--jse-font-size);padding:5px;margin:0;background:var(--jse-button-primary-background);color:var(--jse-button-primary-color);padding:var(--jse-padding) calc(2 * var(--jse-padding));border-radius:3px}.jse-modal.svelte-br95s3 .jse-contents .jse-actions button.svelte-br95s3:hover{background:var(--jse-button-primary-background-highlight)}.jse-modal.svelte-br95s3 .jse-contents .jse-actions button.svelte-br95s3:disabled{background:var(--jse-button-primary-background-disabled)}.bg.jse-modal-bg{width:100%;height:100%;top:0;left:0;background:var(--jse-modal-overlay-background)}.bg.jse-modal-bg .jse-modal-window-wrap{margin:0}.bg.jse-modal-bg .jse-modal-window{max-width:90%;margin:4rem auto 2rem auto;border-radius:2px}.bg.jse-modal-bg .jse-modal-window.jse-modal-window-sort{width:400px}.bg.jse-modal-bg .jse-modal-window.jse-modal-window-transform{width:1200px;height:1200px;max-height:80%;display:flex}.bg.jse-modal-bg .jse-modal-content{flex:1;display:flex;max-height:calc(100vh - 6rem);padding:0}.jse-modal.jse-sort.svelte-br95s3 table.svelte-br95s3{width:100%;border-collapse:collapse;border-spacing:0}.jse-modal.jse-sort.svelte-br95s3 table th.svelte-br95s3,.jse-modal.jse-sort.svelte-br95s3 table td.svelte-br95s3{text-align:left;vertical-align:middle;font-weight:normal;padding-bottom:var(--jse-padding)}.jse-modal.jse-sort.svelte-br95s3 table th input.jse-path.svelte-br95s3,.jse-modal.jse-sort.svelte-br95s3 table td input.jse-path.svelte-br95s3{width:100%;box-sizing:border-box;padding:6px 16px;border:var(--jse-input-border);border-radius:var(--jse-input-radius);font-family:inherit;font-size:inherit;background:inherit;color:inherit;outline:none}.jse-modal.jse-sort.svelte-br95s3 table th input.jse-path.svelte-br95s3:read-only,.jse-modal.jse-sort.svelte-br95s3 table td input.jse-path.svelte-br95s3:read-only{background:var(--jse-input-background-readonly)}.jse-modal.jse-sort.svelte-br95s3 table th.svelte-br95s3 .selectContainer input,.jse-modal.jse-sort.svelte-br95s3 table td.svelte-br95s3 .selectContainer input{box-sizing:border-box}.jse-modal.jse-sort.svelte-br95s3 .jse-space.svelte-br95s3{height:200px}.jse-modal.jse-sort.svelte-br95s3 .jse-space .jse-error.svelte-br95s3{color:var(--jse-error-color)}.svelte-br95s3.svelte-br95s3{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU29ydE1vZGFsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF1SjZCLFVBQUEsNEJBQUEsQ0FBQSx5L0ZBNEg1QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTb3J0TW9kYWwuc3ZlbHRlIl19 */");
}
function create_if_block_117(ctx) {
  let tr;
  let th;
  let t0;
  let t1;
  let td;
  let select;
  let updating_value;
  let current;
  function select_value_binding(value) {
    ctx[13](value);
  }
  let select_props = {
    showIndicator: true,
    items: ctx[4]
  };
  if (ctx[1] !== void 0) {
    select_props.value = ctx[1];
  }
  select = new Select_default({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "value", select_value_binding));
  const block = {
    c: function create() {
      tr = element("tr");
      th = element("th");
      t0 = text("Property");
      t1 = space();
      td = element("td");
      create_component(select.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      th = claim_element(tr_nodes, "TH", { class: true });
      var th_nodes = children(th);
      t0 = claim_text(th_nodes, "Property");
      th_nodes.forEach(detach_dev);
      t1 = claim_space(tr_nodes);
      td = claim_element(tr_nodes, "TD", { class: true });
      var td_nodes = children(td);
      claim_component(select.$$.fragment, td_nodes);
      td_nodes.forEach(detach_dev);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", "svelte-br95s3");
      add_location(th, file49, 109, 12, 3711);
      attr_dev(td, "class", "svelte-br95s3");
      add_location(td, file49, 110, 12, 3741);
      attr_dev(tr, "class", "svelte-br95s3");
      add_location(tr, file49, 108, 10, 3694);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, th);
      append_hydration_dev(th, t0);
      append_hydration_dev(tr, t1);
      append_hydration_dev(tr, td);
      mount_component(select, td, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 16)
        select_changes.items = ctx2[4];
      if (!updating_value && dirty & 2) {
        updating_value = true;
        select_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_component(select);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(108:8) {#if jsonIsArray && (properties.length > 1 || selectedProperty === undefined)}",
    ctx
  });
  return block;
}
function create_if_block29(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[5]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ctx[5]);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-error svelte-br95s3");
      add_location(div, file49, 131, 8, 4231);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(131:6) {#if sortError}",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let div3;
  let header;
  let t0;
  let div2;
  let table;
  let colgroup;
  let col0;
  let t1;
  let col1;
  let t2;
  let tbody;
  let tr0;
  let th0;
  let t3;
  let t4;
  let td0;
  let input;
  let input_value_value;
  let t5;
  let t6;
  let tr1;
  let th1;
  let t7;
  let t8;
  let td1;
  let select;
  let updating_value;
  let t9;
  let div0;
  let t10;
  let div1;
  let button;
  let t11;
  let button_disabled_value;
  let focus_action;
  let current;
  let mounted;
  let dispose;
  header = new Header_default({
    props: {
      title: ctx[3] ? "Sort array items" : "Sort object keys"
    },
    $$inline: true
  });
  let if_block0 = ctx[3] && (ctx[4].length > 1 || ctx[1] === void 0) && create_if_block_117(ctx);
  function select_value_binding_1(value) {
    ctx[14](value);
  }
  let select_props = {
    showIndicator: true,
    items: ctx[6],
    isClearable: false
  };
  if (ctx[2] !== void 0) {
    select_props.value = ctx[2];
  }
  select = new Select_default({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "value", select_value_binding_1));
  let if_block1 = ctx[5] && create_if_block29(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      create_component(header.$$.fragment);
      t0 = space();
      div2 = element("div");
      table = element("table");
      colgroup = element("colgroup");
      col0 = element("col");
      t1 = space();
      col1 = element("col");
      t2 = space();
      tbody = element("tbody");
      tr0 = element("tr");
      th0 = element("th");
      t3 = text("Path");
      t4 = space();
      td0 = element("td");
      input = element("input");
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      tr1 = element("tr");
      th1 = element("th");
      t7 = text("Direction");
      t8 = space();
      td1 = element("td");
      create_component(select.$$.fragment);
      t9 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t10 = space();
      div1 = element("div");
      button = element("button");
      t11 = text("Sort");
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      claim_component(header.$$.fragment, div3_nodes);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      table = claim_element(div2_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      colgroup = claim_element(table_nodes, "COLGROUP", { class: true });
      var colgroup_nodes = children(colgroup);
      col0 = claim_element(colgroup_nodes, "COL", { width: true, class: true });
      t1 = claim_space(colgroup_nodes);
      col1 = claim_element(colgroup_nodes, "COL", { width: true, class: true });
      colgroup_nodes.forEach(detach_dev);
      t2 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      tr0 = claim_element(tbody_nodes, "TR", { class: true });
      var tr0_nodes = children(tr0);
      th0 = claim_element(tr0_nodes, "TH", { class: true });
      var th0_nodes = children(th0);
      t3 = claim_text(th0_nodes, "Path");
      th0_nodes.forEach(detach_dev);
      t4 = claim_space(tr0_nodes);
      td0 = claim_element(tr0_nodes, "TD", { class: true });
      var td0_nodes = children(td0);
      input = claim_element(td0_nodes, "INPUT", { class: true, type: true, title: true });
      td0_nodes.forEach(detach_dev);
      tr0_nodes.forEach(detach_dev);
      t5 = claim_space(tbody_nodes);
      if (if_block0)
        if_block0.l(tbody_nodes);
      t6 = claim_space(tbody_nodes);
      tr1 = claim_element(tbody_nodes, "TR", { class: true });
      var tr1_nodes = children(tr1);
      th1 = claim_element(tr1_nodes, "TH", { class: true });
      var th1_nodes = children(th1);
      t7 = claim_text(th1_nodes, "Direction");
      th1_nodes.forEach(detach_dev);
      t8 = claim_space(tr1_nodes);
      td1 = claim_element(tr1_nodes, "TD", { class: true });
      var td1_nodes = children(td1);
      claim_component(select.$$.fragment, td1_nodes);
      td1_nodes.forEach(detach_dev);
      tr1_nodes.forEach(detach_dev);
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      t9 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t10 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button = claim_element(div1_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t11 = claim_text(button_nodes, "Sort");
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(col0, "width", "25%");
      attr_dev(col0, "class", "svelte-br95s3");
      add_location(col0, file49, 89, 8, 3136);
      attr_dev(col1, "width", "75%");
      attr_dev(col1, "class", "svelte-br95s3");
      add_location(col1, file49, 90, 8, 3164);
      attr_dev(colgroup, "class", "svelte-br95s3");
      add_location(colgroup, file49, 88, 6, 3117);
      attr_dev(th0, "class", "svelte-br95s3");
      add_location(th0, file49, 94, 10, 3239);
      attr_dev(input, "class", "jse-path svelte-br95s3");
      attr_dev(input, "type", "text");
      input.readOnly = true;
      attr_dev(input, "title", "Selected path");
      input.value = input_value_value = !isEmpty_default(ctx[0]) ? stripRootObject(stringifyJSONPath(ctx[0])) : "(whole document)";
      add_location(input, file49, 96, 12, 3280);
      attr_dev(td0, "class", "svelte-br95s3");
      add_location(td0, file49, 95, 10, 3263);
      attr_dev(tr0, "class", "svelte-br95s3");
      add_location(tr0, file49, 93, 8, 3224);
      attr_dev(th1, "class", "svelte-br95s3");
      add_location(th1, file49, 116, 10, 3905);
      attr_dev(td1, "class", "svelte-br95s3");
      add_location(td1, file49, 117, 10, 3934);
      attr_dev(tr1, "class", "svelte-br95s3");
      add_location(tr1, file49, 115, 8, 3890);
      attr_dev(tbody, "class", "svelte-br95s3");
      add_location(tbody, file49, 92, 6, 3208);
      attr_dev(table, "class", "svelte-br95s3");
      add_location(table, file49, 87, 4, 3103);
      attr_dev(div0, "class", "jse-space svelte-br95s3");
      add_location(div0, file49, 129, 4, 4177);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "jse-primary svelte-br95s3");
      button.disabled = button_disabled_value = ctx[3] ? !ctx[1] : false;
      add_location(button, file49, 138, 6, 4352);
      attr_dev(div1, "class", "jse-actions svelte-br95s3");
      add_location(div1, file49, 137, 4, 4320);
      attr_dev(div2, "class", "jse-contents svelte-br95s3");
      add_location(div2, file49, 86, 2, 3072);
      attr_dev(div3, "class", "jse-modal jse-sort svelte-br95s3");
      add_location(div3, file49, 83, 0, 2961);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      mount_component(header, div3, null);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, table);
      append_hydration_dev(table, colgroup);
      append_hydration_dev(colgroup, col0);
      append_hydration_dev(colgroup, t1);
      append_hydration_dev(colgroup, col1);
      append_hydration_dev(table, t2);
      append_hydration_dev(table, tbody);
      append_hydration_dev(tbody, tr0);
      append_hydration_dev(tr0, th0);
      append_hydration_dev(th0, t3);
      append_hydration_dev(tr0, t4);
      append_hydration_dev(tr0, td0);
      append_hydration_dev(td0, input);
      append_hydration_dev(tbody, t5);
      if (if_block0)
        if_block0.m(tbody, null);
      append_hydration_dev(tbody, t6);
      append_hydration_dev(tbody, tr1);
      append_hydration_dev(tr1, th1);
      append_hydration_dev(th1, t7);
      append_hydration_dev(tr1, t8);
      append_hydration_dev(tr1, td1);
      mount_component(select, td1, null);
      append_hydration_dev(div2, t9);
      append_hydration_dev(div2, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div2, t10);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, button);
      append_hydration_dev(button, t11);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[7], false, false, false),
          action_destroyer(focus_action = focus2.call(null, button))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & 8)
        header_changes.title = ctx2[3] ? "Sort array items" : "Sort object keys";
      header.$set(header_changes);
      if (!current || dirty & 1 && input_value_value !== (input_value_value = !isEmpty_default(ctx2[0]) ? stripRootObject(stringifyJSONPath(ctx2[0])) : "(whole document)") && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (ctx2[3] && (ctx2[4].length > 1 || ctx2[1] === void 0)) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 26) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_117(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(tbody, t6);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (!updating_value && dirty & 4) {
        updating_value = true;
        select_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
      if (ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block29(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 10 && button_disabled_value !== (button_disabled_value = ctx2[3] ? !ctx2[1] : false)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block0);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block0);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div3);
      destroy_component(header);
      if (if_block0)
        if_block0.d();
      destroy_component(select);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function focus2(element2) {
  element2.focus();
}
function instance55($$self, $$props, $$invalidate) {
  let jsonIsArray;
  let paths;
  let properties;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SortModal", slots, []);
  const debug5 = createDebug("jsoneditor:SortModal");
  let { id: id2 } = $$props;
  let { json: json2 } = $$props;
  let { selectedPath } = $$props;
  let { onSort } = $$props;
  const { close } = getContext("simple-modal");
  const stateId = `${id2}:${compileJSONPointer(selectedPath)}`;
  const selectedJson = getIn(json2, selectedPath);
  const asc = { value: 1, label: "ascending" };
  const desc = { value: -1, label: "descending" };
  const directions = [asc, desc];
  let selectedProperty = sortModalState[stateId] && sortModalState[stateId].selectedProperty || void 0;
  let selectedDirection = sortModalState[stateId] && sortModalState[stateId].selectedDirection || asc;
  let sortError = void 0;
  function handleSort() {
    try {
      $$invalidate(5, sortError = void 0);
      if (jsonIsArray) {
        if (!selectedProperty) {
          return;
        }
        const property = selectedProperty.value;
        const direction = selectedDirection.value;
        const operations = sortArray(json2, selectedPath, property, direction);
        onSort(operations);
      } else if (isObject(selectedJson)) {
        const direction = selectedDirection.value;
        const operations = sortObjectKeys(json2, selectedPath, direction);
        onSort(operations);
      } else {
        console.error("Cannot sort: no array or object");
      }
      close();
    } catch (err) {
      $$invalidate(5, sortError = err.toString());
    }
  }
  $$self.$$.on_mount.push(function() {
    if (id2 === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console_15.warn("<SortModal> was created without expected prop 'id'");
    }
    if (json2 === void 0 && !("json" in $$props || $$self.$$.bound[$$self.$$.props["json"]])) {
      console_15.warn("<SortModal> was created without expected prop 'json'");
    }
    if (selectedPath === void 0 && !("selectedPath" in $$props || $$self.$$.bound[$$self.$$.props["selectedPath"]])) {
      console_15.warn("<SortModal> was created without expected prop 'selectedPath'");
    }
    if (onSort === void 0 && !("onSort" in $$props || $$self.$$.bound[$$self.$$.props["onSort"]])) {
      console_15.warn("<SortModal> was created without expected prop 'onSort'");
    }
  });
  const writable_props = ["id", "json", "selectedPath", "onSort"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_15.warn(`<SortModal> was created with unknown prop '${key}'`);
  });
  function select_value_binding(value) {
    selectedProperty = value;
    $$invalidate(1, selectedProperty), $$invalidate(4, properties), $$invalidate(12, paths), $$invalidate(3, jsonIsArray);
  }
  function select_value_binding_1(value) {
    selectedDirection = value;
    $$invalidate(2, selectedDirection);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(8, id2 = $$props2.id);
    if ("json" in $$props2)
      $$invalidate(9, json2 = $$props2.json);
    if ("selectedPath" in $$props2)
      $$invalidate(0, selectedPath = $$props2.selectedPath);
    if ("onSort" in $$props2)
      $$invalidate(10, onSort = $$props2.onSort);
  };
  $$self.$capture_state = () => ({
    isEmpty: isEmpty_default,
    getContext,
    Select: Select_default,
    Header: Header_default,
    getNestedPaths,
    isObject,
    pathToOption,
    stringifyJSONPath,
    sortArray,
    sortObjectKeys,
    sortModalState,
    compileJSONPointer,
    getIn,
    createDebug,
    stripRootObject,
    debug: debug5,
    id: id2,
    json: json2,
    selectedPath,
    onSort,
    close,
    stateId,
    selectedJson,
    asc,
    desc,
    directions,
    selectedProperty,
    selectedDirection,
    sortError,
    handleSort,
    focus: focus2,
    jsonIsArray,
    properties,
    paths
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(8, id2 = $$props2.id);
    if ("json" in $$props2)
      $$invalidate(9, json2 = $$props2.json);
    if ("selectedPath" in $$props2)
      $$invalidate(0, selectedPath = $$props2.selectedPath);
    if ("onSort" in $$props2)
      $$invalidate(10, onSort = $$props2.onSort);
    if ("selectedProperty" in $$props2)
      $$invalidate(1, selectedProperty = $$props2.selectedProperty);
    if ("selectedDirection" in $$props2)
      $$invalidate(2, selectedDirection = $$props2.selectedDirection);
    if ("sortError" in $$props2)
      $$invalidate(5, sortError = $$props2.sortError);
    if ("jsonIsArray" in $$props2)
      $$invalidate(3, jsonIsArray = $$props2.jsonIsArray);
    if ("properties" in $$props2)
      $$invalidate(4, properties = $$props2.properties);
    if ("paths" in $$props2)
      $$invalidate(12, paths = $$props2.paths);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(12, paths = jsonIsArray ? getNestedPaths(selectedJson) : void 0);
    }
    if ($$self.$$.dirty & 4096) {
      $:
        $$invalidate(4, properties = paths ? paths.map(pathToOption) : void 0);
    }
    if ($$self.$$.dirty & 18) {
      $: {
        if (selectedProperty === void 0 && properties && properties.length === 1) {
          $$invalidate(1, selectedProperty = properties[0]);
        }
      }
    }
    if ($$self.$$.dirty & 2054) {
      $: {
        $$invalidate(11, sortModalState[stateId] = { selectedProperty, selectedDirection }, sortModalState);
        debug5("store state in memory", stateId, sortModalState[stateId]);
      }
    }
  };
  $:
    $$invalidate(3, jsonIsArray = Array.isArray(selectedJson));
  return [
    selectedPath,
    selectedProperty,
    selectedDirection,
    jsonIsArray,
    properties,
    sortError,
    directions,
    handleSort,
    id2,
    json2,
    onSort,
    sortModalState,
    paths,
    select_value_binding,
    select_value_binding_1
  ];
}
var SortModal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance55,
      create_fragment55,
      not_equal,
      {
        id: 8,
        json: 9,
        selectedPath: 0,
        onSort: 10
      },
      add_css45
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SortModal",
      options,
      id: create_fragment55.name
    });
  }
  get id() {
    throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get json() {
    throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set json(value) {
    throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedPath() {
    throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedPath(value) {
    throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSort() {
    throw new Error("<SortModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSort(value) {
    throw new Error("<SortModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SortModal_default = SortModal;

// ../node_modules/svelte-jsoneditor/components/modals/ModalRef.svelte
function create_fragment56(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalRef", slots, []);
  const context = getContext("simple-modal");
  const open = context.open;
  const close = context.close;
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ModalRef> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ getContext, context, open, close });
  return [open, close];
}
var ModalRef = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, not_equal, { open: 0, close: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalRef",
      options,
      id: create_fragment56.name
    });
  }
  get open() {
    return this.$$.ctx[0];
  }
  set open(value) {
    throw new Error("<ModalRef>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    return this.$$.ctx[1];
  }
  set close(value) {
    throw new Error("<ModalRef>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalRef_default = ModalRef;

// ../node_modules/svelte-jsoneditor/components/JSONEditor.svelte
var { Error: Error_14, console: console_16 } = globals;
var file50 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/components/JSONEditor.svelte";
function add_css46(target) {
  append_styles(target, "svelte-15hsltd", ':root{--jse-font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,\n    Cantarell, "Helvetica Neue", sans-serif;--jse-font-family-mono:consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace;--jse-font-size-mono:14px;--jse-font-size:16px;--jse-font-size-text-mode-search:80%;--jse-line-height:calc(1em + 4px);--jse-indent-size:calc(1em + 4px);--jse-color-picker-button-size:1em;--jse-padding:10px;--jse-theme-color:#3883fa;--jse-theme-color-highlight:#5f9dff;--jse-background-color:#fff;--jse-text-color:#4d4d4d;--jse-text-color-inverse:#fff;--jse-error-color:#ee5341;--jse-warning-color:#fdc539;--jse-main-border:1px solid #d7d7d7;--jse-menu-color:var(--jse-text-color-inverse);--jse-menu-button-size:32px;--jse-modal-background:#f5f5f5;--jse-modal-overlay-background:rgba(0, 0, 0, 0.3);--jse-modal-code-background:rgba(0, 0, 0, 0.05);--jse-tooltip-color:var(--jse-text-color);--jse-tooltip-background:var(--jse-modal-background);--jse-tooltip-border:var(--jse-main-border);--jse-tooltip-action-button-color:var(--jse-text-color-inverse);--jse-tooltip-action-button-background:#4d4d4d;--jse-panel-background:#ebebeb;--jse-panel-color:var(--jse-text-color);--jse-panel-color-readonly:#b2b2b2;--jse-panel-border:var(--jse-main-border);--jse-panel-button-color:inherit;--jse-panel-button-background:transparent;--jse-panel-button-color-highlight:var(--jse-text-color);--jse-panel-button-background-highlight:#e0e0e0;--jse-navigation-bar-background:var(--jse-background-color);--jse-navigation-bar-background-highlight:#e5e5e5;--jse-navigation-bar-dropdown-color:#656565;--jse-context-menu-background:#656565;--jse-context-menu-background-highlight:#7a7a7a;--jse-context-menu-color:var(--jse-text-color-inverse);--jse-context-menu-color-disabled:#9d9d9d;--jse-context-menu-separator-color:#7a7a7a;--jse-context-menu-button-background:var(--jse-context-menu-background);--jse-context-menu-button-background-highlight:var(--jse-context-menu-background-highlight);--jse-context-menu-button-color:var(--jse-context-menu-color);--jse-context-menu-button-size:calc(1em + 4px);--jse-context-menu-tip-background:rgba(255, 255, 255, 0.2);--jse-context-menu-tip-color:inherit;--jse-key-color:#1a1a1a;--jse-value-color:#1a1a1a;--jse-value-color-number:#ee422e;--jse-value-color-boolean:#ff8c00;--jse-value-color-null:#004ed0;--jse-value-color-string:#008000;--jse-value-color-url:#008000;--jse-delimiter-color:rgba(0, 0, 0, 0.38);--jse-edit-outline:2px solid #656565;--jse-selection-background-color:#d3d3d3;--jse-selection-background-light-color:#e8e8e8;--jse-hover-background-color:rgba(0, 0, 0, 0.06);--jse-active-line-background-color:rgba(0, 0, 0, 0.06);--jse-search-match-background-color:#99ff7780;--jse-collapsed-items-background-color:#f5f5f5;--jse-collapsed-items-selected-background-color:#c2c2c2;--jse-collapsed-items-link-color:rgba(0, 0, 0, 0.38);--jse-collapsed-items-link-color-highlight:#ee5341;--jse-search-match-color:#ffe665;--jse-search-match-outline:1px solid #ffd700;--jse-search-match-active-color:#ffd700;--jse-search-match-active-outline:1px solid #e1be00;--jse-tag-background:rgba(0, 0, 0, 0.2);--jse-tag-color:var(--jse-text-color-inverse);--jse-controls-box-shadow:0 2px 6px 0 rgba(0, 0, 0, 0.24);--jse-input-background:var(--jse-background-color);--jse-input-background-readonly:transparent;--jse-input-border:1px solid #d8dbdf;--jse-input-border-focus:1px solid var(--jse-theme-color);--jse-input-radius:3px;--jse-button-background:#e0e0e0;--jse-button-background-highlight:#e7e7e7;--jse-button-color:var(--jse-text-color);--jse-button-primary-background:var(--jse-theme-color);--jse-button-primary-background-highlight:var(--jse-theme-color-highlight);--jse-button-primary-background-disabled:#9d9d9d;--jse-button-primary-color:var(--jse-text-color-inverse);--jse-a-color:#156fc5;--jse-a-color-highlight:#0f508d;--jse-message-error-background:var(--jse-error-color);--jse-message-error-color:var(--jse-text-color-inverse);--jse-message-warning-background:#ffde5c;--jse-message-warning-color:var(--jse-text-color);--jse-message-success-background:#9ac45d;--jse-message-success-color:var(--jse-text-color-inverse);--jse-message-info-background:#9d9d9d;--jse-message-info-color:var(--jse-text-color-inverse);--jse-message-action-background:rgba(255, 255, 255, 0.2);--jse-message-action-background-highlight:rgba(255, 255, 255, 0.3);--itemIsActiveBG:#3883fa;--border:1px solid #d8dbdf;--borderRadius:3px;--background:#fff;--jse-color-picker-background:var(--jse-panel-background);--jse-color-picker-border-box-shadow:#cbcbcb 0 0 0 1px}.jse-main.svelte-15hsltd{width:100%;height:100%;min-width:0;min-height:150px;font-family:var(--jse-font-family);font-size:var(--jse-font-size);line-height:normal;position:relative;display:flex;flex-direction:row}.svelte-15hsltd{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTkVkaXRvci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBeVkrQixLQUFLLEFBQUMsQ0FBQSxBQUVuQyxpQkFBaUIsQ0FBRTsyQ0FDc0IsQ0FHekMsc0JBQXNCLENBQUUsb0VBQW9FLENBQzVGLG9CQUFvQixDQUFFLElBQUksQ0FDMUIsZUFBZSxDQUFFLElBQUksQ0FDckIsZ0NBQWdDLENBQUUsR0FBRyxDQUNyQyxpQkFBaUIsQ0FBRSxlQUFlLENBQ2xDLGlCQUFpQixDQUFFLGVBQWUsQ0FDbEMsOEJBQThCLENBQUUsR0FBRyxDQUNuQyxhQUFhLENBQUUsSUFBSSxDQUNuQixpQkFBaUIsQ0FBRSxPQUFPLENBQzFCLDJCQUEyQixDQUFFLE9BQU8sQ0FDcEMsc0JBQXNCLENBQUUsSUFBSSxDQUM1QixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLHdCQUF3QixDQUFFLElBQUksQ0FDOUIsaUJBQWlCLENBQUUsT0FBTyxDQUMxQixtQkFBbUIsQ0FBRSxPQUFPLENBRTVCLGlCQUFpQixDQUFFLGlCQUFpQixDQUNwQyxnQkFBZ0IsQ0FBRSw2QkFBNkIsQ0FDL0Msc0JBQXNCLENBQUUsSUFBSSxDQUM1QixzQkFBc0IsQ0FBRSxPQUFPLENBQy9CLDhCQUE4QixDQUFFLGtCQUFrQixDQUNsRCwyQkFBMkIsQ0FBRSxtQkFBbUIsQ0FFaEQsbUJBQW1CLENBQUUscUJBQXFCLENBQzFDLHdCQUF3QixDQUFFLDJCQUEyQixDQUNyRCxvQkFBb0IsQ0FBRSxzQkFBc0IsQ0FDNUMsaUNBQWlDLENBQUUsNkJBQTZCLENBQ2hFLHNDQUFzQyxDQUFFLE9BQU8sQ0FFL0Msc0JBQXNCLENBQUUsT0FBTyxDQUMvQixpQkFBaUIsQ0FBRSxxQkFBcUIsQ0FDeEMsMEJBQTBCLENBQUUsT0FBTyxDQUNuQyxrQkFBa0IsQ0FBRSxzQkFBc0IsQ0FDMUMsd0JBQXdCLENBQUUsT0FBTyxDQUNqQyw2QkFBNkIsQ0FBRSxXQUFXLENBQzFDLGtDQUFrQyxDQUFFLHFCQUFxQixDQUN6RCx1Q0FBdUMsQ0FBRSxPQUFPLENBRWhELCtCQUErQixDQUFFLDJCQUEyQixDQUM1RCx5Q0FBeUMsQ0FBRSxPQUFPLENBQ2xELG1DQUFtQyxDQUFFLE9BQU8sQ0FFNUMsNkJBQTZCLENBQUUsT0FBTyxDQUN0Qyx1Q0FBdUMsQ0FBRSxPQUFPLENBQ2hELHdCQUF3QixDQUFFLDZCQUE2QixDQUN2RCxpQ0FBaUMsQ0FBRSxPQUFPLENBQzFDLGtDQUFrQyxDQUFFLE9BQU8sQ0FDM0Msb0NBQW9DLENBQUUsa0NBQWtDLENBQ3hFLDhDQUE4QyxDQUFFLDRDQUE0QyxDQUM1RiwrQkFBK0IsQ0FBRSw2QkFBNkIsQ0FDOUQsOEJBQThCLENBQUUsZUFBZSxDQUMvQyxpQ0FBaUMsQ0FBRSx3QkFBd0IsQ0FDM0QsNEJBQTRCLENBQUUsT0FBTyxDQUVyQyxlQUFlLENBQUUsT0FBTyxDQUN4QixpQkFBaUIsQ0FBRSxPQUFPLENBQzFCLHdCQUF3QixDQUFFLE9BQU8sQ0FDakMseUJBQXlCLENBQUUsT0FBTyxDQUNsQyxzQkFBc0IsQ0FBRSxPQUFPLENBQy9CLHdCQUF3QixDQUFFLE9BQU8sQ0FDakMscUJBQXFCLENBQUUsT0FBTyxDQUM5QixxQkFBcUIsQ0FBRSxtQkFBbUIsQ0FDMUMsa0JBQWtCLENBQUUsaUJBQWlCLENBRXJDLGdDQUFnQyxDQUFFLE9BQU8sQ0FDekMsc0NBQXNDLENBQUUsT0FBTyxDQUMvQyw0QkFBNEIsQ0FBRSxtQkFBbUIsQ0FDakQsa0NBQWtDLENBQUUsbUJBQW1CLENBQ3ZELG1DQUFtQyxDQUFFLFNBQVMsQ0FFOUMsc0NBQXNDLENBQUUsT0FBTyxDQUMvQywrQ0FBK0MsQ0FBRSxPQUFPLENBQ3hELGdDQUFnQyxDQUFFLG1CQUFtQixDQUNyRCwwQ0FBMEMsQ0FBRSxPQUFPLENBRW5ELHdCQUF3QixDQUFFLE9BQU8sQ0FDakMsMEJBQTBCLENBQUUsaUJBQWlCLENBQzdDLCtCQUErQixDQUFFLE9BQU8sQ0FDeEMsaUNBQWlDLENBQUUsaUJBQWlCLENBRXBELG9CQUFvQixDQUFFLGtCQUFrQixDQUN4QyxlQUFlLENBQUUsNkJBQTZCLENBRTlDLHlCQUF5QixDQUFFLCtCQUErQixDQUMxRCxzQkFBc0IsQ0FBRSwyQkFBMkIsQ0FDbkQsK0JBQStCLENBQUUsV0FBVyxDQUM1QyxrQkFBa0IsQ0FBRSxpQkFBaUIsQ0FDckMsd0JBQXdCLENBQUUsZ0NBQWdDLENBQzFELGtCQUFrQixDQUFFLEdBQUcsQ0FDdkIsdUJBQXVCLENBQUUsT0FBTyxDQUNoQyxpQ0FBaUMsQ0FBRSxPQUFPLENBQzFDLGtCQUFrQixDQUFFLHFCQUFxQixDQUN6QywrQkFBK0IsQ0FBRSxzQkFBc0IsQ0FDdkQseUNBQXlDLENBQUUsZ0NBQWdDLENBQzNFLHdDQUF3QyxDQUFFLE9BQU8sQ0FDakQsMEJBQTBCLENBQUUsNkJBQTZCLENBQ3pELGFBQWEsQ0FBRSxPQUFPLENBQ3RCLHVCQUF1QixDQUFFLE9BQU8sQ0FFaEMsOEJBQThCLENBQUUsc0JBQXNCLENBQ3RELHlCQUF5QixDQUFFLDZCQUE2QixDQUN4RCxnQ0FBZ0MsQ0FBRSxPQUFPLENBQ3pDLDJCQUEyQixDQUFFLHFCQUFxQixDQUNsRCxnQ0FBZ0MsQ0FBRSxPQUFPLENBQ3pDLDJCQUEyQixDQUFFLDZCQUE2QixDQUMxRCw2QkFBNkIsQ0FBRSxPQUFPLENBQ3RDLHdCQUF3QixDQUFFLDZCQUE2QixDQUN2RCwrQkFBK0IsQ0FBRSx3QkFBd0IsQ0FDekQseUNBQXlDLENBQUUsd0JBQXdCLENBRW5FLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsUUFBUSxDQUFFLGlCQUFpQixDQUMzQixjQUFjLENBQUUsR0FBRyxDQUNuQixZQUFZLENBQUUsSUFBSSxDQUVsQiw2QkFBNkIsQ0FBRSwyQkFBMkIsQ0FDMUQsb0NBQW9DLENBQUUsaUJBQWlCLEFBQ3pELENBQUEsQUFFQSxTQUFTLGVBQUMsQ0FBQSxBQUNSLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixTQUFTLENBQUUsQ0FBQyxDQUNaLFVBQVUsQ0FBRSxLQUFLLENBQ2pCLFdBQVcsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLENBQ25DLFNBQVMsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxDQUMvQixXQUFXLENBQUUsTUFBTSxDQUNuQixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxHQUFHLEFBQ3JCLENBQUEsQUFBQSxlQUFBLEVBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSlNPTkVkaXRvci5zdmVsdGUiXX0= */');
}
function create_else_block17(ctx) {
  let treemode;
  let current;
  let treemode_props = {
    readOnly: ctx[2],
    indentation: ctx[3],
    externalContent: ctx[0],
    mainMenuBar: ctx[5],
    navigationBar: ctx[6],
    escapeControlCharacters: ctx[8],
    escapeUnicodeCharacters: ctx[9],
    parser: ctx[10],
    validator: ctx[11],
    validationParser: ctx[12],
    pathParser: ctx[13],
    onError: ctx[16],
    onChange: ctx[24],
    onRequestRepair: ctx[25],
    onRenderValue: ctx[14],
    onClassName: ctx[15],
    onFocus: ctx[27],
    onBlur: ctx[28],
    onRenderMenu: ctx[23],
    onSortModal: ctx[30],
    onTransformModal: ctx[29]
  };
  treemode = new TreeMode_default({ props: treemode_props, $$inline: true });
  ctx[57](treemode);
  const block = {
    c: function create() {
      create_component(treemode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treemode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treemode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treemode_changes = {};
      if (dirty[0] & 4)
        treemode_changes.readOnly = ctx2[2];
      if (dirty[0] & 8)
        treemode_changes.indentation = ctx2[3];
      if (dirty[0] & 1)
        treemode_changes.externalContent = ctx2[0];
      if (dirty[0] & 32)
        treemode_changes.mainMenuBar = ctx2[5];
      if (dirty[0] & 64)
        treemode_changes.navigationBar = ctx2[6];
      if (dirty[0] & 256)
        treemode_changes.escapeControlCharacters = ctx2[8];
      if (dirty[0] & 512)
        treemode_changes.escapeUnicodeCharacters = ctx2[9];
      if (dirty[0] & 1024)
        treemode_changes.parser = ctx2[10];
      if (dirty[0] & 2048)
        treemode_changes.validator = ctx2[11];
      if (dirty[0] & 4096)
        treemode_changes.validationParser = ctx2[12];
      if (dirty[0] & 8192)
        treemode_changes.pathParser = ctx2[13];
      if (dirty[0] & 65536)
        treemode_changes.onError = ctx2[16];
      if (dirty[0] & 16384)
        treemode_changes.onRenderValue = ctx2[14];
      if (dirty[0] & 32768)
        treemode_changes.onClassName = ctx2[15];
      if (dirty[0] & 8388608)
        treemode_changes.onRenderMenu = ctx2[23];
      treemode.$set(treemode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treemode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treemode.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      ctx[57](null);
      destroy_component(treemode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(362:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block30(ctx) {
  let textmode;
  let current;
  let textmode_props = {
    externalContent: ctx[0],
    readOnly: ctx[2],
    indentation: ctx[3],
    tabSize: ctx[4],
    mainMenuBar: ctx[5],
    statusBar: ctx[7],
    escapeUnicodeCharacters: ctx[9],
    parser: ctx[10],
    validator: ctx[11],
    validationParser: ctx[12],
    onChange: ctx[24],
    onSwitchToTreeMode: ctx[26],
    onError: ctx[16],
    onFocus: ctx[27],
    onBlur: ctx[28],
    onRenderMenu: ctx[23],
    onSortModal: ctx[30],
    onTransformModal: ctx[29]
  };
  textmode = new TextMode_default({ props: textmode_props, $$inline: true });
  ctx[56](textmode);
  const block = {
    c: function create() {
      create_component(textmode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textmode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textmode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textmode_changes = {};
      if (dirty[0] & 1)
        textmode_changes.externalContent = ctx2[0];
      if (dirty[0] & 4)
        textmode_changes.readOnly = ctx2[2];
      if (dirty[0] & 8)
        textmode_changes.indentation = ctx2[3];
      if (dirty[0] & 16)
        textmode_changes.tabSize = ctx2[4];
      if (dirty[0] & 32)
        textmode_changes.mainMenuBar = ctx2[5];
      if (dirty[0] & 128)
        textmode_changes.statusBar = ctx2[7];
      if (dirty[0] & 512)
        textmode_changes.escapeUnicodeCharacters = ctx2[9];
      if (dirty[0] & 1024)
        textmode_changes.parser = ctx2[10];
      if (dirty[0] & 2048)
        textmode_changes.validator = ctx2[11];
      if (dirty[0] & 4096)
        textmode_changes.validationParser = ctx2[12];
      if (dirty[0] & 65536)
        textmode_changes.onError = ctx2[16];
      if (dirty[0] & 8388608)
        textmode_changes.onRenderMenu = ctx2[23];
      textmode.$set(textmode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textmode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textmode.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      ctx[56](null);
      destroy_component(textmode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(340:8) {#if mode === Mode.text || mode === 'code'}",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block30, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === Mode.text || ctx2[1] === "code")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(338:6) {#key instanceId}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let div;
  let previous_key = ctx[17];
  let current;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      key_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      key_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "jse-main svelte-15hsltd");
      toggle_class(div, "jse-focus", ctx[18]);
      add_location(div, file50, 336, 4, 10584);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      key_block.m(div, null);
      ctx[58](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 131072 && not_equal(previous_key, previous_key = ctx2[17])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (!current || dirty[0] & 262144) {
        toggle_class(div, "jse-focus", ctx2[18]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(div);
      key_block.d(detaching);
      ctx[58](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(336:2) <AbsolutePopup>",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let modalref;
  let updating_open;
  let t;
  let absolutepopup;
  let current;
  function modalref_open_binding(value) {
    ctx[55](value);
  }
  let modalref_props = {};
  if (ctx[22] !== void 0) {
    modalref_props.open = ctx[22];
  }
  modalref = new ModalRef_default({ props: modalref_props, $$inline: true });
  binding_callbacks.push(() => bind(modalref, "open", modalref_open_binding));
  absolutepopup = new AbsolutePopup_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalref.$$.fragment);
      t = space();
      create_component(absolutepopup.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modalref.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(absolutepopup.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modalref, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(absolutepopup, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalref_changes = {};
      if (!updating_open && dirty[0] & 4194304) {
        updating_open = true;
        modalref_changes.open = ctx2[22];
        add_flush_callback(() => updating_open = false);
      }
      modalref.$set(modalref_changes);
      const absolutepopup_changes = {};
      if (dirty[0] & 12582911 | dirty[2] & 2) {
        absolutepopup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      absolutepopup.$set(absolutepopup_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalref.$$.fragment, local);
      transition_in(absolutepopup.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalref.$$.fragment, local);
      transition_out(absolutepopup.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(modalref, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(absolutepopup, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(334:0) <Modal>",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let modal;
  let current;
  modal = new src_default({
    props: {
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modal.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modal_changes = {};
      if (dirty[0] & 16777215 | dirty[2] & 2) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d: function destroy2(detaching) {
      destroy_component(modal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function updateProps(props) {
  this.$set(props);
}
function destroy() {
  this.$destroy();
}
function instance57($$self, $$props, $$invalidate) {
  let handleRenderMenu;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JSONEditor", slots, []);
  const debug5 = createDebug("jsoneditor:Main");
  let { content = { text: "" } } = $$props;
  let { readOnly = false } = $$props;
  let { indentation = 2 } = $$props;
  let { tabSize = 4 } = $$props;
  let { mode = Mode.tree } = $$props;
  let { mainMenuBar = true } = $$props;
  let { navigationBar = true } = $$props;
  let { statusBar = true } = $$props;
  let { escapeControlCharacters = false } = $$props;
  let { escapeUnicodeCharacters = false } = $$props;
  let { parser = JSON } = $$props;
  let { validator = null } = $$props;
  let { validationParser = JSON } = $$props;
  let { pathParser = {
    parse: parseJSONPath,
    stringify: stringifyJSONPath
  } } = $$props;
  let { queryLanguages = [javascriptQueryLanguage] } = $$props;
  let { queryLanguageId = queryLanguages[0].id } = $$props;
  let { onChangeQueryLanguage = noop_default } = $$props;
  let { onChange = null } = $$props;
  let { onRenderValue = renderValue } = $$props;
  let { onClassName = () => void 0 } = $$props;
  let { onRenderMenu = noop_default } = $$props;
  let { onChangeMode = noop_default } = $$props;
  let { onError = (err) => {
    console.error(err);
    alert(err.toString());
  } } = $$props;
  let { onFocus = noop_default } = $$props;
  let { onBlur = noop_default } = $$props;
  let instanceId = uniqueId();
  let hasFocus = false;
  let refJSONEditor;
  let refTreeMode;
  let refTextMode;
  let open;
  let previousParser = parser;
  function get() {
    return content;
  }
  function set(newContent) {
    debug5("set");
    const contentError = validateContentType(newContent);
    if (contentError) {
      throw new Error(contentError);
    }
    $$invalidate(17, instanceId = uniqueId());
    $$invalidate(0, content = newContent);
  }
  function update(updatedContent) {
    debug5("update");
    const contentError = validateContentType(updatedContent);
    if (contentError) {
      throw new Error(contentError);
    }
    $$invalidate(0, content = updatedContent);
  }
  function patch(operations) {
    if (isTextContent(content)) {
      try {
        $$invalidate(0, content = {
          json: parser.parse(content.text),
          text: void 0
        });
      } catch (err) {
        throw new Error("Cannot apply patch: current document contains invalid JSON");
      }
    }
    if (refTreeMode) {
      return refTreeMode.patch(operations);
    }
    if (refTextMode) {
      return refTextMode.patch(operations);
    }
  }
  function expand(callback) {
    if (refTreeMode) {
      return refTreeMode.expand(callback);
    } else {
      throw new Error(`Method expand is not available in mode "${mode}"`);
    }
  }
  function transform(options) {
    if (refTextMode) {
      refTextMode.openTransformModal(options);
    } else if (refTreeMode) {
      refTreeMode.openTransformModal(options);
    } else {
      throw new Error(`Method transform is not available in mode "${mode}"`);
    }
  }
  function validate() {
    if (refTextMode) {
      return refTextMode.validate();
    } else if (refTreeMode) {
      return refTreeMode.validate();
    } else {
      throw new Error(`Method validate is not available in mode "${mode}"`);
    }
  }
  function acceptAutoRepair() {
    if (refTreeMode) {
      return refTreeMode.acceptAutoRepair();
    } else {
      return content;
    }
  }
  function scrollTo(path) {
    if (refTreeMode) {
      return refTreeMode.scrollTo(path);
    } else {
      throw new Error(`Method scrollTo is not available in mode "${mode}"`);
    }
  }
  function findElement(path) {
    if (refTreeMode) {
      return refTreeMode.findElement(path);
    } else {
      throw new Error(`Method findElement is not available in mode "${mode}"`);
    }
  }
  function focus3() {
    if (refTextMode) {
      refTextMode.focus();
    } else if (refTreeMode) {
      refTreeMode.focus();
    }
  }
  function refresh() {
    if (refTextMode) {
      refTextMode.refresh();
    } else {
    }
  }
  function handleChange(updatedContent, previousContent, status) {
    $$invalidate(0, content = updatedContent);
    if (onChange) {
      onChange(updatedContent, previousContent, status);
    }
  }
  async function handleRequestRepair() {
    $$invalidate(1, mode = Mode.text);
    await tick();
    onChangeMode(Mode.text);
  }
  async function handleSwitchToTreeMode() {
    $$invalidate(1, mode = Mode.tree);
    await tick();
    onChangeMode(Mode.tree);
  }
  function handleFocus() {
    $$invalidate(18, hasFocus = true);
    if (onFocus) {
      onFocus();
    }
  }
  function handleBlur() {
    $$invalidate(18, hasFocus = false);
    if (onBlur) {
      onBlur();
    }
  }
  async function toggleMode(newMode) {
    if (mode === newMode) {
      return;
    }
    $$invalidate(1, mode = newMode);
    await tick();
    focus3();
    onChangeMode(newMode);
  }
  let modeMenuItems;
  const separatorMenuItem = { separator: true };
  function handleChangeQueryLanguage(newQueryLanguageId) {
    debug5("handleChangeQueryLanguage", newQueryLanguageId);
    $$invalidate(31, queryLanguageId = newQueryLanguageId);
    onChangeQueryLanguage(newQueryLanguageId);
  }
  function onTransformModal({ id: id2, json: json2, selectedPath, onTransform, onClose }) {
    if (readOnly) {
      return;
    }
    open(
      TransformModal_default,
      {
        id: id2,
        json: json2,
        selectedPath,
        escapeControlCharacters,
        escapeUnicodeCharacters,
        parser,
        queryLanguages,
        queryLanguageId,
        onChangeQueryLanguage: handleChangeQueryLanguage,
        onRenderValue,
        onClassName,
        onTransform
      },
      TRANSFORM_MODAL_OPTIONS,
      { onClose }
    );
  }
  function onSortModal({ id: id2, json: json2, selectedPath, onSort, onClose }) {
    if (readOnly) {
      return;
    }
    open(SortModal_default, { id: id2, json: json2, selectedPath, onSort }, SORT_MODAL_OPTIONS, { onClose });
  }
  const writable_props = [
    "content",
    "readOnly",
    "indentation",
    "tabSize",
    "mode",
    "mainMenuBar",
    "navigationBar",
    "statusBar",
    "escapeControlCharacters",
    "escapeUnicodeCharacters",
    "parser",
    "validator",
    "validationParser",
    "pathParser",
    "queryLanguages",
    "queryLanguageId",
    "onChangeQueryLanguage",
    "onChange",
    "onRenderValue",
    "onClassName",
    "onRenderMenu",
    "onChangeMode",
    "onError",
    "onFocus",
    "onBlur"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_16.warn(`<JSONEditor> was created with unknown prop '${key}'`);
  });
  function modalref_open_binding(value) {
    open = value;
    $$invalidate(22, open);
  }
  function textmode_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refTextMode = $$value;
      $$invalidate(21, refTextMode);
    });
  }
  function treemode_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refTreeMode = $$value;
      $$invalidate(20, refTreeMode);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refJSONEditor = $$value;
      $$invalidate(19, refJSONEditor);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
    if ("readOnly" in $$props2)
      $$invalidate(2, readOnly = $$props2.readOnly);
    if ("indentation" in $$props2)
      $$invalidate(3, indentation = $$props2.indentation);
    if ("tabSize" in $$props2)
      $$invalidate(4, tabSize = $$props2.tabSize);
    if ("mode" in $$props2)
      $$invalidate(1, mode = $$props2.mode);
    if ("mainMenuBar" in $$props2)
      $$invalidate(5, mainMenuBar = $$props2.mainMenuBar);
    if ("navigationBar" in $$props2)
      $$invalidate(6, navigationBar = $$props2.navigationBar);
    if ("statusBar" in $$props2)
      $$invalidate(7, statusBar = $$props2.statusBar);
    if ("escapeControlCharacters" in $$props2)
      $$invalidate(8, escapeControlCharacters = $$props2.escapeControlCharacters);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(9, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(10, parser = $$props2.parser);
    if ("validator" in $$props2)
      $$invalidate(11, validator = $$props2.validator);
    if ("validationParser" in $$props2)
      $$invalidate(12, validationParser = $$props2.validationParser);
    if ("pathParser" in $$props2)
      $$invalidate(13, pathParser = $$props2.pathParser);
    if ("queryLanguages" in $$props2)
      $$invalidate(32, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(31, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(33, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
    if ("onChange" in $$props2)
      $$invalidate(34, onChange = $$props2.onChange);
    if ("onRenderValue" in $$props2)
      $$invalidate(14, onRenderValue = $$props2.onRenderValue);
    if ("onClassName" in $$props2)
      $$invalidate(15, onClassName = $$props2.onClassName);
    if ("onRenderMenu" in $$props2)
      $$invalidate(35, onRenderMenu = $$props2.onRenderMenu);
    if ("onChangeMode" in $$props2)
      $$invalidate(36, onChangeMode = $$props2.onChangeMode);
    if ("onError" in $$props2)
      $$invalidate(16, onError = $$props2.onError);
    if ("onFocus" in $$props2)
      $$invalidate(37, onFocus = $$props2.onFocus);
    if ("onBlur" in $$props2)
      $$invalidate(38, onBlur = $$props2.onBlur);
  };
  $$self.$capture_state = () => ({
    createDebug,
    Modal: src_default,
    SORT_MODAL_OPTIONS,
    TRANSFORM_MODAL_OPTIONS,
    uniqueId,
    isEqualParser,
    isJSONContent,
    isTextContent,
    validateContentType,
    AbsolutePopup: AbsolutePopup_default,
    TextMode: TextMode_default,
    TreeMode: TreeMode_default,
    javascriptQueryLanguage,
    renderValue,
    tick,
    TransformModal: TransformModal_default,
    SortModal: SortModal_default,
    ModalRef: ModalRef_default,
    Mode,
    isMenuSpaceItem,
    noop: noop_default,
    parseJSONPath,
    stringifyJSONPath,
    debug: debug5,
    content,
    readOnly,
    indentation,
    tabSize,
    mode,
    mainMenuBar,
    navigationBar,
    statusBar,
    escapeControlCharacters,
    escapeUnicodeCharacters,
    parser,
    validator,
    validationParser,
    pathParser,
    queryLanguages,
    queryLanguageId,
    onChangeQueryLanguage,
    onChange,
    onRenderValue,
    onClassName,
    onRenderMenu,
    onChangeMode,
    onError,
    onFocus,
    onBlur,
    instanceId,
    hasFocus,
    refJSONEditor,
    refTreeMode,
    refTextMode,
    open,
    previousParser,
    get,
    set,
    update,
    patch,
    expand,
    transform,
    validate,
    acceptAutoRepair,
    scrollTo,
    findElement,
    focus: focus3,
    refresh,
    updateProps,
    destroy,
    handleChange,
    handleRequestRepair,
    handleSwitchToTreeMode,
    handleFocus,
    handleBlur,
    toggleMode,
    modeMenuItems,
    separatorMenuItem,
    handleChangeQueryLanguage,
    onTransformModal,
    onSortModal,
    handleRenderMenu
  });
  $$self.$inject_state = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
    if ("readOnly" in $$props2)
      $$invalidate(2, readOnly = $$props2.readOnly);
    if ("indentation" in $$props2)
      $$invalidate(3, indentation = $$props2.indentation);
    if ("tabSize" in $$props2)
      $$invalidate(4, tabSize = $$props2.tabSize);
    if ("mode" in $$props2)
      $$invalidate(1, mode = $$props2.mode);
    if ("mainMenuBar" in $$props2)
      $$invalidate(5, mainMenuBar = $$props2.mainMenuBar);
    if ("navigationBar" in $$props2)
      $$invalidate(6, navigationBar = $$props2.navigationBar);
    if ("statusBar" in $$props2)
      $$invalidate(7, statusBar = $$props2.statusBar);
    if ("escapeControlCharacters" in $$props2)
      $$invalidate(8, escapeControlCharacters = $$props2.escapeControlCharacters);
    if ("escapeUnicodeCharacters" in $$props2)
      $$invalidate(9, escapeUnicodeCharacters = $$props2.escapeUnicodeCharacters);
    if ("parser" in $$props2)
      $$invalidate(10, parser = $$props2.parser);
    if ("validator" in $$props2)
      $$invalidate(11, validator = $$props2.validator);
    if ("validationParser" in $$props2)
      $$invalidate(12, validationParser = $$props2.validationParser);
    if ("pathParser" in $$props2)
      $$invalidate(13, pathParser = $$props2.pathParser);
    if ("queryLanguages" in $$props2)
      $$invalidate(32, queryLanguages = $$props2.queryLanguages);
    if ("queryLanguageId" in $$props2)
      $$invalidate(31, queryLanguageId = $$props2.queryLanguageId);
    if ("onChangeQueryLanguage" in $$props2)
      $$invalidate(33, onChangeQueryLanguage = $$props2.onChangeQueryLanguage);
    if ("onChange" in $$props2)
      $$invalidate(34, onChange = $$props2.onChange);
    if ("onRenderValue" in $$props2)
      $$invalidate(14, onRenderValue = $$props2.onRenderValue);
    if ("onClassName" in $$props2)
      $$invalidate(15, onClassName = $$props2.onClassName);
    if ("onRenderMenu" in $$props2)
      $$invalidate(35, onRenderMenu = $$props2.onRenderMenu);
    if ("onChangeMode" in $$props2)
      $$invalidate(36, onChangeMode = $$props2.onChangeMode);
    if ("onError" in $$props2)
      $$invalidate(16, onError = $$props2.onError);
    if ("onFocus" in $$props2)
      $$invalidate(37, onFocus = $$props2.onFocus);
    if ("onBlur" in $$props2)
      $$invalidate(38, onBlur = $$props2.onBlur);
    if ("instanceId" in $$props2)
      $$invalidate(17, instanceId = $$props2.instanceId);
    if ("hasFocus" in $$props2)
      $$invalidate(18, hasFocus = $$props2.hasFocus);
    if ("refJSONEditor" in $$props2)
      $$invalidate(19, refJSONEditor = $$props2.refJSONEditor);
    if ("refTreeMode" in $$props2)
      $$invalidate(20, refTreeMode = $$props2.refTreeMode);
    if ("refTextMode" in $$props2)
      $$invalidate(21, refTextMode = $$props2.refTextMode);
    if ("open" in $$props2)
      $$invalidate(22, open = $$props2.open);
    if ("previousParser" in $$props2)
      $$invalidate(53, previousParser = $$props2.previousParser);
    if ("modeMenuItems" in $$props2)
      $$invalidate(54, modeMenuItems = $$props2.modeMenuItems);
    if ("handleRenderMenu" in $$props2)
      $$invalidate(23, handleRenderMenu = $$props2.handleRenderMenu);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1025 | $$self.$$.dirty[1] & 4194304) {
      $: {
        if (!isEqualParser(parser, previousParser)) {
          debug5("parser changed, recreate editor");
          if (isJSONContent(content)) {
            $$invalidate(0, content = {
              json: parser.parse(previousParser.stringify(content.json))
            });
          }
          $$invalidate(53, previousParser = parser);
          $$invalidate(17, instanceId = uniqueId());
        }
      }
    }
    if ($$self.$$.dirty[0] & 1) {
      $: {
        const contentError = validateContentType(content);
        if (contentError) {
          console.error("Error: " + contentError);
        }
      }
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(54, modeMenuItems = [
          {
            text: "text",
            title: `Switch to text mode (current mode: ${mode})`,
            className: "jse-group-button jse-first" + (mode === Mode.text || mode === "code" ? " jse-selected" : ""),
            onClick: () => toggleMode(Mode.text)
          },
          {
            text: "tree",
            title: `Switch to tree mode (current mode: ${mode})`,
            className: "jse-group-button jse-last" + (mode === Mode.tree ? " jse-selected" : ""),
            onClick: () => toggleMode(Mode.tree)
          }
        ]);
    }
    if ($$self.$$.dirty[1] & 8388624) {
      $:
        $$invalidate(23, handleRenderMenu = (mode2, items) => {
          const updatedItems = isMenuSpaceItem(items[0]) ? modeMenuItems.concat(items) : modeMenuItems.concat(separatorMenuItem, items);
          return onRenderMenu(mode2, updatedItems) || updatedItems;
        });
    }
    if ($$self.$$.dirty[0] & 2) {
      $: {
        debug5("mode changed to", mode);
        if (mode === "code") {
          console.warn('Deprecation warning: "code" mode is renamed to "text". Please use mode="text" instead.');
        }
      }
    }
  };
  return [
    content,
    mode,
    readOnly,
    indentation,
    tabSize,
    mainMenuBar,
    navigationBar,
    statusBar,
    escapeControlCharacters,
    escapeUnicodeCharacters,
    parser,
    validator,
    validationParser,
    pathParser,
    onRenderValue,
    onClassName,
    onError,
    instanceId,
    hasFocus,
    refJSONEditor,
    refTreeMode,
    refTextMode,
    open,
    handleRenderMenu,
    handleChange,
    handleRequestRepair,
    handleSwitchToTreeMode,
    handleFocus,
    handleBlur,
    onTransformModal,
    onSortModal,
    queryLanguageId,
    queryLanguages,
    onChangeQueryLanguage,
    onChange,
    onRenderMenu,
    onChangeMode,
    onFocus,
    onBlur,
    get,
    set,
    update,
    patch,
    expand,
    transform,
    validate,
    acceptAutoRepair,
    scrollTo,
    findElement,
    focus3,
    refresh,
    updateProps,
    destroy,
    previousParser,
    modeMenuItems,
    modalref_open_binding,
    textmode_binding,
    treemode_binding,
    div_binding
  ];
}
var JSONEditor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance57,
      create_fragment57,
      not_equal,
      {
        content: 0,
        readOnly: 2,
        indentation: 3,
        tabSize: 4,
        mode: 1,
        mainMenuBar: 5,
        navigationBar: 6,
        statusBar: 7,
        escapeControlCharacters: 8,
        escapeUnicodeCharacters: 9,
        parser: 10,
        validator: 11,
        validationParser: 12,
        pathParser: 13,
        queryLanguages: 32,
        queryLanguageId: 31,
        onChangeQueryLanguage: 33,
        onChange: 34,
        onRenderValue: 14,
        onClassName: 15,
        onRenderMenu: 35,
        onChangeMode: 36,
        onError: 16,
        onFocus: 37,
        onBlur: 38,
        get: 39,
        set: 40,
        update: 41,
        patch: 42,
        expand: 43,
        transform: 44,
        validate: 45,
        acceptAutoRepair: 46,
        scrollTo: 47,
        findElement: 48,
        focus: 49,
        refresh: 50,
        updateProps: 51,
        destroy: 52
      },
      add_css46,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONEditor",
      options,
      id: create_fragment57.name
    });
  }
  get content() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indentation() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indentation(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabSize() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabSize(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mode() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mode(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mainMenuBar() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mainMenuBar(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navigationBar() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navigationBar(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get statusBar() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set statusBar(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeControlCharacters() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeControlCharacters(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeUnicodeCharacters() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeUnicodeCharacters(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validator() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validator(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationParser() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationParser(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pathParser() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pathParser(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryLanguages() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguages(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryLanguageId() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryLanguageId(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChangeQueryLanguage() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChangeQueryLanguage(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChange() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChange(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderValue() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderValue(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClassName() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClassName(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRenderMenu() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRenderMenu(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChangeMode() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChangeMode(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onError() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onError(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onFocus() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onFocus(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBlur() {
    throw new Error_14("<JSONEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBlur(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get get() {
    return this.$$.ctx[39];
  }
  set get(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get set() {
    return this.$$.ctx[40];
  }
  set set(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    return this.$$.ctx[41];
  }
  set update(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patch() {
    return this.$$.ctx[42];
  }
  set patch(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    return this.$$.ctx[43];
  }
  set expand(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transform() {
    return this.$$.ctx[44];
  }
  set transform(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validate() {
    return this.$$.ctx[45];
  }
  set validate(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get acceptAutoRepair() {
    return this.$$.ctx[46];
  }
  set acceptAutoRepair(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollTo() {
    return this.$$.ctx[47];
  }
  set scrollTo(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get findElement() {
    return this.$$.ctx[48];
  }
  set findElement(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[49];
  }
  set focus(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refresh() {
    return this.$$.ctx[50];
  }
  set refresh(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateProps() {
    return updateProps;
  }
  set updateProps(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get destroy() {
    return destroy;
  }
  set destroy(value) {
    throw new Error_14("<JSONEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JSONEditor_default = JSONEditor;

// ../node_modules/svelte-jsoneditor/plugins/value/components/EnumValue.svelte
var file51 = "Users/toomuchham/pec-hackathon/sveltepress/node_modules/svelte-jsoneditor/plugins/value/components/EnumValue.svelte";
function add_css47(target) {
  append_styles(target, "svelte-1gwmn8u", ".jse-value.jse-string.svelte-1gwmn8u{color:var(--jse-value-color-string)}.jse-value.jse-object.svelte-1gwmn8u,.jse-value.jse-array.svelte-1gwmn8u{min-width:16px;color:var(--jse-delimiter-color)}.jse-value.jse-number.svelte-1gwmn8u{color:var(--jse-value-color-number)}.jse-value.jse-boolean.svelte-1gwmn8u{color:var(--jse-value-color-boolean)}.jse-value.jse-null.svelte-1gwmn8u{color:var(--jse-value-color-null)}.jse-value.jse-invalid.svelte-1gwmn8u{color:var(--jse-text-color)}.jse-value.jse-url.svelte-1gwmn8u{color:var(--jse-value-color-url);text-decoration:underline}.jse-enum-value.svelte-1gwmn8u{background:var(--jse-hover-background-color);border:none;padding:0;font-family:inherit;font-size:inherit;cursor:pointer;outline:none}.jse-enum-value.jse-selected.svelte-1gwmn8u{background:var(--jse-selection-background-color);color:inherit}.jse-enum-value.jse-value.svelte-1gwmn8u:focus{color:var(--jse-text-color)}.jse-json-node.jse-selected .jse-enum-value.svelte-1gwmn8u{background:transparent}.svelte-1gwmn8u{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRW51bVZhbHVlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzRDZCLFVBQUEsV0FBQSxlQUFBLENBQUEsazlCQTJDNUIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRW51bVZhbHVlLnN2ZWx0ZSJdfQ== */");
}
function get_each_context18(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block18(ctx) {
  let option;
  let t_value = ctx[13].text + "";
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { class: true });
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = ctx[13].value;
      option.value = option.__value;
      attr_dev(option, "class", "svelte-1gwmn8u");
      add_location(option, file51, 50, 4, 1181);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[13].text + ""))
        set_data_dev(t, t_value);
      if (dirty & 4 && option_value_value !== (option_value_value = ctx2[13].value)) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
    },
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block18.name,
    type: "each",
    source: "(50:2) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment58(ctx) {
  let select;
  let select_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[2];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block18(get_each_context18(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", { class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select, "class", select_class_value = null_to_empty(`jse-enum-value ${getValueClass(ctx[4], ctx[0])}`) + " svelte-1gwmn8u");
      if (ctx[4] === void 0)
        add_render_callback(() => ctx[10].call(select));
      toggle_class(select, "jse-selected", ctx[1]);
      add_location(select, file51, 41, 0, 933);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[4]);
      ctx[11](select);
      if (!mounted) {
        dispose = [
          listen_dev(select, "change", ctx[10]),
          listen_dev(select, "change", ctx[5], false, false, false),
          listen_dev(select, "mousedown", handleMouseDown, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value = ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context18(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block18(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 17 && select_class_value !== (select_class_value = null_to_empty(`jse-enum-value ${getValueClass(ctx2[4], ctx2[0])}`) + " svelte-1gwmn8u")) {
        attr_dev(select, "class", select_class_value);
      }
      if (dirty & 16) {
        select_option(select, ctx2[4]);
      }
      if (dirty & 19) {
        toggle_class(select, "jse-selected", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy2(detaching) {
      if (detaching)
        detach_dev(select);
      destroy_each(each_blocks, detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function handleMouseDown(event) {
  event.stopPropagation();
}
function instance58($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EnumValue", slots, []);
  let { path } = $$props;
  let { value } = $$props;
  let { parser } = $$props;
  let { readOnly } = $$props;
  let { isSelected } = $$props;
  let { onPatch } = $$props;
  let { options } = $$props;
  let refSelect;
  let bindValue = value;
  function applyFocus(isSelected2) {
    if (isSelected2) {
      if (refSelect) {
        refSelect.focus();
      }
    }
  }
  function handleSelect(event) {
    event.stopPropagation();
    if (readOnly) {
      return;
    }
    onPatch([
      {
        op: "replace",
        path: compileJSONPointer(path),
        value: bindValue
      }
    ]);
  }
  $$self.$$.on_mount.push(function() {
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<EnumValue> was created without expected prop 'path'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<EnumValue> was created without expected prop 'value'");
    }
    if (parser === void 0 && !("parser" in $$props || $$self.$$.bound[$$self.$$.props["parser"]])) {
      console.warn("<EnumValue> was created without expected prop 'parser'");
    }
    if (readOnly === void 0 && !("readOnly" in $$props || $$self.$$.bound[$$self.$$.props["readOnly"]])) {
      console.warn("<EnumValue> was created without expected prop 'readOnly'");
    }
    if (isSelected === void 0 && !("isSelected" in $$props || $$self.$$.bound[$$self.$$.props["isSelected"]])) {
      console.warn("<EnumValue> was created without expected prop 'isSelected'");
    }
    if (onPatch === void 0 && !("onPatch" in $$props || $$self.$$.bound[$$self.$$.props["onPatch"]])) {
      console.warn("<EnumValue> was created without expected prop 'onPatch'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<EnumValue> was created without expected prop 'options'");
    }
  });
  const writable_props = ["path", "value", "parser", "readOnly", "isSelected", "onPatch", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EnumValue> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    bindValue = select_value(this);
    $$invalidate(4, bindValue), $$invalidate(7, value);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refSelect = $$value;
      $$invalidate(3, refSelect);
      $$invalidate(2, options);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(6, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(7, value = $$props2.value);
    if ("parser" in $$props2)
      $$invalidate(0, parser = $$props2.parser);
    if ("readOnly" in $$props2)
      $$invalidate(8, readOnly = $$props2.readOnly);
    if ("isSelected" in $$props2)
      $$invalidate(1, isSelected = $$props2.isSelected);
    if ("onPatch" in $$props2)
      $$invalidate(9, onPatch = $$props2.onPatch);
    if ("options" in $$props2)
      $$invalidate(2, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    compileJSONPointer,
    getValueClass,
    path,
    value,
    parser,
    readOnly,
    isSelected,
    onPatch,
    options,
    refSelect,
    bindValue,
    applyFocus,
    handleSelect,
    handleMouseDown
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(6, path = $$props2.path);
    if ("value" in $$props2)
      $$invalidate(7, value = $$props2.value);
    if ("parser" in $$props2)
      $$invalidate(0, parser = $$props2.parser);
    if ("readOnly" in $$props2)
      $$invalidate(8, readOnly = $$props2.readOnly);
    if ("isSelected" in $$props2)
      $$invalidate(1, isSelected = $$props2.isSelected);
    if ("onPatch" in $$props2)
      $$invalidate(9, onPatch = $$props2.onPatch);
    if ("options" in $$props2)
      $$invalidate(2, options = $$props2.options);
    if ("refSelect" in $$props2)
      $$invalidate(3, refSelect = $$props2.refSelect);
    if ("bindValue" in $$props2)
      $$invalidate(4, bindValue = $$props2.bindValue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(4, bindValue = value);
    }
    if ($$self.$$.dirty & 2) {
      $:
        applyFocus(isSelected);
    }
  };
  return [
    parser,
    isSelected,
    options,
    refSelect,
    bindValue,
    handleSelect,
    path,
    value,
    readOnly,
    onPatch,
    select_change_handler,
    select_binding
  ];
}
var EnumValue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance58,
      create_fragment58,
      not_equal,
      {
        path: 6,
        value: 7,
        parser: 0,
        readOnly: 8,
        isSelected: 1,
        onPatch: 9,
        options: 2
      },
      add_css47
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EnumValue",
      options,
      id: create_fragment58.name
    });
  }
  get path() {
    throw new Error("<EnumValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<EnumValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<EnumValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<EnumValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<EnumValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<EnumValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<EnumValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<EnumValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSelected() {
    throw new Error("<EnumValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<EnumValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPatch() {
    throw new Error("<EnumValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPatch(value) {
    throw new Error("<EnumValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<EnumValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<EnumValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EnumValue_default = EnumValue;

// ../node_modules/svelte-jsoneditor/utils/jsonSchemaUtils.js
function getJSONSchemaOptions(schema, schemaDefinitions, path) {
  const schemaForPath = findSchema(schema, schemaDefinitions || {}, path);
  return schemaForPath ? findEnum(schemaForPath) : null;
}
function findEnum(schema) {
  if (schema.enum) {
    return schema.enum;
  }
  const composite = schema.oneOf || schema.anyOf || schema.allOf;
  if (composite) {
    const match = composite.filter((entry) => entry.enum);
    if (match.length > 0) {
      return match[0].enum;
    }
  }
  return null;
}
function findSchema(topLevelSchema, schemaDefinitions, path, currentSchema = topLevelSchema) {
  var _a;
  const nextPath = path.slice(1, path.length);
  const nextKey = path[0];
  let possibleSchemas = [currentSchema];
  for (const subSchemas of [currentSchema.oneOf, currentSchema.anyOf, currentSchema.allOf]) {
    if (Array.isArray(subSchemas)) {
      possibleSchemas = possibleSchemas.concat(subSchemas);
    }
  }
  for (const schema of possibleSchemas) {
    currentSchema = schema;
    if ("$ref" in currentSchema && typeof currentSchema.$ref === "string") {
      const ref = currentSchema.$ref;
      if (ref in schemaDefinitions) {
        currentSchema = schemaDefinitions[ref];
      } else if (ref.startsWith("#/")) {
        const refPath = ref.substring(2).split("/");
        currentSchema = topLevelSchema;
        for (const segment of refPath) {
          if (segment in currentSchema) {
            currentSchema = currentSchema[segment];
          } else {
            throw Error(`Unable to resovle reference ${ref}`);
          }
        }
      } else if (((_a = ref.match(/#\//g)) == null ? void 0 : _a.length) === 1) {
        const [schemaUrl, relativePath] = ref.split("#/");
        if (schemaUrl in schemaDefinitions) {
          const referencedSchema = schemaDefinitions[schemaUrl];
          const reference = { $ref: "#/".concat(relativePath) };
          const auxNextPath = [];
          auxNextPath.push(nextKey);
          if (nextPath.length > 0) {
            auxNextPath.push(...nextPath);
          }
          return findSchema(referencedSchema, schemaDefinitions, auxNextPath, reference);
        } else {
          throw Error(`Unable to resolve reference ${ref}`);
        }
      } else {
        throw Error(`Unable to resolve reference ${ref}`);
      }
    }
    if (nextKey === void 0) {
      return currentSchema;
    }
    if (typeof nextKey === "string") {
      if (typeof currentSchema.properties === "object" && currentSchema.properties !== null && nextKey in currentSchema.properties) {
        currentSchema = currentSchema.properties[nextKey];
        return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema);
      }
      if (typeof currentSchema.patternProperties === "object" && currentSchema.patternProperties !== null) {
        for (const prop in currentSchema.patternProperties) {
          if (nextKey.match(prop)) {
            currentSchema = currentSchema.patternProperties[prop];
            return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema);
          }
        }
      }
      if (typeof currentSchema.additionalProperties === "object") {
        currentSchema = currentSchema.additionalProperties;
        return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema);
      }
      continue;
    }
    if (typeof nextKey === "number" && typeof currentSchema.items === "object" && currentSchema.items !== null) {
      currentSchema = currentSchema.items;
      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema);
    }
  }
  return null;
}

// ../node_modules/svelte-jsoneditor/plugins/value/renderJSONSchemaEnum.js
function renderJSONSchemaEnum(props, schema, schemaDefinitions) {
  const enumValues = getJSONSchemaOptions(schema, schemaDefinitions, props.path);
  if (enumValues) {
    const { value, path, readOnly, onPatch, isSelected } = props;
    const options = enumValues.map((enumValue) => ({
      value: enumValue,
      text: enumValue
    }));
    const optionsWithValue = enumValues.includes(props.value) ? options : [{ value, text: value }].concat(options);
    return [
      {
        component: EnumValue_default,
        props: {
          value,
          path,
          readOnly,
          onPatch,
          isSelected,
          options: optionsWithValue
        }
      }
    ];
  }
  return null;
}

// ../node_modules/svelte-jsoneditor/plugins/validator/createAjvValidator.js
var import_ajv_dist = __toESM(require_ajv7_min(), 1);
function createAjvValidator(options) {
  if (options.schema === void 0) {
    throw new Error("Deprecation warning: the signature of createAjvValidator is changed from createAjvValidator(schema, schemaDefinitions, ajvOptions) to createAjvValidator({ schema, schemaDefinitions, ajvOptions }). Please pass the arguments as an object instead of unnamed arguments.");
  }
  let ajv = createAjvInstance(options);
  if (options.onCreateAjv !== void 0) {
    ajv = options.onCreateAjv(ajv) || ajv;
  }
  const validateAjv = ajv.compile(options.schema);
  return function validate(json2) {
    validateAjv(json2);
    const ajvErrors = validateAjv.errors || [];
    return ajvErrors.map(improveAjvError).map((error) => normalizeAjvError(json2, error));
  };
}
function createAjvInstance(options) {
  const { schemaDefinitions, ajvOptions } = options;
  const ajv = new import_ajv_dist.default({
    allErrors: true,
    verbose: true,
    $data: true,
    ...ajvOptions
  });
  if (schemaDefinitions) {
    Object.keys(schemaDefinitions).forEach((ref) => {
      ajv.addSchema(schemaDefinitions[ref], ref);
    });
  }
  return ajv;
}
function normalizeAjvError(json2, ajvError) {
  return {
    path: parsePath(json2, ajvError.instancePath),
    message: ajvError.message,
    severity: ValidationSeverity.warning
  };
}
function improveAjvError(ajvError) {
  if (ajvError.keyword === "enum" && Array.isArray(ajvError.schema)) {
    let enums = ajvError.schema;
    if (enums) {
      enums = enums.map((value) => JSON.stringify(value));
      if (enums.length > 5) {
        const more = ["(" + (enums.length - 5) + " more...)"];
        enums = enums.slice(0, 5);
        enums.push(more);
      }
      ajvError.message = "should be equal to one of: " + enums.join(", ");
    }
  }
  if (ajvError.keyword === "additionalProperties") {
    ajvError.message = "should NOT have additional property: " + ajvError.params.additionalProperty;
  }
  return ajvError;
}

// ../node_modules/svelte-jsoneditor/plugins/query/lodashQueryLanguage.js
var description2 = `
<p>
  Enter a JavaScript function to filter, sort, or transform the data.
  You can use <a href="https://lodash.com" target="_blank" rel="noopener noreferrer">Lodash</a>
  functions like <code>_.map</code>, <code>_.filter</code>,
  <code>_.orderBy</code>, <code>_.sortBy</code>, <code>_.groupBy</code>,
  <code>_.pick</code>, <code>_.uniq</code>, <code>_.get</code>, etcetera.
</p>
`;
var lodashQueryLanguage = {
  id: "lodash",
  name: "Lodash",
  description: description2,
  createQuery: createQuery2,
  executeQuery: executeQuery2
};
function createQuery2(json2, queryOptions) {
  const { filter, sort, projection } = queryOptions;
  const queryParts = [];
  if (filter && filter.path && filter.relation && filter.value) {
    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`;
    const filterValue = parseString(filter.value);
    const filterValueStr = typeof filterValue === "string" ? `'${filter.value}'` : isInteger(filter.value) && !Number.isSafeInteger(filterValue) ? `${filter.value}n` : filter.value;
    queryParts.push(`  data = _.filter(data, ${actualValueGetter} ${filter.relation} ${filterValueStr})
`);
  }
  if (sort && sort.path && sort.direction) {
    queryParts.push(`  data = _.orderBy(data, [${createLodashPropertySelector(sort.path)}], ['${sort.direction}'])
`);
  }
  if (projection && projection.paths) {
    if (projection.paths.length > 1) {
      const paths = projection.paths.map((path) => {
        const name = last_default(path) || "item";
        return `    ${JSON.stringify(name)}: item${createPropertySelector(path)}`;
      });
      queryParts.push(`  data = _.map(data, item => ({
${paths.join(",\n")}
  }))
`);
    } else {
      const path = projection.paths[0];
      queryParts.push(`  data = _.map(data, item => item${createPropertySelector(path)})
`);
    }
  }
  queryParts.push("  return data\n");
  return `function query (data) {
${queryParts.join("")}}`;
}
function executeQuery2(json2, query) {
  const queryFn = new Function("_", '"use strict";\n\n' + query + `

if (typeof query !== "function") {
  throw new Error("Cannot execute query: expecting a function named 'query' but is undefined")
}

return query;
`)(lodash_exports);
  const output = queryFn(json2);
  return output !== void 0 ? output : null;
}

// ../node_modules/svelte-jsoneditor/plugins/query/jmespathQueryLanguage.js
var import_jmespath = __toESM(require_jmespath(), 1);
var description3 = `
<p>
  Enter a <a href="https://jmespath.org" target="_blank" rel="noopener noreferrer">JMESPath</a> query 
  to filter, sort, or transform the JSON data.
 To learn JMESPath, go to <a href="https://jmespath.org/tutorial.html" target="_blank" rel="noopener noreferrer">the interactive tutorial</a>.
</p>
`;
var jmespathQueryLanguage = {
  id: "jmespath",
  name: "JMESPath",
  description: description3,
  createQuery: createQuery3,
  executeQuery: executeQuery3
};
function createQuery3(json2, queryOptions) {
  const { sort, filter, projection } = queryOptions;
  let query = "";
  if (filter && filter.path && filter.relation && filter.value) {
    const examplePath = ["0"].concat(filter.path);
    const exampleValue = getIn(json2, examplePath);
    const filterValue = parseString(filter.value);
    const filterValueStr = typeof exampleValue === "string" && filterValue !== null && filterValue !== void 0 ? `"${filter.value}"` : filterValue;
    query += "[? " + stringifyPathForJmespath(filter.path) + " " + filter.relation + " `" + filterValueStr + "`]";
  } else {
    query += Array.isArray(json2) ? "[*]" : "@";
  }
  if (sort && sort.path && sort.direction) {
    if (sort.direction === "desc") {
      query += " | reverse(sort_by(@, &" + stringifyPathForJmespath(sort.path) + "))";
    } else {
      query += " | sort_by(@, &" + stringifyPathForJmespath(sort.path) + ")";
    }
  }
  if (projection && projection.paths) {
    if (query[query.length - 1] !== "]") {
      query += " | [*]";
    }
    if (projection.paths.length === 1) {
      const path = projection.paths[0];
      query += path.length === 0 ? "" : "." + stringifyPathForJmespath(path);
    } else if (projection.paths.length > 1) {
      query += ".{" + projection.paths.map((path) => {
        const name = path[path.length - 1];
        return stringifyProp(name) + ": " + stringifyPathForJmespath(path);
      }).join(", ") + "}";
    } else {
    }
  }
  return query;
}
function executeQuery3(json2, query) {
  return import_jmespath.default.search(json2, query);
}
function stringifyPathForJmespath(path) {
  if (path.length === 0) {
    return "@";
  }
  const str = path.map((prop) => {
    if (typeof prop === "number") {
      return "[" + prop + "]";
    } else {
      return "." + stringifyProp(String(prop));
    }
  }).join("");
  return str[0] === "." ? str.slice(1) : str;
}
function stringifyProp(prop) {
  return prop.match(/^[A-Za-z\d_$]+$/) ? prop : JSON.stringify(prop);
}
export {
  BooleanToggle_default as BooleanToggle,
  CaretType,
  ColorPicker_default as ColorPicker,
  EditableValue_default as EditableValue,
  EnumValue_default as EnumValue,
  JSONEditor_default as JSONEditor,
  Mode,
  ReadonlyValue_default as ReadonlyValue,
  SearchField,
  SelectionType,
  TimestampTag_default as TimestampTag,
  ValidationSeverity,
  compileJSONPointer,
  compileJSONPointerProp,
  createAfterSelection,
  createAjvValidator,
  createInsideSelection,
  createKeySelection,
  createMultiSelection,
  createValueSelection,
  deleteIn,
  estimateSerializedSize,
  existsIn,
  getIn,
  immutableJSONPatch,
  insertAt,
  isAfterSelection,
  isContent,
  isEditingSelection,
  isEqualParser,
  isInsideSelection,
  isJSONContent,
  isKeySelection,
  isLargeContent,
  isMultiSelection,
  isTextContent,
  isValueSelection,
  javascriptQueryLanguage,
  jmespathQueryLanguage,
  lodashQueryLanguage,
  parseFrom,
  parseJSONPath,
  parseJSONPointer,
  parsePath,
  renderJSONSchemaEnum,
  renderValue,
  revertJSONPatch,
  setIn,
  stringifyJSONPath,
  toJSONContent,
  toTextContent,
  updateIn
};
//# sourceMappingURL=svelte-jsoneditor.js.map
