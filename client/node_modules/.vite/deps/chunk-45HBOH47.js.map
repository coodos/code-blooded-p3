{
  "version": 3,
  "sources": ["../../../../node_modules/jsonrepair/src/JsonRepairError.js", "../../../../node_modules/jsonrepair/src/stringUtils.js", "../../../../node_modules/jsonrepair/src/jsonrepair.js"],
  "sourcesContent": ["export default function JsonRepairError (message, char) {\n  if (!(this instanceof JsonRepairError)) {\n    throw new SyntaxError('Constructor must be called with the new operator')\n  }\n\n  this.message = message + ' (char ' + char + ')'\n  this.char = char\n  this.stack = (new Error()).stack\n}\n\nJsonRepairError.prototype = new Error()\nJsonRepairError.prototype.constructor = Error\n", "\nconst SINGLE_QUOTES = {\n  '\\'': true, // quote\n  '\\u2018': true, // quote left\n  '\\u2019': true, // quote right\n  '\\u0060': true, // grave accent\n  '\\u00B4': true // acute accent\n}\n\nconst DOUBLE_QUOTES = {\n  '\"': true,\n  '\\u201C': true, // double quote left\n  '\\u201D': true // double quote right\n}\n\n/**\n * Check if the given character contains an alpha character, a-z, A-Z, _\n * @param {string} c\n * @return {boolean}\n */\nexport function isAlpha (c) {\n  return ALPHA_REGEX.test(c)\n}\n\nconst ALPHA_REGEX = /^[a-zA-Z_]$/\n\n/**\n * Check if the given character contains a hexadecimal character 0-9, a-f, A-F\n * @param {string} c\n * @return {boolean}\n */\nexport function isHex (c) {\n  return HEX_REGEX.test(c)\n}\n\nconst HEX_REGEX = /^[0-9a-fA-F]$/\n\n/**\n * checks if the given char c is a digit\n * @param {string} c\n * @return {boolean}\n */\nexport function isDigit (c) {\n  return DIGIT_REGEX.test(c)\n}\n\nconst DIGIT_REGEX = /^[0-9]$/\n\n/**\n * Check if the given character is a whitespace character like space, tab, or\n * newline\n * @param {string} c\n * @return {boolean}\n */\nexport function isWhitespace (c) {\n  return c === ' ' || c === '\\t' || c === '\\n' || c === '\\r'\n}\n\n/**\n * Check if the given character is a special whitespace character, some\n * unicode variant\n * @param {string} c\n * @return {boolean}\n */\nexport function isSpecialWhitespace (c) {\n  return (\n    c === '\\u00A0' ||\n    (c >= '\\u2000' && c <= '\\u200A') ||\n    c === '\\u202F' ||\n    c === '\\u205F' ||\n    c === '\\u3000'\n  )\n}\n\n/**\n * Replace speical whitespace characters with regular spaces\n * @param {string} text\n * @returns {string}\n */\nexport function normalizeWhitespace (text) {\n  let normalized = ''\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i]\n    normalized += isSpecialWhitespace(char)\n      ? ' '\n      : char\n  }\n\n  return normalized\n}\n\n/**\n * Test whether the given character is a quote or double quote character.\n * Also tests for special variants of quotes.\n * @param {string} c\n * @returns {boolean}\n */\nexport function isQuote (c) {\n  return SINGLE_QUOTES[c] === true || DOUBLE_QUOTES[c] === true\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Also tests for special variants of single quotes.\n * @param {string} c\n * @returns {boolean}\n */\nexport function isSingleQuote (c) {\n  return SINGLE_QUOTES[c] === true\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Also tests for special variants of double quotes.\n * @param {string} c\n * @returns {boolean}\n */\nexport function isDoubleQuote (c) {\n  return DOUBLE_QUOTES[c] === true\n}\n\n/**\n * Normalize special double or single quote characters to their regular\n * variant ' or \"\n * @param {string} c\n * @returns {string}\n */\nexport function normalizeQuote (c) {\n  if (SINGLE_QUOTES[c] === true) {\n    return '\\''\n  }\n\n  if (DOUBLE_QUOTES[c] === true) {\n    return '\"'\n  }\n\n  return c\n}\n\n/**\n * Strip last occurrence of textToStrip from text\n * @param {string} text\n * @param {string} textToStrip\n * @returns {string}\n */\nexport function stripLastOccurrence (text, textToStrip) {\n  const index = text.lastIndexOf(textToStrip)\n  return (index !== -1)\n    ? text.substring(0, index) + text.substring(index + 1)\n    : text\n}\n\n/**\n * Insert textToInsert into text before the last whitespace in text\n * @param {string} text\n * @param {string} textToInsert\n * @returns {string}\n */\nexport function insertBeforeLastWhitespace (text, textToInsert) {\n  let index = text.length\n\n  if (!isWhitespace(text[index - 1])) {\n    // no trailing whitespaces\n    return text + textToInsert\n  }\n\n  while (isWhitespace(text[index - 1])) {\n    index--\n  }\n\n  return text.substring(0, index) + textToInsert + text.substring(index)\n}\n\n/**\n * Insert textToInsert at index in text\n * @param {string} text\n * @param {string} textToInsert\n * @param {number} index\n * @returns {string}\n */\nexport function insertAtIndex (text, textToInsert, index) {\n  return text.substring(0, index) + textToInsert + text.substring(index)\n}\n", "import JsonRepairError from './JsonRepairError.js'\nimport {\n  insertAtIndex,\n  insertBeforeLastWhitespace,\n  isAlpha,\n  isDigit,\n  isDoubleQuote,\n  isHex,\n  isQuote,\n  isSingleQuote,\n  isSpecialWhitespace,\n  isWhitespace,\n  normalizeQuote,\n  normalizeWhitespace,\n  stripLastOccurrence\n} from './stringUtils.js'\n\n// token types enumeration\nconst DELIMITER = 0\nconst NUMBER = 1\nconst STRING = 2\nconst SYMBOL = 3\nconst WHITESPACE = 4\nconst COMMENT = 5\nconst UNKNOWN = 6\n\n/**\n * @typedef {DELIMITER | NUMBER | STRING | SYMBOL | WHITESPACE | COMMENT | UNKNOWN} TokenType\n */\n\n// map with all delimiters\nconst DELIMITERS = {\n  '': true,\n  '{': true,\n  '}': true,\n  '[': true,\n  ']': true,\n  ':': true,\n  ',': true,\n\n  // for JSONP and MongoDB data type notation\n  '(': true,\n  ')': true,\n  ';': true,\n\n  // for string concatenation\n  '+': true\n}\n\n// map with all escape characters\nconst ESCAPE_CHARACTERS = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // \\u is handled by getToken()\n}\n\n// TODO: can we unify CONTROL_CHARACTERS and ESCAPE_CHARACTERS?\nconst CONTROL_CHARACTERS = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n}\n\nconst SYMBOLS = {\n  null: 'null',\n  true: 'true',\n  false: 'false'\n}\n\nconst PYTHON_SYMBOLS = {\n  None: 'null',\n  True: 'true',\n  False: 'false'\n}\n\nlet input = '' // current json text\nlet output = '' // generated output\nlet index = 0 // current index in text\nlet c = '' // current token character in text\nlet token = '' // current token\nlet tokenType = UNKNOWN // type of current token\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     jsonrepair('{name: \\'John\\'}\") // '{\"name\": \"John\"}'\n *\n * @param {string} text\n * @return {string}\n */\nexport default function jsonrepair (text) {\n  // initialize\n  input = text\n  output = ''\n  index = 0\n  c = input.charAt(0)\n  token = ''\n  tokenType = UNKNOWN\n\n  // get first token\n  processNextToken()\n\n  const rootLevelTokenType = tokenType\n\n  // parse everything\n  parseObject()\n\n  // ignore trailing comma\n  skipComma()\n\n  if (token === '') {\n    // reached the end of the document properly\n    return output\n  }\n\n  if (rootLevelTokenType === tokenType && tokenIsStartOfValue()) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n\n    let stashedOutput = ''\n\n    while (rootLevelTokenType === tokenType && tokenIsStartOfValue()) {\n      output = insertBeforeLastWhitespace(output, ',')\n\n      stashedOutput += output\n      output = ''\n\n      // parse next newline delimited item\n      parseObject()\n\n      // ignore trailing comma\n      skipComma()\n    }\n\n    // wrap the output in an array\n    return `[\\n${stashedOutput}${output}\\n]`\n  }\n\n  throw new JsonRepairError('Unexpected characters', index - token.length)\n}\n\n/**\n * Get the next character from the expression.\n * The character is stored into the char c. If the end of the expression is\n * reached, the function puts an empty string in c.\n */\nfunction next () {\n  index++\n  c = input.charAt(index)\n  // Note: not using input[index] because that returns undefined when index is out of range\n}\n\n/**\n * Special version of the function next, used to parse escaped strings\n */\nfunction nextSkipEscape () {\n  next()\n  if (c === '\\\\') {\n    next()\n  }\n}\n\n/**\n * check whether the current token is the start of a value:\n * object, array, number, string, or symbol\n * @returns {boolean}\n */\nfunction tokenIsStartOfValue () {\n  return (tokenType === DELIMITER && (token === '[' || token === '{')) ||\n    tokenType === STRING ||\n    tokenType === NUMBER ||\n    tokenType === SYMBOL\n}\n\n/**\n * check whether the current token is the start of a key (or possible key):\n * number, string, or symbol\n * @returns {boolean}\n */\nfunction tokenIsStartOfKey () {\n  return tokenType === STRING ||\n    tokenType === NUMBER ||\n    tokenType === SYMBOL\n}\n\n/**\n * Process the previous token, and get next token in the current text\n */\nfunction processNextToken () {\n  output += token\n\n  tokenType = UNKNOWN\n  token = ''\n\n  getTokenDelimiter()\n\n  if (tokenType === WHITESPACE) {\n    // we leave the whitespace as it is, except replacing special white\n    // space character\n    token = normalizeWhitespace(token)\n    processNextToken()\n  }\n\n  if (tokenType === COMMENT) {\n    // ignore comments\n    tokenType = UNKNOWN\n    token = ''\n\n    processNextToken()\n  }\n}\n\nfunction skipComma () {\n  if (token === ',') {\n    token = ''\n    tokenType = UNKNOWN\n    processNextToken()\n  }\n}\n\n// check for delimiters like ':', '{', ']'\nfunction getTokenDelimiter () {\n  if (DELIMITERS[c]) {\n    tokenType = DELIMITER\n    token = c\n    next()\n    return\n  }\n\n  getTokenNumber()\n}\n\n// check for a number like \"2.3e+5\"\nfunction getTokenNumber () {\n  if (isDigit(c) || c === '-') {\n    tokenType = NUMBER\n\n    if (c === '-') {\n      token += c\n      next()\n\n      if (!isDigit(c)) {\n        throw new JsonRepairError('Invalid number, digit expected', index)\n      }\n    } else if (c === '0') {\n      token += c\n      next()\n    } else {\n      // digit 1-9, nothing extra to do\n    }\n\n    while (isDigit(c)) {\n      token += c\n      next()\n    }\n\n    if (c === '.') {\n      token += c\n      next()\n\n      if (!isDigit(c)) {\n        throw new JsonRepairError('Invalid number, digit expected', index)\n      }\n\n      while (isDigit(c)) {\n        token += c\n        next()\n      }\n    }\n\n    if (c === 'e' || c === 'E') {\n      token += c\n      next()\n\n      if (c === '+' || c === '-') {\n        token += c\n        next()\n      }\n\n      if (!isDigit(c)) {\n        throw new JsonRepairError('Invalid number, digit expected', index)\n      }\n\n      while (isDigit(c)) {\n        token += c\n        next()\n      }\n    }\n\n    return\n  }\n\n  getTokenEscapedString()\n}\n\n// get a token string like '\\\"hello world\\\"'\nfunction getTokenEscapedString () {\n  if (c === '\\\\' && input.charAt(index + 1) === '\"') {\n    // an escaped piece of JSON\n    next()\n    getTokenString(nextSkipEscape)\n  } else {\n    getTokenString(next)\n  }\n}\n\n// get a token string like '\"hello world\"'\nfunction getTokenString (getNext) {\n  if (isQuote(c)) {\n    const quote = normalizeQuote(c)\n    const isEndQuote = isSingleQuote(c) ? isSingleQuote : isDoubleQuote\n\n    token += '\"' // output valid double quote\n    tokenType = STRING\n    getNext()\n\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (c !== '' && !isEndQuote(c)) {\n      if (c === '\\\\') {\n        // handle escape characters\n        getNext()\n\n        const unescaped = ESCAPE_CHARACTERS[c]\n        if (unescaped !== undefined) {\n          token += '\\\\' + c\n          getNext()\n        } else if (c === 'u') {\n          // parse escaped unicode character, like '\\\\u260E'\n          token += '\\\\u'\n          getNext()\n\n          for (let u = 0; u < 4; u++) {\n            if (!isHex(c)) {\n              throw new JsonRepairError('Invalid unicode character', index - token.length)\n            }\n            token += c\n            getNext()\n          }\n        } else if (c === '\\'') {\n          // escaped single quote character -> remove the escape character\n          token += '\\''\n          getNext()\n        } else {\n          throw new JsonRepairError('Invalid escape character \"\\\\' + c + '\"', index)\n        }\n      } else if (CONTROL_CHARACTERS[c]) {\n        // unescaped special character\n        // fix by adding an escape character\n        token += CONTROL_CHARACTERS[c]\n        getNext()\n      } else if (c === '\"') {\n        // unescaped double quote -> escape it\n        token += '\\\\\"'\n        getNext()\n      } else {\n        // a regular character\n        token += c\n        getNext()\n      }\n    }\n\n    if (normalizeQuote(c) !== quote) {\n      throw new JsonRepairError('End of string expected', index - token.length)\n    }\n    token += '\"' // output valid double quote\n    getNext()\n\n    return\n  }\n\n  getTokenAlpha()\n}\n\n// check for symbols (true, false, null)\nfunction getTokenAlpha () {\n  if (isAlpha(c)) {\n    tokenType = SYMBOL\n\n    while (isAlpha(c) || isDigit(c) || c === '$') {\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  getTokenWhitespace()\n}\n\n// get whitespaces: space, tab, newline, and carriage return\nfunction getTokenWhitespace () {\n  if (isWhitespace(c) || isSpecialWhitespace(c)) {\n    tokenType = WHITESPACE\n\n    while (isWhitespace(c) || isSpecialWhitespace(c)) {\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  getTokenComment()\n}\n\nfunction getTokenComment () {\n  // find a block comment '/* ... */'\n  if (c === '/' && input[index + 1] === '*') {\n    tokenType = COMMENT\n\n    while (c !== '' && (c !== '*' || (c === '*' && input[index + 1] !== '/'))) {\n      token += c\n      next()\n    }\n\n    if (c === '*' && input[index + 1] === '/') {\n      token += c\n      next()\n\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  // find a comment '// ...'\n  if (c === '/' && input[index + 1] === '/') {\n    tokenType = COMMENT\n\n    while (c !== '' && c !== '\\n') {\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  getTokenUnknown()\n}\n\n// something unknown is found, wrong characters -> a syntax error\nfunction getTokenUnknown () {\n  tokenType = UNKNOWN\n\n  while (c !== '') {\n    token += c\n    next()\n  }\n\n  throw new JsonRepairError('Syntax error in part \"' + token + '\"', index - token.length)\n}\n\n/**\n * Parse an object like '{\"key\": \"value\"}'\n * @return {*}\n */\nfunction parseObject () {\n  if (tokenType === DELIMITER && token === '{') {\n    processNextToken()\n\n    // TODO: can we make this redundant?\n    if (tokenType === DELIMITER && token === '}') {\n      // empty object\n      processNextToken()\n      return\n    }\n\n    while (true) {\n      // parse key\n\n      if (tokenType === SYMBOL || tokenType === NUMBER) {\n        // unquoted key -> add quotes around it, change it into a string\n        tokenType = STRING\n        token = `\"${token}\"`\n      }\n\n      if (tokenType !== STRING) {\n        // TODO: handle ambiguous cases like '[{\"a\":1,{\"b\":2}]' which could be an array with two objects or one\n        throw new JsonRepairError('Object key expected', index - token.length)\n      }\n      processNextToken()\n\n      // parse colon (key/value separator)\n      if (tokenType === DELIMITER && token === ':') {\n        processNextToken()\n      } else {\n        if (tokenIsStartOfValue()) {\n          // we expect a colon here, but got the start of a value\n          // -> insert a colon before any inserted whitespaces at the end of output\n          output = insertBeforeLastWhitespace(output, ':')\n        } else {\n          throw new JsonRepairError('Colon expected', index - token.length)\n        }\n      }\n\n      // parse value\n      parseObject()\n\n      // parse comma (key/value pair separator)\n      if (tokenType === DELIMITER && token === ',') {\n        processNextToken()\n\n        if (tokenType === DELIMITER && token === '}') {\n          // we've just passed a trailing comma -> remove the trailing comma\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n\n        if (token === '') {\n          // end of json reached, but missing }\n          // Strip the missing comma (the closing bracket will be added later)\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n      } else {\n        if (tokenIsStartOfKey()) {\n          // we expect a comma here, but got the start of a new key\n          // -> insert a comma before any inserted whitespaces at the end of output\n          output = insertBeforeLastWhitespace(output, ',')\n        } else {\n          break\n        }\n      }\n    }\n\n    if (tokenType === DELIMITER && token === '}') {\n      processNextToken()\n    } else {\n      // missing end bracket -> insert the missing bracket\n      output = insertBeforeLastWhitespace(output, '}')\n    }\n\n    return\n  }\n\n  parseArray()\n}\n\n/**\n * Parse an object like '[\"item1\", \"item2\", ...]'\n */\nfunction parseArray () {\n  if (tokenType === DELIMITER && token === '[') {\n    processNextToken()\n\n    if (tokenType === DELIMITER && token === ']') {\n      // empty array\n      processNextToken()\n      return\n    }\n\n    while (true) {\n      // parse item\n      parseObject()\n\n      // parse comma (item separator)\n      if (tokenType === DELIMITER && token === ',') {\n        processNextToken()\n\n        if (tokenType === DELIMITER && token === ']') {\n          // we've just passed a trailing comma -> remove the trailing comma\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n\n        if (token === '') {\n          // end of json reached, but missing ]\n          // Strip the missing comma (the closing bracket will be added later)\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n      } else {\n        if (tokenIsStartOfValue()) {\n          // we expect a comma here, but got the start of a new item\n          // -> insert a comma before any inserted whitespaces at the end of output\n          output = insertBeforeLastWhitespace(output, ',')\n        } else {\n          break\n        }\n      }\n    }\n\n    if (tokenType === DELIMITER && token === ']') {\n      processNextToken()\n    } else {\n      // missing end bracket -> insert the missing bracket\n      output = insertBeforeLastWhitespace(output, ']')\n    }\n    return\n  }\n\n  parseString()\n}\n\n/**\n * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n */\nfunction parseString () {\n  if (tokenType === STRING) {\n    processNextToken()\n\n    while (tokenType === DELIMITER && token === '+') {\n      // string concatenation like \"hello\" + \"world\"\n      token = '' // don't output the concatenation\n      processNextToken()\n\n      if (tokenType === STRING) {\n        // concatenate with the previous string\n        const endIndex = output.lastIndexOf('\"')\n        output = output.substring(0, endIndex) + token.substring(1)\n        token = ''\n        processNextToken()\n      }\n    }\n\n    return\n  }\n\n  parseNumber()\n}\n\n/**\n * Parse a number\n */\nfunction parseNumber () {\n  if (tokenType === NUMBER) {\n    processNextToken()\n    return\n  }\n\n  parseSymbol()\n}\n\n/**\n * Parse constants true, false, null\n */\nfunction parseSymbol () {\n  if (tokenType === SYMBOL) {\n    // a supported symbol: true, false, null\n    if (SYMBOLS[token]) {\n      processNextToken()\n      return\n    }\n\n    // for example replace None with null\n    if (PYTHON_SYMBOLS[token]) {\n      token = PYTHON_SYMBOLS[token]\n      processNextToken()\n      return\n    }\n\n    // make a copy of the symbol, let's see what comes next\n    const symbol = token\n    const symbolIndex = output.length\n    token = ''\n    processNextToken()\n\n    // if (tokenType === DELIMITER && token === '(') {\n    if (tokenType === DELIMITER && token === '(') {\n      // a MongoDB function call or JSONP call\n      // Can be a MongoDB data type like in {\"_id\": ObjectId(\"123\")}\n      // token = '' // do not output the function name\n      // processNextToken()\n\n      // next()\n      token = '' // do not output the ( character\n      processNextToken()\n\n      // process the part inside the brackets\n      parseObject()\n\n      // skip the closing bracket \")\" and \");\"\n      if (tokenType === DELIMITER && token === ')') {\n        token = '' // do not output the ) character\n        processNextToken()\n\n        if (tokenType === DELIMITER && token === ';') {\n          token = '' // do not output the semicolon character\n          processNextToken()\n        }\n      }\n\n      return\n    }\n\n    // unknown symbol => turn into in a string\n    // it is possible that by reading the next token we already inserted\n    // extra spaces in the output which should be inside the string,\n    // hence the symbolIndex\n    output = insertAtIndex(output, `\"${symbol}`, symbolIndex)\n    while (tokenType === SYMBOL || tokenType === NUMBER) {\n      processNextToken()\n    }\n    output += '\"'\n\n    return\n  }\n\n  parseEnd()\n}\n\n/**\n * Evaluated when the expression is not yet ended but expected to end\n */\nfunction parseEnd () {\n  if (token === '') {\n    // syntax error or unexpected end of expression\n    throw new JsonRepairError('Unexpected end of json string', index - token.length)\n  } else {\n    throw new JsonRepairError('Value expected', index - token.length)\n  }\n}\n"],
  "mappings": "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",
  "names": ["message", "char", "JsonRepairError", "SyntaxError", "stack", "Error", "prototype", "constructor", "SINGLE_QUOTES", "DOUBLE_QUOTES", "isAlpha", "c", "ALPHA_REGEX", "test", "isHex", "HEX_REGEX", "isDigit", "DIGIT_REGEX", "isWhitespace", "isSpecialWhitespace", "normalizeWhitespace", "text", "normalized", "i", "length", "char", "isQuote", "isSingleQuote", "isDoubleQuote", "normalizeQuote", "stripLastOccurrence", "textToStrip", "index", "lastIndexOf", "substring", "insertBeforeLastWhitespace", "textToInsert", "insertAtIndex", "DELIMITER", "NUMBER", "STRING", "SYMBOL", "WHITESPACE", "COMMENT", "UNKNOWN", "DELIMITERS", "ESCAPE_CHARACTERS", "b", "f", "n", "r", "t", "CONTROL_CHARACTERS", "SYMBOLS", "null", "true", "false", "PYTHON_SYMBOLS", "None", "True", "False", "input", "output", "index", "c", "token", "tokenType", "text", "charAt", "processNextToken", "rootLevelTokenType", "parseObject", "skipComma", "tokenIsStartOfValue", "stashedOutput", "insertBeforeLastWhitespace", "JsonRepairError", "length", "next", "nextSkipEscape", "tokenIsStartOfKey", "getTokenDelimiter", "normalizeWhitespace", "getTokenNumber", "isDigit", "getTokenEscapedString", "getTokenString", "getNext", "isQuote", "quote", "normalizeQuote", "isEndQuote", "isSingleQuote", "isDoubleQuote", "unescaped", "undefined", "u", "isHex", "getTokenAlpha", "isAlpha", "getTokenWhitespace", "isWhitespace", "isSpecialWhitespace", "getTokenComment", "getTokenUnknown", "stripLastOccurrence", "parseArray", "parseString", "endIndex", "lastIndexOf", "substring", "parseNumber", "parseSymbol", "symbol", "symbolIndex", "insertAtIndex", "parseEnd"]
}
