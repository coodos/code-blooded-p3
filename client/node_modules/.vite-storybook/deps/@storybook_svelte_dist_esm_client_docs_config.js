import {
  SvelteComponentDev,
  assign,
  check_outros,
  claim_component,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  safe_not_equal,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-4PYYXLO3.js";
import {
  SNIPPET_RENDERED,
  SourceType,
  enhanceArgTypes
} from "./chunk-DV7GRO77.js";
import "./chunk-FRIVSEHK.js";
import "./chunk-FYEOGHJK.js";
import "./chunk-H46JHKJF.js";
import {
  require_react
} from "./chunk-C3M2AGI3.js";
import "./chunk-SCLW2GIS.js";
import "./chunk-CYE57BTX.js";
import "./chunk-VS4IOSXL.js";
import "./chunk-YGJUHNSU.js";
import "./chunk-YPBZOUWZ.js";
import "./chunk-MBEM7IVK.js";
import "./chunk-DL4YUJ3A.js";
import "./chunk-473JB3JH.js";
import "./chunk-A4EWK22L.js";
import "./chunk-HA6TNTS6.js";
import "./chunk-2B4CT4R5.js";
import "./chunk-MIELV54Y.js";
import "./chunk-VMEA5U6U.js";
import "./chunk-RR5FGD7S.js";
import "./chunk-SMF7HVWG.js";
import "./chunk-RS2AFSDR.js";
import "./chunk-EEZ6PRT3.js";
import "./chunk-DXHARYZY.js";
import "./chunk-Y7GOSMO5.js";
import "./chunk-QMBWRNGB.js";
import "./chunk-CLLV6UDW.js";
import "./chunk-DBFPTQY5.js";
import "./chunk-PWPBF2IC.js";
import "./chunk-JNMJK6EV.js";
import "./chunk-Z6OHBJ6T.js";
import "./chunk-6B5SQVI7.js";
import "./chunk-X4ETYLIO.js";
import "./chunk-2A47XIO5.js";
import "./chunk-ZQB4AWHS.js";
import "./chunk-DGBCWGLY.js";
import "./chunk-KSVDCPBP.js";
import "./chunk-KKHTY7N3.js";
import "./chunk-CX5FUPZZ.js";
import "./chunk-CINROI6V.js";
import "./chunk-WGOZYHNP.js";
import "./chunk-X2T7JFOG.js";
import "./chunk-F4UNMNUQ.js";
import "./chunk-K3T4HMST.js";
import {
  addons,
  useEffect
} from "./chunk-D4RAKN6G.js";
import "./chunk-JFARQTUS.js";
import "./chunk-A3OGDT64.js";
import "./chunk-GB23VXIS.js";
import "./chunk-4CTSTLBM.js";
import "./chunk-ODSDVYJE.js";
import "./chunk-C3PCYSX7.js";
import "./chunk-WWEYPR3O.js";
import "./chunk-QHLK3LWB.js";
import "./chunk-WLLOGUM4.js";
import "./chunk-EEXVRB3V.js";
import "./chunk-BXAX3M5R.js";
import "./chunk-WN4MXLH6.js";
import "./chunk-QPGFLCB4.js";
import "./chunk-EOFYT53F.js";
import "./chunk-IM6TSS52.js";
import "./chunk-TD2H7XDF.js";
import "./chunk-U6RSZVM4.js";
import "./chunk-35MBE3PB.js";
import "./chunk-YKNJOU7U.js";
import "./chunk-GKOJNFYH.js";
import "./chunk-FK4PCQKD.js";
import "./chunk-RTZSCR66.js";
import "./chunk-RBOIDH5C.js";
import "./chunk-FTHKUHE7.js";
import "./chunk-M62M5TYI.js";
import "./chunk-6OWOWFNX.js";
import "./chunk-IJVR6UYI.js";
import "./chunk-3W4ELSFD.js";
import {
  logger,
  once,
  require_es_array_iterator,
  require_es_regexp_exec,
  require_es_string_iterator
} from "./chunk-26ANIFV2.js";
import "./chunk-HCAL2U5D.js";
import "./chunk-KBGTN2E4.js";
import {
  __toESM
} from "./chunk-BHN6OJC3.js";

// ../node_modules/@storybook/svelte/dist/esm/client/docs/extractArgTypes.js
function hasKeyword(keyword, keywords) {
  return keywords ? keywords.find(function(k) {
    return k.name === keyword;
  }) != null : false;
}
var extractArgTypes = function extractArgTypes2(component) {
  try {
    var docgen = component.__docgen;
    if (docgen) {
      return createArgTypes(docgen);
    }
  } catch (err) {
    logger.log("Error extracting argTypes: ".concat(err));
  }
  return {};
};
var createArgTypes = function createArgTypes2(docgen) {
  var results = {};
  docgen.data.forEach(function(item) {
    var _item$type, _item$type2;
    results[item.name] = {
      control: parseTypeToControl(item.type),
      name: item.name,
      description: item.description,
      type: {
        required: hasKeyword("required", item.keywords),
        name: (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.text
      },
      table: {
        type: {
          summary: (_item$type2 = item.type) === null || _item$type2 === void 0 ? void 0 : _item$type2.text
        },
        defaultValue: {
          summary: item.defaultValue
        },
        category: "properties"
      }
    };
  });
  docgen.events.forEach(function(item) {
    results["event_".concat(item.name)] = {
      name: item.name,
      description: item.description,
      type: {
        name: "other",
        value: "void"
      },
      table: {
        category: "events"
      }
    };
  });
  docgen.slots.forEach(function(item) {
    var _item$params;
    results["slot_".concat(item.name)] = {
      name: item.name,
      description: [item.description, (_item$params = item.params) === null || _item$params === void 0 ? void 0 : _item$params.map(function(p) {
        return "`".concat(p.name, "`");
      }).join(" ")].filter(function(p) {
        return p;
      }).join("\n\n"),
      type: {
        name: "other",
        value: "void"
      },
      table: {
        category: "slots"
      }
    };
  });
  return results;
};
var parseTypeToControl = function parseTypeToControl2(type) {
  if (!type) {
    return null;
  }
  if (type.kind === "type") {
    switch (type.type) {
      case "string":
        return {
          type: "text"
        };
      case "enum":
        return {
          type: "radio"
        };
      case "any":
        return {
          type: "object"
        };
      default:
        return {
          type: type.type
        };
    }
  } else if (type.kind === "union") {
    if (Array.isArray(type.type) && !type.type.find(function(t) {
      return t.type !== "string";
    })) {
      return {
        type: "radio",
        options: type.type.filter(function(t) {
          return t.kind === "const";
        }).map(function(t) {
          return t.value;
        })
      };
    }
  }
  return null;
};

// ../node_modules/@storybook/svelte/dist/esm/client/docs/extractComponentDescription.js
function extractComponentDescription(component) {
  if (!component) {
    return null;
  }
  var _component$__docgen = component.__docgen, __docgen = _component$__docgen === void 0 ? {} : _component$__docgen;
  return __docgen.description;
}

// ../node_modules/@storybook/svelte/dist/esm/client/docs/prepareForInline.js
var import_react = __toESM(require_react());

// ../node_modules/@storybook/svelte/templates/HOC.svelte
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[1]];
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[1])]) : {};
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HOC", slots, []);
  let { storyFn } = $$props;
  let { Component: component, props } = storyFn();
  $$self.$$.on_mount.push(function() {
    if (storyFn === void 0 && !("storyFn" in $$props || $$self.$$.bound[$$self.$$.props["storyFn"]])) {
      console.warn("<HOC> was created without expected prop 'storyFn'");
    }
  });
  const writable_props = ["storyFn"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HOC> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("storyFn" in $$props2)
      $$invalidate(2, storyFn = $$props2.storyFn);
  };
  $$self.$capture_state = () => ({ storyFn, component, props });
  $$self.$inject_state = ($$props2) => {
    if ("storyFn" in $$props2)
      $$invalidate(2, storyFn = $$props2.storyFn);
    if ("component" in $$props2)
      $$invalidate(0, component = $$props2.component);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [component, props, storyFn];
}
var HOC = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { storyFn: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HOC",
      options,
      id: create_fragment.name
    });
  }
  get storyFn() {
    throw new Error("<HOC>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set storyFn(value) {
    throw new Error("<HOC>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HOC_default = HOC;

// ../node_modules/@storybook/svelte/dist/esm/client/docs/prepareForInline.js
var prepareForInline = function prepareForInline2(storyFn) {
  var el = import_react.default.useRef(null);
  import_react.default.useEffect(function() {
    var root = new HOC_default({
      target: el.current,
      props: {
        storyFn
      }
    });
    return function() {
      return root.$destroy();
    };
  });
  return import_react.default.createElement("div", {
    ref: el
  });
};

// ../node_modules/@storybook/svelte/dist/esm/client/docs/sourceDecorator.js
var import_es_array_iterator = __toESM(require_es_array_iterator());
var import_es_string_iterator = __toESM(require_es_string_iterator());
var import_es_regexp_exec = __toESM(require_es_regexp_exec());
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var skipSourceRender = function skipSourceRender2(context) {
  var _context$parameters$d;
  var sourceParams = context === null || context === void 0 ? void 0 : (_context$parameters$d = context.parameters.docs) === null || _context$parameters$d === void 0 ? void 0 : _context$parameters$d.source;
  var isArgsStory = context === null || context === void 0 ? void 0 : context.parameters.__isArgsStory;
  if ((sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.type) === SourceType.DYNAMIC) {
    return false;
  }
  return !isArgsStory || (sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.code) || (sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.type) === SourceType.CODE;
};
function toSvelteProperty(key, value, argTypes) {
  if (value === void 0 || value === null) {
    return null;
  }
  if (argTypes[key] && argTypes[key].defaultValue === value) {
    return null;
  }
  if (value === true) {
    return key;
  }
  if (typeof value === "string") {
    return "".concat(key, "=").concat(JSON.stringify(value));
  }
  return "".concat(key, "={").concat(JSON.stringify(value), "}");
}
function getComponentName(component) {
  if (component == null) {
    return null;
  }
  var _component$__docgen = component.__docgen, __docgen = _component$__docgen === void 0 ? {} : _component$__docgen;
  var name = __docgen.name;
  if (!name) {
    return component.name;
  }
  if (name.endsWith(".svelte")) {
    name = name.substring(0, name.length - 7);
  }
  return name;
}
function generateSvelteSource(component, args, argTypes, slotProperty) {
  var name = getComponentName(component);
  if (!name) {
    return null;
  }
  var props = Object.entries(args).filter(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 1), k = _ref2[0];
    return k !== slotProperty;
  }).map(function(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), k = _ref4[0], v = _ref4[1];
    return toSvelteProperty(k, v, argTypes);
  }).filter(function(p) {
    return p;
  }).join(" ");
  var slotValue = slotProperty ? args[slotProperty] : null;
  if (slotValue) {
    return "<".concat(name, " ").concat(props, ">\n    ").concat(slotValue, "\n</").concat(name, ">");
  }
  return "<".concat(name, " ").concat(props, "/>");
}
function getWrapperProperties(component) {
  var __docgen = component.__docgen;
  if (!__docgen) {
    return {
      wrapper: false
    };
  }
  if (!__docgen.keywords.find(function(kw) {
    return kw.name === "wrapper";
  })) {
    return {
      wrapper: false
    };
  }
  var slotProp = __docgen.data.find(function(prop) {
    return prop.keywords.find(function(kw) {
      return kw.name === "slot";
    });
  });
  return {
    wrapper: true,
    slotProperty: slotProp === null || slotProp === void 0 ? void 0 : slotProp.name
  };
}
var sourceDecorator = function sourceDecorator2(storyFn, context) {
  var channel = addons.getChannel();
  var skip = skipSourceRender(context);
  var story = storyFn();
  var source;
  useEffect(function() {
    if (!skip && source) {
      channel.emit(SNIPPET_RENDERED, (context || {}).id, source);
    }
  });
  if (skip) {
    return story;
  }
  var _ref5 = context || {}, _ref5$parameters = _ref5.parameters, parameters2 = _ref5$parameters === void 0 ? {} : _ref5$parameters, _ref5$args = _ref5.args, args = _ref5$args === void 0 ? {} : _ref5$args, ctxtComponent = _ref5.component;
  var _story$Component = story.Component, component = _story$Component === void 0 ? {} : _story$Component;
  var _getWrapperProperties = getWrapperProperties(component), wrapper = _getWrapperProperties.wrapper, slotProperty = _getWrapperProperties.slotProperty;
  if (wrapper) {
    if (parameters2.component) {
      once.warn("parameters.component is deprecated. Using context.component instead.");
    }
    component = ctxtComponent;
  }
  source = generateSvelteSource(component, args, context === null || context === void 0 ? void 0 : context.argTypes, slotProperty);
  return story;
};

// ../node_modules/@storybook/svelte/dist/esm/client/docs/config.js
var parameters = {
  docs: {
    inlineStories: true,
    prepareForInline,
    extractArgTypes,
    extractComponentDescription
  }
};
var decorators = [sourceDecorator];
var argTypesEnhancers = [enhanceArgTypes];
export {
  argTypesEnhancers,
  decorators,
  parameters
};
//# sourceMappingURL=@storybook_svelte_dist_esm_client_docs_config.js.map
