import {
  SvelteComponentDev,
  assign,
  binding_callbacks,
  check_outros,
  claim_component,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onMount,
  safe_not_equal,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-4PYYXLO3.js";
import {
  sanitizeStoryContextUpdate
} from "./chunk-VS4IOSXL.js";
import {
  esm_default
} from "./chunk-3W4ELSFD.js";
import {
  require_window
} from "./chunk-KBGTN2E4.js";
import {
  __toESM
} from "./chunk-BHN6OJC3.js";

// ../node_modules/@storybook/svelte/templates/SlotDecorator.svelte
var { Object: Object_1 } = globals;
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[3]];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[9](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[3])]) : {};
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[9](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[9](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(28:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[1]];
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[8](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[1])]) : {};
      if (dirty & 2076) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[8](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[8](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:0) {#if decorator}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[3]];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[7](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[3])]) : {};
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[7](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[7](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(25:2) <svelte:component this={decorator} {...decoratorProps} bind:this={decoratorInstance}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlotDecorator", slots, []);
  let { decorator } = $$props;
  let { decoratorProps = {} } = $$props;
  let { component } = $$props;
  let { props = {} } = $$props;
  let { on } = $$props;
  let instance2;
  let decoratorInstance;
  function getInstance() {
    return instance2 || decoratorInstance;
  }
  if (on) {
    Object.keys(on).forEach((eventName) => {
      onMount(() => getInstance().$on(eventName, on[eventName]));
    });
  }
  $$self.$$.on_mount.push(function() {
    if (decorator === void 0 && !("decorator" in $$props || $$self.$$.bound[$$self.$$.props["decorator"]])) {
      console.warn("<SlotDecorator> was created without expected prop 'decorator'");
    }
    if (component === void 0 && !("component" in $$props || $$self.$$.bound[$$self.$$.props["component"]])) {
      console.warn("<SlotDecorator> was created without expected prop 'component'");
    }
    if (on === void 0 && !("on" in $$props || $$self.$$.bound[$$self.$$.props["on"]])) {
      console.warn("<SlotDecorator> was created without expected prop 'on'");
    }
  });
  const writable_props = ["decorator", "decoratorProps", "component", "props", "on"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SlotDecorator> was created with unknown prop '${key}'`);
  });
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      instance2 = $$value;
      $$invalidate(4, instance2);
    });
  }
  function switch_instance_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      decoratorInstance = $$value;
      $$invalidate(5, decoratorInstance);
    });
  }
  function switch_instance_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      instance2 = $$value;
      $$invalidate(4, instance2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("decoratorProps" in $$props2)
      $$invalidate(1, decoratorProps = $$props2.decoratorProps);
    if ("component" in $$props2)
      $$invalidate(2, component = $$props2.component);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("on" in $$props2)
      $$invalidate(6, on = $$props2.on);
  };
  $$self.$capture_state = () => ({
    onMount,
    decorator,
    decoratorProps,
    component,
    props,
    on,
    instance: instance2,
    decoratorInstance,
    getInstance
  });
  $$self.$inject_state = ($$props2) => {
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("decoratorProps" in $$props2)
      $$invalidate(1, decoratorProps = $$props2.decoratorProps);
    if ("component" in $$props2)
      $$invalidate(2, component = $$props2.component);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("on" in $$props2)
      $$invalidate(6, on = $$props2.on);
    if ("instance" in $$props2)
      $$invalidate(4, instance2 = $$props2.instance);
    if ("decoratorInstance" in $$props2)
      $$invalidate(5, decoratorInstance = $$props2.decoratorInstance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    decorator,
    decoratorProps,
    component,
    props,
    instance2,
    decoratorInstance,
    on,
    switch_instance_binding,
    switch_instance_binding_1,
    switch_instance_binding_2
  ];
}
var SlotDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      decorator: 0,
      decoratorProps: 1,
      component: 2,
      props: 3,
      on: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlotDecorator",
      options,
      id: create_fragment.name
    });
  }
  get decorator() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decoratorProps() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decoratorProps(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get on() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set on(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlotDecorator_default = SlotDecorator;

// ../node_modules/@storybook/svelte/dist/esm/client/preview/decorators.js
function isSvelteComponent(obj) {
  return obj.prototype && obj.prototype.$destroy !== void 0;
}
function unWrap(obj) {
  return obj && obj.default ? obj.default : obj;
}
function prepareStory(context, story, originalStory) {
  var result = unWrap(story);
  if (isSvelteComponent(result)) {
    result = {
      Component: result
    };
  }
  if (originalStory) {
    result = {
      Component: SlotDecorator_default,
      props: {
        decorator: unWrap(result.Component),
        decoratorProps: result.props,
        component: unWrap(originalStory.Component),
        props: originalStory.props,
        on: originalStory.on
      }
    };
  } else {
    var cpn = result.Component;
    if (!cpn) {
      cpn = context.component;
    }
    result.Component = unWrap(cpn);
  }
  return result;
}
function decorateStory(storyFn, decorators) {
  return decorators.reduce(function(previousStoryFn, decorator) {
    return function(context) {
      var story;
      var decoratedStory = decorator(function(update) {
        story = previousStoryFn(Object.assign({}, context, sanitizeStoryContextUpdate(update)));
        return story;
      }, context);
      if (!story) {
        story = previousStoryFn(context);
      }
      if (!decoratedStory || decoratedStory === story) {
        return story;
      }
      return prepareStory(context, decoratedStory, story);
    };
  }, function(context) {
    return prepareStory(context, storyFn(context));
  });
}

// ../node_modules/@storybook/svelte/dist/esm/client/preview/render.js
var import_global = __toESM(require_window());

// ../node_modules/@storybook/svelte/templates/PreviewRender.svelte
function create_fragment2(ctx) {
  let slotdecorator;
  let current;
  slotdecorator = new SlotDecorator_default({
    props: {
      decorator: ctx[3],
      decoratorProps: ctx[4],
      component: ctx[0],
      props: ctx[1],
      on: ctx[2]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(slotdecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(slotdecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(slotdecorator, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(slotdecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(slotdecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(slotdecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PreviewRender", slots, []);
  let { name } = $$props;
  let { kind } = $$props;
  let { storyFn } = $$props;
  let { showError } = $$props;
  const {
    Component,
    props = {},
    on,
    Wrapper,
    WrapperData = {}
  } = storyFn();
  if (!Component) {
    showError({
      title: `Expecting a Svelte component from the story: "${name}" of "${kind}".`,
      description: esm_default`
        Did you forget to return the Svelte component configuration from the story?
        Use "() => ({ Component: YourComponent, data: {} })"
        when defining the story.
      `
    });
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<PreviewRender> was created without expected prop 'name'");
    }
    if (kind === void 0 && !("kind" in $$props || $$self.$$.bound[$$self.$$.props["kind"]])) {
      console.warn("<PreviewRender> was created without expected prop 'kind'");
    }
    if (storyFn === void 0 && !("storyFn" in $$props || $$self.$$.bound[$$self.$$.props["storyFn"]])) {
      console.warn("<PreviewRender> was created without expected prop 'storyFn'");
    }
    if (showError === void 0 && !("showError" in $$props || $$self.$$.bound[$$self.$$.props["showError"]])) {
      console.warn("<PreviewRender> was created without expected prop 'showError'");
    }
  });
  const writable_props = ["name", "kind", "storyFn", "showError"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PreviewRender> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(5, name = $$props2.name);
    if ("kind" in $$props2)
      $$invalidate(6, kind = $$props2.kind);
    if ("storyFn" in $$props2)
      $$invalidate(7, storyFn = $$props2.storyFn);
    if ("showError" in $$props2)
      $$invalidate(8, showError = $$props2.showError);
  };
  $$self.$capture_state = () => ({
    SlotDecorator: SlotDecorator_default,
    dedent: esm_default,
    name,
    kind,
    storyFn,
    showError,
    Component,
    props,
    on,
    Wrapper,
    WrapperData
  });
  $$self.$inject_state = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(5, name = $$props2.name);
    if ("kind" in $$props2)
      $$invalidate(6, kind = $$props2.kind);
    if ("storyFn" in $$props2)
      $$invalidate(7, storyFn = $$props2.storyFn);
    if ("showError" in $$props2)
      $$invalidate(8, showError = $$props2.showError);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Component, props, on, Wrapper, WrapperData, name, kind, storyFn, showError];
}
var PreviewRender = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment2, safe_not_equal, {
      name: 5,
      kind: 6,
      storyFn: 7,
      showError: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PreviewRender",
      options,
      id: create_fragment2.name
    });
  }
  get name() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get storyFn() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set storyFn(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showError() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showError(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PreviewRender_default = PreviewRender;

// ../node_modules/@storybook/svelte/dist/esm/client/preview/render.js
var document = import_global.default.document;
var previousComponent = null;
function cleanUpPreviousStory() {
  if (!previousComponent) {
    return;
  }
  previousComponent.$destroy();
  previousComponent = null;
}
function renderToDOM(_ref, domElement) {
  var storyFn = _ref.storyFn, kind = _ref.kind, name = _ref.name, showMain = _ref.showMain, showError = _ref.showError;
  cleanUpPreviousStory();
  var target = document.getElementById("root");
  target.innerHTML = "";
  previousComponent = new PreviewRender_default({
    target,
    props: {
      storyFn,
      name,
      kind,
      showError
    }
  });
  showMain();
}
var render = function render2(args, context) {
  var id = context.id, Component = context.component;
  if (!Component) {
    throw new Error("Unable to render story ".concat(id, " as the component annotation is missing from the default export"));
  }
  return {
    Component,
    props: args
  };
};

export {
  decorateStory,
  renderToDOM,
  render
};
//# sourceMappingURL=chunk-K3BB4AM4.js.map
